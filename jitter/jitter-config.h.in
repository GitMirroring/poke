/* Jitter: host configuration header to install.

   Copyright (C) 2017, 2019, 2020, 2021 Luca Saiu
   Updated in 2021 by pEp foundation (JITTER_HOST_OS_IS_ANDROID)
   Updated in 2022 by Luca Saiu
   Written by Luca Saiu

   This file is part of GNU Jitter.

   GNU Jitter is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   GNU Jitter is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GNU Jitter.  If not, see <https://www.gnu.org/licenses/>. */


#ifndef JITTER_CONFIG_H_
#define JITTER_CONFIG_H_

/* This host-dependent file is installed and used in the definition of some
   fundamental types or features.  Macro names have a JITTER_ prefix in order to
   be safe for user code and prevent clashes.

   All of this is particularly useful for generated C code and templates, which
   must rely on information from an installed header rather than a configuration
   script.

   This file is included from both C and assembly, so it must contain only
   whitespace and preprocessor directives.  In particular, differenly from the
   purely C source files in Jitter, it does not use "" characters for
   sectioning. */


/* Data representation.
 * ************************************************************************** */

#undef JITTER_WORDS_BIGENDIAN


/* C types and data representation: type availability, size, alignment.
 * ************************************************************************** */

#undef JITTER_HAVE_LONG_LONG_INT
#undef JITTER_HAVE_UNSIGNED_LONG_LONG_INT
#undef JITTER_HAVE_LONG_DOUBLE

#undef JITTER_SIZEOF_VOID_P
#undef JITTER_SIZEOF_SHORT
#undef JITTER_SIZEOF_INT
#undef JITTER_SIZEOF_LONG
#undef JITTER_SIZEOF_LONG_LONG

#undef JITTER_SIZEOF_FLOAT
#undef JITTER_SIZEOF_DOUBLE
#undef JITTER_SIZEOF_LONG_DOUBLE

#undef JITTER_ALIGNOF_VOID_P
#undef JITTER_ALIGNOF_VOID_P_P
#undef JITTER_ALIGNOF_SHORT
#undef JITTER_ALIGNOF_INT
#undef JITTER_ALIGNOF_LONG
#undef JITTER_ALIGNOF_LONG_LONG

#undef JITTER_ALIGNOF_FLOAT
#undef JITTER_ALIGNOF_DOUBLE
#undef JITTER_ALIGNOF_LONG_DOUBLE


/* Machine features.
 * ************************************************************************** */

#undef JITTER_HAVE_ASSEMBLY
#undef JITTER_ENABLE_ASSEMBLY

/* Define if we know how to do things like switching sections and defining
   globals from inline assembly for this configuration. */
#undef JITTER_HAVE_KNOWN_BINARY_FORMAT

/* It is convenient to let C code access the architecture name. */
#undef JITTER_ASSEMBLY_SUBDIRECTORY


/* CPU architecture.
 * ************************************************************************** */

/* Define a CPU (architecture)-specific macro if the CPU is known and the
   user did not disable assembly support.  Not every architecture mentioned
   here has specific support, but this is still useful even for user code
   when deciding whether to enable optional optimisations, which can be
   achieved without need for configuration facilities other than what
   Jitter already provides.
   Where an architecture has 32-bit and 64-bit variants one macro is defined
   for both when the 64-bit variant is a very similar clean extension, as
   is the case for example with RISC-V, MIPS and PowerPC; the user may then
   conditionalise on JITTER_BYTES_PER_WORD (which is a CPP-time constant) if
   needed. 
   When the two variants of an architecture are radically different and
   incompatible two different macros are used here. */

/* Define if the CPU is Aarch64. */
#undef JITTER_HOST_CPU_IS_AARCH64

/* Define if the CPU is Alpha. */
#undef JITTER_HOST_CPU_IS_ALPHA

/* Define if the CPU is a 32-bit ARM.  The 64-bit version, Aarch64, is so
   different that it would make little sense to define one macro for both. */
#undef JITTER_HOST_CPU_IS_ARM

/* Define if the CPU is i386.  This is for 32-bit configurations only. */
#undef JITTER_HOST_CPU_IS_I386

/* Define if the CPU is some m68k variant. */
#undef JITTER_HOST_CPU_IS_M68K

/* Define if the CPU is a MIPS, either 32-bit or 64-bit. */
#undef JITTER_HOST_CPU_IS_MIPS

/* Define if the CPU is a MIPS, either 32-bit or 64-bit, release 6 or later.
   Release 6 introduces many useful but incompatible changes. */
#undef JITTER_HOST_CPU_IS_MIPS_R6_OR_LATER

/* Define if the CPU is a PA-RISC, either 32-bit or 64-bit. */
#undef JITTER_HOST_CPU_IS_PARISC

/* Define if the CPU is some POWER or PowerPC variant, either 32-bit or
   64-bit. */
#undef JITTER_HOST_CPU_IS_POWERPC

/* Define if the CPU is RISC-V, either 32-bit or 64-bit. */
#undef JITTER_HOST_CPU_IS_RISCV

/* Define if the CPU is any variant of S390. */
#undef JITTER_HOST_CPU_IS_S390

/* Define if the CPU is some SH variant. */
#undef JITTER_HOST_CPU_IS_SH

/* Define if the CPU is some SPARC variant, either 32-bit or 64-bit. */
#undef JITTER_HOST_CPU_IS_SPARC

/* Define if the CPU is x86_64. */
#undef JITTER_HOST_CPU_IS_X86_64


/* Operating system features.
 * ************************************************************************** */

/* System triplets. */
#undef JITTER_HOST_TRIPLET
#undef JITTER_BUILD_TRIPLET

#undef JITTER_HOST_OS_IS_GNU
#undef JITTER_HOST_OS_IS_GNU_HURD   /* FIXME: recognize this. */
#undef JITTER_HOST_OS_IS_GNU_LINUX  /* FIXME: recognize this. */
#undef JITTER_HOST_OS_IS_ANDROID
#undef JITTER_HOST_OS_IS_FREEBSD
#undef JITTER_HOST_OS_IS_NETBSD
#undef JITTER_HOST_OS_IS_OPENBSD
#undef JITTER_HOST_OS_IS_WINDOWS

/* Binary format.  ELF support may be disabled even on ELF systems, if the
   tools are old enough not to support .pushsection / .popsection with
   subsection numbers. */
#undef JITTER_HOST_OS_IS_ELF
#undef JITTER_HOST_OS_IS_COFF
#undef JITTER_HOST_OS_IS_MACHO
#undef JITTER_HAVE_SECTION_NOTE_GNU_STACK
#undef JITTER_HAVE_SECTION_NOTE_GNU_STACK_IN_ARM_SYNTAX

/* Assembler flavour. */
#undef JITTER_HOST_ASSEMBLER_IS_GNU


/* Libc features.
 * ************************************************************************** */

/* See configure.ac for the meaning of each macro. */

/* C functions or features. */
#undef JITTER_HAVE_MMAP_ANONYMOUS
#undef JITTER_HAVE_MPROTECT
#undef JITTER_HAVE_SETRLIMIT
#undef JITTER_HAVE_ALARM
#undef JITTER_HAVE_ALIGNED_ALLOC
#undef JITTER_HAVE_POSIX_MEMALIGN
#undef JITTER_HAVE_FLOCKFILE
#undef JITTER_HAVE_POPEN
#undef JITTER_HAVE_SIGACTION
#undef JITTER_HAVE_CLOCK_GETTIME
#undef JITTER_HAVE_SETITIMER
#undef JITTER_HAVE_SYSCONF
#undef JITTER_HAVE_GETPAGESIZE

/* Arguments for sysconf. */
#undef JITTER_HAVE__SC_PAGESIZE
#undef JITTER_HAVE__SC_PHYS_PAGES
#undef JITTER_HAVE__SC_AVPHYS_PAGES
#undef JITTER_HAVE__SC_NPROCESSORS_CONF
#undef JITTER_HAVE__SC_NPROCESSORS_ONLN
#undef JITTER_HAVE__SC_LEVEL1_ICACHE_SIZE
#undef JITTER_HAVE__SC_LEVEL1_DCACHE_SIZE
#undef JITTER_HAVE__SC_LEVEL2_CACHE_SIZE
#undef JITTER_HAVE__SC_LEVEL3_CACHE_SIZE
#undef JITTER_HAVE__SC_LEVEL4_CACHE_SIZE


/* System-specific features.
 * ************************************************************************** */

/* Some RISC-V systems provide a function __riscv_flush_icache for invalidating
   icache lines.  When that function is not available we fall back to the
   generic GCC builtin. */
#undef JITTER_HAVE___RISCV_FLUSH_ICACHE


/* External library availability.
 * ************************************************************************** */

/* This macro is defined iff GNU Readline is available, in which case the
   separate library libjitter-readline will be a wrapper using the actual
   library and depending on it; otherwise the wrapper library will use its own
   compatible but crude replacement.
   The convenient way of linking libjitter-readline (along with the actual GNU
   Readline library, when used) is by using
     jitter-config
   or the substitutions defined by JITTER_JITTER and JITTER_JITTER_SUBPACKAGE
   . */
#undef JITTER_HAVE_READLINE

/* This macro is defined iff GNU Libtextstyle is available, in which case the
   separate wrapper library libjitter-libtextstyle is also built.  However,
   since Libtextstyle is a large library and its usage should remain optional,
   having JITTER_HAVE_LIBTEXTSTYLE defined is not enough to actually enable
   its functionality.
   The user should define
     JITTER_WITH_LIBTEXTSTYLE
   on the command line *and* have JITTER_HAVE_LIBTEXTSTYLE defined in order for
   the functionality to be actually used. The convenient way of doing this is
   by using
     jitter-config
   or the substitutions defined by JITTER_JITTER and JITTER_JITTER_SUBPACKAGE .
   User code should conditionalise using only JITTER_WITH_LIBTEXTSTYLE : it is
   the build system's responsibility to define
     JITTER_WITH_LIBTEXTSTYLE
   on the command line only when the configuration supports it. */
#undef JITTER_HAVE_LIBTEXTSTYLE


/* External utility availability, features and options.
 * ************************************************************************** */

#undef JITTER_OBJDUMP
#undef JITTER_CROSS_OBJDUMP
#undef JITTER_OBJDUMP_OPTIONS


/* Jitter feature selection.
 * ************************************************************************** */

/* What the best dispatch is. */
#undef JITTER_BEST_DISPATCH_IS_SWITCH
#undef JITTER_BEST_DISPATCH_IS_DIRECT_THREADING
#undef JITTER_BEST_DISPATCH_IS_MINIMAL_THREADING
#undef JITTER_BEST_DISPATCH_IS_NO_THREADING

/* The best dispatch name as a string literal, respectively all-uppercase with
   underscores separating words and lowercase with dashes separating words.
   These are always defined. */
#undef JITTER_BEST_DISPATCH_NAME_LOWER
#undef JITTER_BEST_DISPATCH_NAME_UPPER

/* Defect replacement debugging.  No more than one of these features can be
   defined -- Jitter's configure script enforces this restriction.  With
   JITTER_DEFECT_REPLACEMENT_ALL_POSSIBLE a Jittery VM replaces every
   potentially defective option, even if not needed: this is useful for
   debugging Jitter.  With JITTER_DEFECT_REPLACEMENT_NEVER a Jittery VM still
   checks for defects but actually performs no replacement; this is dangerous
   and must not be used in production, as it allows the generation of subtly
   incorrect code.
   These macros have an effect only with minimal-threading and no-threading
   dispatches: simple dispatches need no replacements becasue they cannot
   generate defects. */
#undef JITTER_DEFECT_REPLACEMENT_ALL_POSSIBLE
#undef JITTER_DEFECT_REPLACEMENT_NEVER


/* Versioning.
 * ************************************************************************** */

/* Information about Jitter, to be printed out to the user. */
#undef JITTER_PACKAGE_NAME
#undef JITTER_PACKAGE_VERSION
#undef JITTER_PACKAGE_BUGREPORT
#undef JITTER_PACKAGE_URL

/* Notice that JITTER_DISPATCH_NAME_STRING , not defined here but available from
   jitter/jitter.h , will also be appropriate to print, particularly for user
   bug reports. */


/* Availability of GNU C features.
 * ************************************************************************** */

/* Define if the compiler is actually GCC, rather then some other compiler
   falsely claiming compatibility. */
#undef JITTER_HAVE_ACTUAL_GCC

/* Define to the GCC version, when GCC is being used. */
#undef JITTER_GCC_MAJOR_VERSION
#undef JITTER_GCC_MINOR_VERSION
#undef JITTER_GCC_PATCHLEVEL_VERSION
#undef JITTER_GCC_COMBINED_VERSION

/* Define if the compiler is clang.  Notice that we discourage the use of clang
   as a non-copylefted project with a copyleft alternative.  Jitter recommends
   GCC, and only supports high-performance advanced dispatches with GCC. */
#undef JITTER_HAVE_CLANG

/* Define to the clang version, when clang is being used. */
#undef JITTER_CLANG_MAJOR_VERSION
#undef JITTER_CLANG_MINOR_VERSION
#undef JITTER_CLANG_PATCHLEVEL_VERSION
#undef JITTER_CLANG_COMBINED_VERSION

/* Define iff GNU C's typeof works. */
#undef JITTER_HAVE_TYPEOF

/* Define if the language supports mixing declarations and statements, as
   standard in C since 1999 and widely supported even earlier.  If this is not
   defined I expect major problems, and the compiler will not be supported.
   This is mostly intended to be checked in bug reports. */
#undef JITTER_HAVE_MIXED_DECLARATIONS_AND_STATEMENTS

/* Define if the C compiler supports non-constant aggregate initialisers. */
#undef JITTER_HAVE_NON_CONSTANT_AGGREGATE_INITIALIZERS

/* Define if the C compiler supports designed initialisers. */
#undef JITTER_HAVE_DESIGNATED_INITIALIZERS

/* Define if the C compiler supports compound literals. */
#undef JITTER_HAVE_COMPOUND_LITERALS

/* Define if the C compiler supports compound literals as l-values. */
#undef JITTER_HAVE_COMPOUND_LITERALS_AS_LVALUES

/* Define if the language supports statement expressions in the style of GNU C. */
#undef JITTER_HAVE_GNU_C_STATEMENT_EXPRESSIONS

/* Define if the language supports computed goto in the style of GNU C. */
#undef JITTER_HAVE_GNU_C_COMPUTED_GOTO

/* Define if the language supports computed goto in the style of GNU C and the
   difference between the addresses of two labels (in the same function) is a
   constant expression. */
#undef JITTER_HAVE_GNU_C_CONSTANT_LABEL_DIFFERENCE

/* Define if the language supports GNU C's inline asm, including the modern
   syntax for named operands. */
#undef JITTER_HAVE_GNU_C_INLINE_ASM

/* Define if the language supports asm goto in the style of GNU C. */
#undef JITTER_HAVE_GNU_C_ASM_GOTO

/* Define if the language supports asm inline in the style of modern GNU C.
   This is still a recent feature, introduced around the time of GCC 9. */
#undef JITTER_HAVE_GNU_C_ASM_INLINE

/* Define if the compiler supports alignas. */
#undef JITTER_HAVE_ALIGNAS

/* Define if the library/compiler supports offsetof. */
#undef JITTER_HAVE_OFFSETOF

/* Define if the builtins for handling overflow are available. */
#undef JITTER_HAVE_GCC_OVERFLOW_CHECKING

/* Define if __builtin_constant_p is available. */
#undef JITTER_HAVE_GCC_BUILTIN_CONSTANT_P

/* Define if __builtin_expect is available. */
#undef JITTER_HAVE_GCC_BUILTIN_EXPECT

/* Define if __builtin_unreachable is available. */
#undef JITTER_HAVE_GCC_BUILTIN_UNREACHABLE

/* Define if __builtin_types_compatible_p is available. */
#undef JITTER_HAVE_GCC_BUILTIN_TYPES_COMPATIBLE_P

/* Define if __builtin_choose_expr is available. */
#undef JITTER_HAVE_GCC_BUILTIN_CHOOSE_EXPR

/* Define if the C compilers supports GNU C attributes. */
#undef JITTER_HAVE_GNU_C_ATTRIBUTE

/* Define for specific GNU C attributes. */
#undef JITTER_HAVE_ATTRIBUTE_NO_REORDER
#undef JITTER_HAVE_ATTRIBUTE_RETURNS_NONNULL

/* Define if the compiler supports #pragma GCC diagnostic inside functions.
   Some old versions of GCC 4 do not but, annoyingly, others versions do which
   are less recent than others which do not. */
#undef JITTER_HAVE_PRAGMA_GCC_DIAGNOSTIC_IN_FUNCTIONS

/* Define if the compiler supports assembly names for functions in the style of
   GNU C. */
#undef JITTER_HAVE_ASSEMBLY_NAMES_FOR_FUNCTIONS

/* Define if the compiler supports assembly names for nonfunctions in the style
   of GNU C. */
#undef JITTER_HAVE_ASSEMBLY_NAMES_FOR_NON_FUNCTIONS


/* Features depending on previous checks.
 * ************************************************************************** */

/* Define if the platform supports the GNU C extensions necessray for function
   wrappers. */
#undef JITTER_HAVE_FUNCTION_WRAPPERS_REQUIREMENTS

/* Define if the platform supports the GNU C extensions necessray for local
   poisoning. */
#undef JITTER_HAVE_LOCAL_POISONING_REQUIREMENTS


/* Optimization: machine-specific alternatives.
 * ************************************************************************** */

/* Define if a conditional expression based on the negative sign can be compiled
   more efficiently without branches. */
#undef JITTER_HAVE_FAST_STRAIGHT_LINE_NEGATIVITY

/* Define if there is an efficient way of masking off low-order bits by and-ing
   with a sign-extended immediate, or another one-instruction equivalent
   operation. */
#undef JITTER_HAVE_FAST_MASK_OFF

#endif // #ifndef JITTER_CONFIG_H_
