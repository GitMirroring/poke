/* mbr-test.pk - Tests for the mbr pickle.  */

/* Copyright (C) 2021, 2022, 2023, 2024 The poke authors */

/* This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

load pktest;
load mbr;

set_endian(ENDIAN_LITTLE);

var data = open ("*data*");

/* 4 primary partition.
   mbr_fdisk
     :disk_identifier 0x23bdaa60
     :partitions [
       part :start 2048#4096 :end 22527#4096 :sectors 20480
            :size 10#MiB :id 83 :typ "Linux";
       // 1#MiB gap.
       part :start 24576#4096 :end 40959#4096 :sectors 16384
            :size 8#MiB :id 83 :typ "Linux";
       part :start 40960#4096 :end 81919#4096 :sectors 40960
            :size 20#MiB :id 83 :typ "Linux";
       part :start 81920#4096 :end 198655#4096 :sectors 116736
            :size 57#MiB :id 83 :typ "Linux";
     ];
*/
var SAMPLE_MBR = [
  0xfaUB, 0xb8UB, 0x00UB, 0x10UB, 0x8eUB, 0xd0UB, 0xbcUB, 0x00UB,
  0xb0UB, 0xb8UB, 0x00UB, 0x00UB, 0x8eUB, 0xd8UB, 0x8eUB, 0xc0UB,
  0xfbUB, 0xbeUB, 0x00UB, 0x7cUB, 0xbfUB, 0x00UB, 0x06UB, 0xb9UB,
  0x00UB, 0x02UB, 0xf3UB, 0xa4UB, 0xeaUB, 0x21UB, 0x06UB, 0x00UB,
  0x00UB, 0xbeUB, 0xbeUB, 0x07UB, 0x38UB, 0x04UB, 0x75UB, 0x0bUB,
  0x83UB, 0xc6UB, 0x10UB, 0x81UB, 0xfeUB, 0xfeUB, 0x07UB, 0x75UB,
  0xf3UB, 0xebUB, 0x16UB, 0xb4UB, 0x02UB, 0xb0UB, 0x01UB, 0xbbUB,
  0x00UB, 0x7cUB, 0xb2UB, 0x80UB, 0x8aUB, 0x74UB, 0x01UB, 0x8bUB,
  0x4cUB, 0x02UB, 0xcdUB, 0x13UB, 0xeaUB, 0x00UB, 0x7cUB, 0x00UB,
  0x00UB, 0xebUB, 0xfeUB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x60UB, 0xaaUB, 0xbdUB, 0x23UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x01UB, 0x10UB, 0x83UB, 0x03UB, 0x20UB, 0xafUB, 0x00UB, 0x08UB,
  0x00UB, 0x00UB, 0x00UB, 0x50UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x01UB, 0xc0UB, 0x83UB, 0x03UB, 0x60UB, 0x3fUB, 0x00UB, 0x60UB,
  0x00UB, 0x00UB, 0x00UB, 0x40UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x41UB, 0x40UB, 0x83UB, 0x03UB, 0xa0UB, 0x7fUB, 0x00UB, 0xa0UB,
  0x00UB, 0x00UB, 0x00UB, 0xa0UB, 0x00UB, 0x00UB, 0x00UB, 0x00UB,
  0x81UB, 0x80UB, 0x83UB, 0x03UB, 0xe0UB, 0xffUB, 0x00UB, 0x40UB,
  0x01UB, 0x00UB, 0x00UB, 0xc8UB, 0x01UB, 0x00UB, 0x55UB, 0xaaUB,
];

var tests = [
  PkTest {
    name = "magic number",
    func = lambda (string name) void:
      {
        uint<8>[512] @ data : 0#B = uint<8>[512] ();

        try
          {
            var m = MBR @ data : 0#B;

            assert(0, "unreachable reached!");
          }
        catch if E_constraint
          {
            assert (1, "the magic number cannot be zero!");
          }

        /* Fix the magic number */
        uint<8>[2] @ data : 510#B = [0x55UB, 0xaaUB];

        var m = MBR @ data : 0#B;
      },
  },
  PkTest {
    name = "CHS",
    func = lambda (string name) void:
      {
        uint<8>[510] @ data : 0#B = uint<8>[510] ();
        uint<8>[2] @ data : 510#B = [0x55UB, 0xaaUB];

        var m = MBR @ data : 0#B;
        var chs = m.pte[0].start_chs;

        assert(chs.head == 0);
        assert(chs.cs.cylinder_hi == 0);
        assert(chs.cs.sector == 0);
        assert(chs.cylinder_lo == 0);
        assert(chs.cylinder == 0);
        assert((uint<8>[chs'size] @ data : chs'offset) == [0UB, 0UB, 0UB]);

        chs.cylinder = 0x3ff;
        assert(chs.head == 0);
        assert(chs.cs.cylinder_hi == 3);
        assert(chs.cs.sector == 0);
        assert(chs.cylinder_lo == 0xff);
        assert(chs.cylinder == 0x3ff);
        assert((uint<8>[chs'size] @ data : chs'offset) == [0UB, 0xc0UB, 0xffUB]);

        chs.cs.cylinder_hi = 1;
        assert(chs.head == 0);
        assert(chs.cs.cylinder_hi == 1);
        assert(chs.cs.sector == 0);
        assert(chs.cylinder_lo == 0xff);
        assert(chs.cylinder == 0x1ff);
        assert((uint<8>[chs'size] @ data : chs'offset) == [0UB, 0x40UB, 0xffUB]);

        chs.head = 0xa5;
        assert(chs.head == 0xa5);
        assert(chs.cs.cylinder_hi == 1);
        assert(chs.cs.sector == 0);
        assert(chs.cylinder_lo == 0xff);
        assert(chs.cylinder == 0x1ff);
        assert((uint<8>[chs'size] @ data : chs'offset) ==
               [0xa5UB, 0x40UB, 0xffUB]);

        chs.cs.sector = 0xff;  /* Only the 6 LSBs are relevant */
        assert(chs.head == 0xa5);
        assert(chs.cs.cylinder_hi == 1);
        assert(chs.cs.sector == 0x3f);
        assert(chs.cylinder_lo == 0xff);
        assert(chs.cylinder == 0x1ff);
        assert((uint<8>[chs'size] @ data : chs'offset) ==
               [0xa5UB, 0x7fUB, 0xffUB]);

        chs.cylinder_lo = 0x81;
        assert(chs.head == 0xa5);
        assert(chs.cs.cylinder_hi == 1);
        assert(chs.cs.sector == 0x3f);
        assert(chs.cylinder_lo == 0x81);
        assert(chs.cylinder == 0x181);
        assert((uint<8>[chs'size] @ data : chs'offset) ==
               [0xa5UB, 0x7fUB, 0x81UB]);
      },
  },
  PkTest {
    name = "Sample MBR verification",
    func = lambda (string name) void:
      {
        for (end in [ENDIAN_BIG, ENDIAN_LITTLE])
          with_temp_ios
            :endian end
            :do lambda void:
              {
                uint<8>[512#B] @ 0#B = SAMPLE_MBR;

                var mbr = MBR @ 0#B;

                assert (mbr.signature == 0x23bdaa60);
                assert (mbr.reserved == [0UB, 0UB]);

                /* TODO mbr.pte[0].start_chs  */
                /* TODO mbr.pte[0].end_chs  */
                assert (mbr.pte[0].part_type == 0x83 as MBR_PartitionType);
                assert (mbr.pte[0].part_type
                        == MBR_PT_LinuxNative as MBR_PartitionType);
                assert (mbr.pte[0].lba == 2048#MBR_SectorSize);
                assert (mbr.pte[0].sector_count == 20480#MBR_SectorSize);
                assert (mbr.pte[0].sector_count == 10#MiB);
                assert (mbr.pte[0].lba == 1#MiB);
                assert (mbr.pte[0].lba_end == 11#MiB);

                /* TODO mbr.pte[1].start_chs  */
                /* TODO mbr.pte[1].end_chs  */
                assert (mbr.pte[1].part_type == 0x83 as MBR_PartitionType);
                assert (mbr.pte[1].part_type
                        == MBR_PT_LinuxNative as MBR_PartitionType);
                assert (mbr.pte[1].lba == 24576#MBR_SectorSize);
                assert (mbr.pte[1].sector_count == 16384#MBR_SectorSize);
                assert (mbr.pte[1].sector_count == 8#MiB);
                assert (mbr.pte[1].lba == 11#MiB + /*gap*/ 1#MiB);
                assert (mbr.pte[1].lba_end == 20#MiB);

                /* TODO mbr.pte[2].start_chs  */
                /* TODO mbr.pte[2].end_chs  */
                assert (mbr.pte[2].part_type == 0x83 as MBR_PartitionType);
                assert (mbr.pte[2].part_type
                        == MBR_PT_LinuxNative as MBR_PartitionType);
                assert (mbr.pte[2].lba == 40960#MBR_SectorSize);
                assert (mbr.pte[2].sector_count == 40960#MBR_SectorSize);
                assert (mbr.pte[2].sector_count == 20#MiB);
                assert (mbr.pte[2].lba == 20#MiB);
                assert (mbr.pte[2].lba_end == 40#MiB);

                /* TODO mbr.pte[3].start_chs  */
                /* TODO mbr.pte[3].end_chs  */
                assert (mbr.pte[3].part_type == 0x83 as MBR_PartitionType);
                assert (mbr.pte[3].part_type
                        == MBR_PT_LinuxNative as MBR_PartitionType);
                assert (mbr.pte[3].lba == 81920#MBR_SectorSize);
                assert (mbr.pte[3].sector_count == 116736#MBR_SectorSize);
                assert (mbr.pte[3].sector_count == 57#MiB);
                assert (mbr.pte[3].lba == 40#MiB);
                assert (mbr.pte[3].lba_end == 97#MiB); // 97.66 MiB
              };
      },
  },
];

var ec = pktest_run (tests) ? 0 : 1;

close(data);
exit (ec);
