/* pe.pk -- PE COFF implementation for GNU poke.  */

/* Copyright (C) 2022 Jose E. Marchesi.  */

/* This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

load time; /* For POSIX_Time32 */
load coff;

/* Load architecture-specific stuff.  */

load "pe-amd64.pk";
load "pe-arm.pk";
load "pe-arm64.pk";
load "pe-i386.pk";
load "pe-ia64.pk";
load "pe-m32r.pk";
load "pe-mips.pk";
load "pe-ppc.pk";
load "pe-sh3.pk";

/* PE magic numbers used in the optional COFF header.  */

var PE_MAGIC_PE32 = 0x10bUH,
    PE_MAGIC_PE32P = 0x20bUH; /* PE32+ */

/* DLL characteristics flag bits.  */

var PE_DLL_F_HIGH_ENTROPY_VA = 0x0020UH,
    PE_DLL_F_DYNAMIC_BASE = 0x0040UH,
    PE_DLL_F_FORCE_INTEGRITY = 0x0080UH,
    PE_DLL_F_NX_COMPAT = 0x0100UH,
    PE_DLL_F_NO_ISOLATION = 0x0200UH,
    PE_DLL_F_NO_SEH = 0x0400UH,
    PE_DLL_F_NO_BIND = 0x0800UH,
    PE_DLL_F_APPCONTAINER = 0x1000UH,
    PE_DLL_F_WDM_DRIVER = 0x2000UH,
    PE_DLL_F_GUARD_CF = 0x4000UH,
    PE_DLL_F_TERMINAL_SERVER_AWARE = 0x8000UH;

var pe_dll_characteristics =
  [ PE_DLL_F_HIGH_ENTROPY_VA, PE_DLL_F_DYNAMIC_BASE,
    PE_DLL_F_FORCE_INTEGRITY, PE_DLL_F_NX_COMPAT,
    PE_DLL_F_NO_ISOLATION, PE_DLL_F_NO_SEH,
    PE_DLL_F_NO_BIND, PE_DLL_F_APPCONTAINER,
    PE_DLL_F_WDM_DRIVER, PE_DLL_F_GUARD_CF,
    PE_DLL_F_TERMINAL_SERVER_AWARE ];

/* Section header flags.  */

var PE_IMAGE_SCN_MEM_DISCARDABLE = 0x02000000U,
    PE_IMAGE_SCN_MEM_EXECUTE     = 0x20000000U,
    PE_IMAGE_SCN_MEM_READ        = 0x40000000U,
    PE_IMAGE_SCN_MEM_WRITE       = 0x80000000;

/* Section characteristics.  */

var PE_IMAGE_SCN_TYPE_NO_PAD = 0x00000008U, /* Reserved.  */
    PE_IMAGE_SCN_CNT_CODE    = 0x00000020U, /* Section contains code.  */
    PE_IMAGE_SCN_CNT_INITIALIZED_DATA = 0x00000040U, /* Section contains initialized data.  */
    PE_IMAGE_SCN_CNT_UNINITIALIZED_DATA = 0x00000080U, /* Section contains uninitialized data.  */
    PE_IMAGE_SCN_LNK_OTHER   = 0x00000100U, /* Reserved.  */
    PE_IMAGE_SCN_LNK_INFO    = 0x00000200U, /* Section contains comments or some other type of information.  */
    PE_IMAGE_SCN_LNK_REMOVE  = 0x00000800U, /* Section contents will not become part of image.  */
    PE_IMAGE_SCN_LNK_COMDAT  = 0x00001000U, /* Section contents comdat.  */
    PE_IMAGE_SCN_MEM_FARDATA = 0x00008000U,
    PE_IMAGE_SCN_MEM_PURGEABLE = 0x00020000U,
    PE_IMAGE_SCN_MEM_16BIT   = 0x00020000U,
    PE_IMAGE_SCN_MEM_LOCKED  = 0x00040000U,
    PE_IMAGE_SCN_MEM_PRELOAD = 0x00080000U;

/* COMDAT selection codes.  */

var PE_IMAGE_COMDAT_SELECT_NODUPLICATES = 1, /* Warn if duplicates.  */
    PE_IMAGE_COMDAT_SELECT_ANY = 2,          /* No warning.  */
    PE_IMAGE_COMDAT_SELECT_SAME_SIZE = 3,    /* Warn if different size.  */
    PE_IMAGE_COMDAT_SELECT_EXACT_MATCH = 4,  /* Warn if different.  */
    PE_IMAGE_COMDAT_SELECT_ASSOCIATIVE = 5;  /* Base on other section.  */

/* Machine numbers.  */

var PE_IMAGE_FILE_MACHINE_UNKNOWN    = 0x0000UH,
    PE_IMAGE_FILE_MACHINE_ALPHA      = 0x0184UH,
    PE_IMAGE_FILE_MACHINE_ALPHA64    = 0x0284UH,
    PE_IMAGE_FILE_MACHINE_AM33       = 0x01d3UH,
    PE_IMAGE_FILE_MACHINE_AMD64      = 0x8664UH,
    PE_IMAGE_FILE_MACHINE_ARM        = 0x01c0UH,
    PE_IMAGE_FILE_MACHINE_ARM64      = 0xaa64UH,
    PE_IMAGE_FILE_MACHINE_AXP64      = PE_IMAGE_FILE_MACHINE_ALPHA64,
    PE_IMAGE_FILE_MACHINE_CEE        = 0xc0eeUH,
    PE_IMAGE_FILE_MACHINE_CEF        = 0x0cefUH,
    PE_IMAGE_FILE_MACHINE_EBC        = 0x0ebcUH,
    PE_IMAGE_FILE_MACHINE_I386       = 0x014cUH,
    PE_IMAGE_FILE_MACHINE_IA64       = 0x0200UH,
    PE_IMAGE_FILE_MACHINE_M32R       = 0x9041UH,
    PE_IMAGE_FILE_MACHINE_M68K       = 0x0268UH,
    PE_IMAGE_FILE_MACHINE_MIPS16     = 0x0266UH,
    PE_IMAGE_FILE_MACHINE_MIPSFPU    = 0x0366UH,
    PE_IMAGE_FILE_MACHINE_MIPSFPU16  = 0x0466UH,
    PE_IMAGE_FILE_MACHINE_POWERPC    = 0x01f0UH,
    PE_IMAGE_FILE_MACHINE_POWERPCFP  = 0x01f1UH,
    PE_IMAGE_FILE_MACHINE_R10000     = 0x0168UH,
    PE_IMAGE_FILE_MACHINE_R3000      = 0x0162UH,
    PE_IMAGE_FILE_MACHINE_R4000      = 0x0166UH,
    PE_IMAGE_FILE_MACHINE_SH3        = 0x01a2UH,
    PE_IMAGE_FILE_MACHINE_SH3DSP     = 0x01a3UH,
    PE_IMAGE_FILE_MACHINE_SH3E       = 0x01a4UH,
    PE_IMAGE_FILE_MACHINE_SH4        = 0x01a6UH,
    PE_IMAGE_FILE_MACHINE_SH5        = 0x01a8UH,
    PE_IMAGE_FILE_MACHINE_THUMB      = 0x01c2UH,
    PE_IMAGE_FILE_MACHINE_TRICORE    = 0x0520UH,
    PE_IMAGE_FILE_MACHINE_WCEMIPSV2  = 0x0169UH,
    PE_IMAGE_FILE_MACHINE_AMD64      = 0x8664UH;

/* Subsystem types.  */

var PE_SUBSYS_UNKNOWN = 0,
    PE_SUBSYS_NATIVE = 1,
    PE_SUBSYS_WINDOWS_GUI = 2,
    PE_SUBSYS_WINDOWS_CUI = 3,
    PE_SUBSYS_POSIX_CUI = 7,
    PE_SUBSYS_WINDOWS_CE_GUI = 9,
    PE_SUBSYS_EFI_APPLICATION = 10,
    PE_SUBSYS_EFI_BOOT_SERVICE_DRIVER = 11,
    PE_SUBSYS_EFI_RUNTIME_DRIVER = 12,
    PE_SUBSYS_SAL_RUNTIME_DRIVER = 13,
    PE_SUBSYS_XBOX = 14;

var pe_subsystems =
  [ PE_SUBSYS_UNKNOWN, PE_SUBSYS_NATIVE, PE_SUBSYS_WINDOWS_GUI,
    PE_SUBSYS_WINDOWS_CUI, PE_SUBSYS_POSIX_CUI,
    PE_SUBSYS_WINDOWS_CE_GUI, PE_SUBSYS_EFI_APPLICATION,
    PE_SUBSYS_EFI_BOOT_SERVICE_DRIVER, PE_SUBSYS_EFI_RUNTIME_DRIVER,
    PE_SUBSYS_SAL_RUNTIME_DRIVER, PE_SUBSYS_XBOX ];

/* Characteristics of the PE/COFF image, encoded in the `flags' field
   of the COFF header.  */

var PE_F_RELOCS_STRIPPED = 0x0001UH,
    PE_F_EXECUTABLE_IMAGE = 0x0002UH,
    PE_F_LINE_NUMS_STRIPPED = 0x0004UH,
    PE_F_LOCL_SYMS_STRIPPED = 0x0008UH,
    PE_F_AGGRESSIVE_WS_TRIM = 0x0010UH,
    PE_F_LARGE_ADDRESS_AWARE = 0x0020UH,
    PE_F_BYTES_REVERSED_LO = 0x0080UH;

var pe_characteristics =
  [PE_F_RELOCS_STRIPPED, PE_F_EXECUTABLE_IMAGE,
   PE_F_LINE_NUMS_STRIPPED, PE_F_LOCL_SYMS_STRIPPED,
   PE_F_AGGRESSIVE_WS_TRIM, PE_F_LARGE_ADDRESS_AWARE,
   PE_F_BYTES_REVERSED_LO];

/* PE section flags.  */

var PE_SEC_F_TYPE_NO_PAD = 0x0008,
    PE_SEC_F_CNT_CODE = 0x0020,
    PE_SEC_F_CNT_INITIALIZED_DATA = 0x0040,
    PE_SEC_F_CNT_UNINITIALIZED_DATA = 0x0080,
    PE_SEC_F_LNK_OTHER = 0x0100,
    PE_SEC_F_LNK_INFO = 0x0200,
    PE_SEC_F_LNK_REMOVE = 0x0800,
    PE_SEC_F_LNK_COMDAT = 0x1000,
    PE_SEC_F_GPREL = 0x8000,
    PE_SEC_F_MEM_PURGEABLE = 0x20000,
    PE_SEC_F_MEM_16BIT = 0x20000,
    PE_SEC_F_MEM_LOCKED = 0x40000,
    PE_SEC_F_MEM_PRELOAD = 0x80000,
    PE_SEC_F_ALIGN_1BYTES = 0x100000,
    PE_SEC_F_ALIGN_2BYTES = 0x200000,
    PE_SEC_F_ALIGN_4BYTES = 0x300000,
    PE_SEC_F_ALIGN_8BYTES = 0x400000,
    PE_SEC_F_ALIGN_16BYTES = 0x500000,
    PE_SEC_F_ALIGN_32BYTES = 0x600000,
    PE_SEC_F_ALIGN_64BYTES = 0x700000,
    PE_SEC_F_ALIGN_128BYTES = 0x800000,
    PE_SEC_F_ALIGN_512BYTES = 0xa00000,
    PE_SEC_F_ALIGN_1024BYTES = 0xb00000,
    PE_SEC_F_ALIGN_2048BYTES = 0xc00000,
    PE_SEC_F_ALIGN_4096BYTES = 0xd00000,
    PE_SEC_F_ALIGN_8192BYTES = 0xe00000,
    PE_SEC_F_LNK_NRELOC_OVFL = 0x01000000,
    PE_SEC_F_MEM_DISCARDABLE = 0x02000000,
    PE_SEC_F_MEM_NOT_CACHED = 0x04000000,
    PE_SEC_F_MEM_NOT_PAGED = 0x08000000,
    PE_SEC_F_MEM_SHARED = 0x10000000,
    PE_SEC_F_MEM_EXECUTE = 0x20000000,
    PE_SEC_F_MEM_READ = 0x40000000,
    PE_SEC_F_MEM_WRITE = 0x80000000;

/* PE names.

   COFF names are sort of ugly (see COFF_Name in coff.pk) but the
   PE/COFF variant is an atrocity.  */

type PE_Name =
  struct
  {
    /* Array containing a null-padded UTF-8 encoded string. If the
       string is exactly 8 characters long, there is no terminating
       null. For longer names, this field contains a slash (/) that is
       followed by an ASCII representation of a decimal number that is
       an offset into the string table.  */
    char[8] chars;

    /* Offset in the COFF string table for this name.  If the length
       of the name is 8 bytes or shorter, then return 0#B (which is
       not a valid offset in COFF string tables.)  */
    computed offset<uint<32>,B> offset;

    method get_offset = offset<uint<32>,B>:
    {
      if (chars[0] != '/')
        return 0#B;
      return atoi (catos (chars[1:]))#B;
    }

    method set_offset = (offset<uint<32>,B> offset) void:
    {
      stoca ("/" + format ("%i32d", offset'magnitude), chars);
    }

    method _print = void:
    {
      print "#<" + catos (chars) + ">";
    }
  };

/* PE section header.  */

type PE_Shdr =
  struct
  {
    PE_Name name;

    offset<uint<32>,B> virtual_size; /* XXX should be zero for objects.  */
    offset<uint<32>,B> virtual_address;
    offset<uint<32>,B> size_of_raw_data;
    offset<uint<32>,B> ptr_to_raw_data;
    offset<uint<32>,B> ptr_to_relocs;
    offset<uint<32>,B> ptr_to_linenos;

    uint<16> num_relocs;
    uint<16> num_linenos; /* XXX should be zero for images.  */


    /* PE_SEC_F_LNK_NRELOC_OVFL indicates that the count of
       relocations for the section exceeds the 16 bits that are
       reserved for it in the section header. If the bit is set and
       the NumberOfRelocations field in the section header is 0xffff,
       the actual relocation count is stored in the 32-bit
       VirtualAddress field of the first relocation. It is an error if
       IMAGE_SCN_LNK_NRELOC_OVFL is set and there are fewer than
       0xffff relocations in the section.  */
    uint<32> flags;
  };


/* Supported symbol base types, encoded in the least-significative
   byte of COFF_Sym.e_type.  */

var PE_SYM_TYPE_NULL = 0UB,
    PE_SYM_TYPE_VOID = 1UB,
    PE_SYM_TYPE_CHAR = 2UB,
    PE_SYM_TYPE_SHORT = 3UB,
    PE_SYM_TYPE_INT = 4UB,
    PE_SYM_TYPE_LONG = 5UB,
    PE_SYM_TYPE_FLOAT = 6UB,
    PE_SYM_TYPE_DOUBLE = 7UB,
    PE_SYM_TYPE_STRUCT = 8UB,
    PE_SYM_TYPE_UNION = 9UB,
    PE_SYM_TYPE_ENUM = 10UB,
    PE_SYM_TYPE_MOE = 11UB,
    PE_SYM_TYPE_BYTE = 12UB,
    PE_SYM_TYPE_WORD = 13UB,
    PE_SYM_TYPE_UINT = 14UB,
    PE_SYM_TYPE_DWORD = 15UB;

/* Supported complex sym types, encoded in the most-significative byte
   of COFF_Sym.e_type.  */

var PE_SYM_DTYPE_NULL = 0UB,
    PE_SYM_DTYPE_POINTER = 1UB,
    PE_SYM_DTYPE_FUNCTION = 2UB,
    PE_SYM_DTYPE_ARRAY = 3UB;

/* Symbol storage classes, to be used in COFF_Sym.e_sclass.  */

var PE_SYM_CLASS_END_OF_FUNCTION = 0xFFUB,
    PE_SYM_CLASS_NULL = 0UB,
    PE_SYM_CLASS_AUTOMATIC = 1UB,
    PE_SYM_CLASS_EXTERNAL = 2UB,
    PE_SYM_CLASS_STATIC = 3UB,
    PE_SYM_CLASS_REGISTER = 4UB,
    PE_SYM_CLASS_EXTERNAL_DEF = 5UB,
    PE_SYM_CLASS_LABEL = 6UB,
    PE_SYM_CLASS_UNDEFINED_LABEL = 7UB,
    PE_SYM_CLASS_MEMBER_OF_STRUCT = 8UB,
    PE_SYM_CLASS_ARGUMENT = 9UB,
    PE_SYM_CLASS_STRUCT_TAG = 10UB,
    PE_SYM_CLASS_MEMBER_OF_UNION = 11UB,
    PE_SYM_CLASS_UNION_TAG = 12UB,
    PE_SYM_CLASS_TYPE_DEFINITION = 13UB,
    PE_SYM_CLASS_UNDEFINED_STATIC = 14UB,
    PE_SYM_CLASS_ENUM_TAG = 15UB,
    PE_SYM_CLASS_MEMBER_OF_ENUM = 16UB,
    PE_SYM_CLASS_REGISTER_PARAM = 17UB,
    PE_SYM_CLASS_BIT_FIELD = 18UB,
    PE_SYM_CLASS_BLOCK = 100UB,
    PE_SYM_CLASS_FUNCTION = 101UB,
    PE_SYM_CLASS_END_OF_STRUCT = 102UB,
    PE_SYM_CLASS_FILE = 103UB,
    PE_SYM_CLASS_SECTION = 104UB,
    PE_SYM_CLASS_WEAK_EXTERNAL = 105UB,
    PE_SYM_CLASS_CLR_TOKEN = 107UB;

/* PE auxiliary symbol records.  These follow certain kind of regular
   symbol records and must be 18 bytes long.  */

type PE_Func_Def =
  struct
  {
    uint<32> tag_index;
    offset<uint<32>,B> total_size;
    offset<uint<32>,B> ptr_to_linenos;
    offset<uint<32>,B> ptr_to_next_func;
    uint<16>;
  };

assert (1#PE_Func_Def == 18#B);

type PE_Begin_Function =
  struct
  {
    uint<32>;
    uint<16> lineno : lineno > 0;
    uint<48>;
    offset<uint<32>,B> ptr_to_next_function;
    uint<16>;
  };

assert (1#PE_Begin_Function == 18#B, "size must be 18#B");

type PE_End_Function =
  struct
  {
    uint<32>;
    uint<16> lineno : lineno > 0;
    uint<48>;
    uint<32>;
    uint<16>;
  };

assert (1#PE_End_Function == 18#B, "size musot be 18#B");

/* XXX I made these values up - jemarch  */
var PE_WEAK_EXTERN_SEARCH_NOLIBRARY = 0x1U,
    PE_WEAK_EXTERN_SEARCH_LIBRARY = 0x2U,
    PE_WEAK_EXTERN_SEARCH_ALIAS = 0x4U;

type PE_Weak_External =
  struct
  {
    uint<32> tag_index;
    uint<32> flags;
    uint<64>;
    uint<16>;
  };

assert (1#PE_Weak_External == 18#B, "size must be 18#B");

var PE_COMDAT_SELECT_NODUPLICATES = 1UB,
    PE_COMDAT_SELECT_ANY = 2UB,
    PE_COMDAT_SELECT_SAME_SIZE = 3UB,
    PE_COMDAT_SELECT_EXACT_MATCH = 4UB,
    PE_COMDAT_SELECT_ASSOCIATIVE = 5UB,
    PE_COMDAT_SELECT_LARGEST = 6UB;

type PE_Section_Definition =
  struct
  {
    offset<uint<32>,B> size; /* Same as PE_Shdr.size_of_raw_data  */
    uint<16> num_of_relocs;
    uint<16> num_of_linenos;
    uint<32> checksum;
    uint<16> number;
    uint<8> selection : selection in [0UB, /* When no COMDAT section.  */
                                      PE_COMDAT_SELECT_NODUPLICATES,
                                      PE_COMDAT_SELECT_ANY,
                                      PE_COMDAT_SELECT_SAME_SIZE,
                                      PE_COMDAT_SELECT_EXACT_MATCH,
                                      PE_COMDAT_SELECT_ASSOCIATIVE,
                                      PE_COMDAT_SELECT_LARGEST];
    uint<24> unused;
  };

assert (1#PE_Section_Definition == 18#B, "size must be 18#B");

var PE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1UB;

type PE_CLR_Token =
  struct
  {
    uint<8> aux_type == PE_AUX_SYMBOL_TYPE_TOKEN_DEF;
    uint<8> rsv1 : rsv1 == 0;
    uint<32> symbol_table_index;
    uint<64> rsv2 : rsv2 == 0;
    uint<32> rsv3 : rsv3 == 0;
  };

assert (1#PE_CLR_Token == 18#B, "size must be 18#B");

/* PE symbol records.  */

type PE_Sym =
  struct
  {
    COFF_Sym sym;
    union
    {
      PE_Func_Def function_definition : sym.e_sclass == PE_SYM_CLASS_EXTERNAL
                                        && sym.e_type.msb == PE_SYM_DTYPE_FUNCTION
                                        && sym.e_scnum > 0;
      PE_Begin_Function bf : sym.e_type.msb == PE_SYM_DTYPE_FUNCTION
                             && catos (sym.e_name.name) == ".bf";
      PE_End_Function ef : sym.e_type.msb == PE_SYM_DTYPE_FUNCTION
                           && catos (sym.e_name.name) == ".ef";
      PE_Weak_External weak_external : sym.e_sclass == PE_SYM_CLASS_EXTERNAL
                                       && sym.e_scnum == COFF_N_UNDEF
                                       && sym.e_value == 0;
      /* We assume here that any symbol with static storage and whose
         name starts with a dot character '.' is a section name.  */
      PE_Section_Definition section_definition : sym.e_sclass == PE_SYM_CLASS_STATIC
                                                 && (sym.e_name.name ?! E_elem
                                                     || sym.e_name.name[0] == '.');
      PE_CLR_Token clr_token : sym.e_sclass == PE_SYM_CLASS_CLR_TOKEN;
      char[18] file_name : sym.e_sclass == PE_SYM_CLASS_FILE;
      byte[18] unused;
    } aux_sym;
  };

/* PE attribute certificates.  */

var PE_WIN_CERT_REVISION_1_0 = 0x0100UH,
    PE_WIN_CERT_REVISION_2_0 = 0x0200UH;

var PE_WIN_CERT_TYPE_X509 = 0x0001UH,
    PE_WIN_CERT_TYPE_PKCS_SIGNED_DATA = 0x0002UH,
    PE_WIN_CERT_TYPE_RESERVED_1 = 0x0003UH,
    PE_WIN_CERT_TYPE_TS_STACK_SIGNED = 0x0004UH;

type PE_Attribute_Certificate =
  struct
  {
    offset<uint<32>,B> length;
    uint<16> revision;
    uint<16> cert_type;

    /* Note: we use internal padding here so we can map arrays of
       attribute certificates by total size.  */
    byte[0] certificate_begin;
    byte[0] certificate_end @ length + alignto (length, 8#B);
  };

/* PE delay import descriptors.  */

type PE_Delay_Import =
  struct
  {
    uint<32> attributes == 0;
    offset<uint<32>,B> name;
    offset<uint<32>,B> module_handle;
    offset<uint<32>,B> delay_import_address_table;
    offset<uint<32>,B> delay_import_name_table;
    offset<uint<32>,B> bound_delay_import_table;
    offset<uint<32>,B> unload_delay_import_table;
    POSIX_Time32 timestamp;
  };

/* PE relocations.  */

type PE_Reloc =
  struct
  {
    offset<uint<32>,B> r_vaddr;
    uint<32> r_symndx;
    uint<16> r_type;
  };

/* PE data directory descriptor.  */

type PE_Data_Directory =
  struct
  {
    offset<uint<32>,B> rva;
    offset<uint<32>,B> size;
  };

/* PE optional header.  */

type PE_Opt_Hdr =
  struct
  {
    COFF_Opt_Hdr coff_opt_hdr = COFF_Opt_Hdr { magic = PE_MAGIC_PE32 }
                              : coff_opt_hdr.magic in [PE_MAGIC_PE32,
                                                       PE_MAGIC_PE32P];

    var pe32p = coff_opt_hdr.magic == PE_MAGIC_PE32P;

    offset<uint<32>,B> data_start if pe32p;

    /* Preferred address of the first byte of image when loaded into
       memory.  */
    union
    {
      offset<uint<64>,B> a64 : pe32p && a64 % 64#B == 0#B;
      offset<uint<32>,B> a32 : (a32 & 0xffff#B) == 0#B;
    } image_base;

    /* Alignment of sections when they are loaded into memory.  */
    offset<uint<32>,B> section_alignment;

    /* Alignment factor that is used to align the raw data of sections
       in the image file.  */
    offset<uint<32>,B> file_alignment : (file_alignment & 0x1#b) == 0#B
                                        && file_alignment <= section_alignment
                                        && file_alignment >= 512#B
                                        && file_alignment <= 64#KB
                                      = 512#B;

    /* Version numbers for operating system, images etc.  */
    uint<16> major_os_version;
    uint<16> minor_os_version;
    uint<16> major_image_version;
    uint<16> minor_image_version;
    uint<16> major_subsystem_version;
    uint<16> minor_subsystem_version;
    uint<32> win32_version_value;

    /* The size of the image, including all headers, as the image is
       loaded in memory.  */
    offset<uint<32>,B> size_of_image
                       : section_alignment % size_of_image == 0#B;

    /* The combined size of an MS-DOS stub, PE header, and section
       headers rounded up to a multiple of FileAlignment.  */
    offset<uint<32>,B> size_of_headers
                       : size_of_headers % file_alignment == 0#B;

    /* The image file checksum.  */
    uint<32> checksum;

    /* The subsystem that is required to run this image.  */
    uint<16> subsystem : subsystem in pe_subsystems;

    /* DLL characteristics.  */
    uint<16> dll_characteristics : dll_characteristics in pe_dll_characteristics;

    /* The size of the stack to reserve.  */
    union
    {
      offset<uint<64>,B> s64 : pe32p;
      offset<uint<32>,B> s32;
    } size_of_stack_commit;

    /* The size of the local heap space to commit.  */
    union
    {
      offset<uint<64>,B> s64 : pe32p;
      offset<uint<32>,B> s32;
    } size_of_heap_commit;

    /* Loader flags.  This is reserved and must be zero.  */
    uint<32> loader_flags == 0;

    /* Number of data-directory entries in the remainder of the
       optional header.  */
    uint<32> num_of_rva_and_sizes;

    /* Data directories.  */
    struct
    {
      PE_Data_Directory export_table;
      PE_Data_Directory import_table;
      PE_Data_Directory resource_table;
      PE_Data_Directory exception_table;
      PE_Data_Directory certificate_table;
      PE_Data_Directory base_relocation_table;
      PE_Data_Directory debug;
      PE_Data_Directory architecture : architecture.rva == 0#B
                                       && architecture.size == 0#B;
      PE_Data_Directory global_ptr : global_ptr.size == 0#B;
      PE_Data_Directory tls_table;
      PE_Data_Directory load_config_table;
      PE_Data_Directory bound_import;
      PE_Data_Directory iat;
      PE_Data_Directory delay_import_descriptor;
      PE_Data_Directory clr_runtime_header;
      PE_Data_Directory reserved : reserved.rva == 0#B
                                   && reserved.size == 0#B;
    } data_directories
        : data_directories'length == num_of_rva_and_sizes;
  };

/* PE file header.  */

type PE_File =
  struct
  {
    COFF_File_Hdr hdr @ 0x3C#B;
    PE_Opt_Hdr opt_hdr : opt_hdr'size == hdr.opthdr
      if hdr.opthdr > 0#B;

    PE_Shdr[hdr.nscns] sections
      if hdr.nscns > 0;
    PE_Sym[hdr.nsyms] symbols @ hdr.symptr
      if hdr.nsyms > 0;
    COFF_Strtab strings;

    var delay_import_datadir = opt_hdr.data_directories.delay_import_descriptor;

    PE_Delay_Import[delay_import_datadir.size] delay_imports
      @ delay_import_datadir.rva
      if delay_import_datadir.size > 0#B;

    var certs_datadir = opt_hdr.data_directories.certificate_table;

    PE_Attribute_Certificate[certs_datadir.size] certificates
      @ certs_datadir.rva
      if certs_datadir.size > 0#B;
  };
