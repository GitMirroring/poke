/* ieee754-test.pk - Tests for the IEEE 754 pickle.  */

/* Copyright (C) 2022, 2023, 2024 The poke authors.  */

/* This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

load pktest;
load ieee754;

var data = open("*data*");

var tests = [
  PkTest {
    name = "binary16",
    func = lambda (string name) void:
      {
        var one = 0x3c00 as Float16;

        assert (one.sign == 0);
        assert (one.exp == 0xf);
        assert (one.frac == 0);
        assert (!one.is_inf_p);
        assert (!one.is_nan_p);

        var minus_two = 0xc000 as Float16;

        assert (minus_two.sign == 1);
        assert (minus_two.exp == 0x10); // 2^(16-15) = 2^1 = 2
        assert (minus_two.frac == 0);
        assert (!minus_two.is_inf_p);
        assert (!minus_two.is_nan_p);

        var random = 0x5144 as Float16;

        assert (random.sign == 0);
        assert (random.exp == 0x14); // 42
        assert (random.frac == 0x144); // .125
        assert (!random.is_inf_p);
        assert (!random.is_nan_p);

        var posinf = 0b0111110000000000 as Float16;

        assert (posinf.is_inf_p);
        assert (!posinf.is_nan_p);

        var qnan1 = IEEE754_binary16{ sign=1, exp=-1, frac=1T:::(1 as uint<9>) },
            qnan2 = IEEE754_binary16{ sign=1, exp=-1, frac=1T:::(-1 as uint<9>) },
            snan1 = IEEE754_binary16{ sign=0, exp=-1, frac=0T:::(1 as uint<9>) },
            snan2 = IEEE754_binary16{ sign=0, exp=-1, frac=0T:::(-1 as uint<9>) };

        assert (qnan1.is_nan_p);
        assert (qnan1.is_qnan_p);
        assert (!qnan1.is_snan_p);

        assert (qnan2.is_nan_p);
        assert (qnan2.is_qnan_p);
        assert (!qnan2.is_snan_p);

        assert (snan1.is_nan_p);
        assert (!snan1.is_qnan_p);
        assert (snan1.is_snan_p);

        assert (snan2.is_nan_p);
        assert (!snan2.is_qnan_p);
        assert (snan2.is_snan_p);

        var subnormal1 = 1 as Float16,
            subnormal2 = Float16 {sign=1, exp=0, frac=1};

        assert (subnormal1.is_subnormal_p);
        assert (subnormal2.is_subnormal_p);
      },
  },
  PkTest {
    name = "binary32",
    func = lambda (string name) void:
      {
        var one = 0x3f800000 as Float32;

        assert (one.sign == 0);
        assert (one.exp == 127); // 2^(127-127) == 2^0 == 1
        assert (one.frac == 0);
        assert (format ("%f32d", +one) == "1.0000000");

        var minus_two = 0xc0000000 as Float32;

        assert (minus_two.sign == 1);
        assert (minus_two.exp == 128); // 2^(128-127) == 2^1 == 1
        assert (minus_two.frac == 0);
        assert (format ("%f32d", +minus_two) == "-2.0000000");

        var random = 0x42288659 as Float32;

        assert (random.sign == 0);
        assert (random.exp == 0x84);
        assert (random.frac == 0x288659);
        assert (format ("%f32d", +random) == "42.1311989");

        uint<8>[4] @ data : 0#B = [ 0xa4UB, 0x70UB, 0x45UB, 0x41UB];

        type little_32 = struct { little uint<32> f; };
        var l32 = (little_32 @ data : 0#B).f as Float32;

        assert (l32.sign == 0);
        assert (l32.exp - 127 == 3);
        assert (l32.frac == 0x4570a4);

        // Reverse the four bytes:
        uint<8>[4] @ data : 0#B = [ 0x41UB, 0x45UB, 0x70UB, 0xa4UB];

        type big_32 = struct { big uint<32> f; };
        var b32 = (big_32 @ data : 0#B).f as Float32;

        assert (b32 == l32);

        assert ((stof ("nan") as IEEE754_binary32).is_qnan_p);
        assert ((stof ("-nan") as IEEE754_binary32).is_qnan_p);
        assert ((stof ("nan") as IEEE754_binary32).sign == 0);
        assert ((stof ("-nan") as IEEE754_binary32).sign == 1);

        var qnan1 = IEEE754_binary32{ sign=1, exp=-1, frac=1T:::(1 as uint<22>) },
            qnan2 = IEEE754_binary32{ sign=1, exp=-1, frac=1T:::(-1 as uint<22>) },
            snan1 = IEEE754_binary32{ sign=0, exp=-1, frac=0T:::(1 as uint<22>) },
            snan2 = IEEE754_binary32{ sign=0, exp=-1, frac=0T:::(-1 as uint<22>) };

        assert (qnan1.is_nan_p);
        assert (qnan1.is_qnan_p);
        assert (!qnan1.is_snan_p);

        assert (qnan2.is_nan_p);
        assert (qnan2.is_qnan_p);
        assert (!qnan2.is_snan_p);

        assert (snan1.is_nan_p);
        assert (!snan1.is_qnan_p);
        assert (snan1.is_snan_p);

        assert (snan2.is_nan_p);
        assert (!snan2.is_qnan_p);
        assert (snan2.is_snan_p);

        var subnormal1 = 1 as Float32,
            subnormal2 = Float32 {sign=1, exp=0, frac=1};

        assert (subnormal1.is_subnormal_p);
        assert (subnormal2.is_subnormal_p);
      },
  },
  PkTest {
    name = "binary64",
    func = lambda (string name) void:
      {
        var pi = 0x400921fb54442eeaUL as Float64;

        assert (pi.sign == 0);
        assert (pi.exp == 0b10000000000);
        assert (pi.frac
                == 0b1001001000011111101101010100010001000010111011101010U);
        assert (format ("%f64d", +pi) == "3.141592653590000");

        assert ((stod ("nan") as IEEE754_binary64).is_qnan_p);
        assert ((stod ("-nan") as IEEE754_binary64).is_qnan_p);
        assert ((stod ("nan") as IEEE754_binary64).sign == 0);
        assert ((stod ("-nan") as IEEE754_binary64).sign == 1);

        var qnan1 = IEEE754_binary64{ sign=1, exp=-1, frac=1T:::(1 as uint<51>) },
            qnan2 = IEEE754_binary64{ sign=1, exp=-1, frac=1T:::(-1 as uint<51>) },
            snan1 = IEEE754_binary64{ sign=0, exp=-1, frac=0T:::(1 as uint<51>) },
            snan2 = IEEE754_binary64{ sign=0, exp=-1, frac=0T:::(-1 as uint<51>) };

        assert (qnan1.is_nan_p);
        assert (qnan1.is_qnan_p);
        assert (!qnan1.is_snan_p);

        assert (qnan2.is_nan_p);
        assert (qnan2.is_qnan_p);
        assert (!qnan2.is_snan_p);

        assert (snan1.is_nan_p);
        assert (!snan1.is_qnan_p);
        assert (snan1.is_snan_p);

        assert (snan2.is_nan_p);
        assert (!snan2.is_qnan_p);
        assert (snan2.is_snan_p);

        var subnormal1 = 1 as Float64,
            subnormal2 = Float64 {sign=1, exp=0, frac=1};

        assert (subnormal1.is_subnormal_p);
        assert (subnormal2.is_subnormal_p);
      },
  },
  PkTest {
    name = "binary16->binary32",
    func = lambda (string name) void:
      {
        assert (ieee754_16to32 (0x0000U as IEEE754_binary16)
                == (0x00000000U as IEEE754_binary32) /*0.000000e+00*/);
        assert (ieee754_16to32 (0x0001U as IEEE754_binary16)
                == (0x33800000U as IEEE754_binary32) /*5.960464e-08*/);
        assert (ieee754_16to32 (0x0003U as IEEE754_binary16)
                == (0x34400000U as IEEE754_binary32) /*1.788139e-07*/);
        assert (ieee754_16to32 (0x0100U as IEEE754_binary16)
                == (0x37800000U as IEEE754_binary32) /*1.525879e-05*/);
        assert (ieee754_16to32 (0x03feU as IEEE754_binary16)
                == (0x387f8000U as IEEE754_binary32) /*6.091595e-05*/);
        assert (ieee754_16to32 (0x03ffU as IEEE754_binary16)
                == (0x387fc000U as IEEE754_binary32) /*6.097555e-05*/);

        assert (ieee754_16to32 (0x3c00U as IEEE754_binary16)
                == (0x3f800000U as IEEE754_binary32) /*1.000000e+00*/);
        assert (ieee754_16to32 (0x4248U as IEEE754_binary16)
                == (0x40490000U as IEEE754_binary32) /*3.140625e+00*/);
        assert (ieee754_16to32 (0x3da8U as IEEE754_binary16)
                == (0x3fb50000U as IEEE754_binary32) /*1.414062e+00*/);
        assert (ieee754_16to32 (0xfe00U as IEEE754_binary16)
                == (0xffc00000U as IEEE754_binary32) /*-nan*/);
        assert (ieee754_16to32 (0x7e00U as IEEE754_binary16)
                == (0x7fc00000U as IEEE754_binary32) /*nan*/);
        assert (ieee754_16to32 (0x7c00U as IEEE754_binary16)
                == (0x7f800000U as IEEE754_binary32) /*inf*/);
        },
  },
  PkTest {
    name = "binary32->binary64",
    func = lambda (string name) void:
      {
        assert (ieee754_32to64 (0x00000000U as IEEE754_binary32) /*0.000000e+00*/
                == (0x0000000000000000U as IEEE754_binary64) /*0.000000e+00*/);
        assert (ieee754_32to64 (0x00000001U as IEEE754_binary32) /*1.401298e-45*/
                == (0x36a0000000000000U as IEEE754_binary64) /*1.401298e-45*/);
        assert (ieee754_32to64 (0x00400000U as IEEE754_binary32) /*5.877472e-39*/
                == (0x3800000000000000U as IEEE754_binary64) /*5.877472e-39*/);
        assert (ieee754_32to64 (0x007fffffU as IEEE754_binary32) /*1.175494e-38*/
                == (0x380fffffc0000000U as IEEE754_binary64) /*1.175494e-38*/);
        assert (ieee754_32to64 (0x00800000U as IEEE754_binary32) /*1.175494e-38*/
                == (0x3810000000000000U as IEEE754_binary64) /*1.175494e-38*/);

        assert (ieee754_32to64 (0x3f800000U as IEEE754_binary32) /*1.000000e+00*/
                == (0x3ff0000000000000U as IEEE754_binary64) /*1.000000e+00*/);
        assert (ieee754_32to64 (0x40490e56U as IEEE754_binary32) /*3.141500e+00*/
                == (0x400921cac0000000U as IEEE754_binary64) /*3.141500e+00*/);
        assert (ieee754_32to64 (0x3fb4fdf4U as IEEE754_binary32) /*1.414000e+00*/
                == (0x3ff69fbe80000000U as IEEE754_binary64) /*1.414000e+00*/);
        assert (ieee754_32to64 (0xffc00000U as IEEE754_binary32) /*-nan*/
                == (0xfff8000000000000U as IEEE754_binary64) /*-nan*/);
        assert (ieee754_32to64 (0x7fc00000U as IEEE754_binary32) /*nan*/
                == (0x7ff8000000000000U as IEEE754_binary64) /*nan*/);
        assert (ieee754_32to64 (0x7f800000U as IEEE754_binary32) /*inf*/
                == (0x7ff0000000000000U as IEEE754_binary64) /*inf*/);
      },
  },
];

var ok = pktest_run (tests);

close (data);
exit(ok ? 0 : 1);
