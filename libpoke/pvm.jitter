## Jitter specification for the GNU Poke Virtual Machine.

## Copyright (C) 2019, 2020, 2021, 2022, 2023, 2024, 2025 Jose E.
## Marchesi
## Written by Jose E. Marchesi

## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

vm
  set prefix "pvm"
end



## Stacks.

stack s
  long-name "stack"
  c-element-type "pvm_val"
  tos-optimized
  element-no 65536
  guard-underflow
  guard-overflow
end

stack t
  long-name "returnstack"
  c-element-type "pvm_val"
  non-tos-optimized
  element-no 65536
  guard-underflow
  guard-overflow
end

stack x
  long-name "exceptionstack"
  c-element-type "struct pvm_exception_handler"
  non-tos-optimized
  element-no 65536
  guard-underflow
  guard-overflow
end



## Register classes.

register-class r
  c-type "pvm_val"
  fast-register-no 0
  slow-registers
end



## Functions and globals to wrap.

wrapped-functions
  pvm_free
  pvm_array_insert
  pvm_array_set
  pvm_assert
  pvm_env_lookup
  pvm_env_register
  pvm_env_pop_frame
  pvm_env_push_frame
  pvm_env_toplevel
  pvm_make_string
  pvm_make_string_nodup
  pvm_make_array
  pvm_make_struct
  pvm_make_offset
  pvm_make_int
  pvm_make_uint
  pvm_make_long
  pvm_make_ulong
  pvm_make_exception
  pvm_make_integral_type
  pvm_make_string_type
  pvm_make_offset_type
  pvm_make_array_type
  pk_upow
  pk_format_binary
  pvm_alloc
  pvm_alloc_gc
  pvm_allocate_struct_attrs
  pvm_make_struct_type
  pvm_typeof
  pvm_type_equal_p
  pvm_ref_struct
  pvm_ref_struct_cstr
  pvm_set_struct
  pvm_val_reloc
  pvm_val_unmap
  pvm_val_ureloc
  pvm_allocate_closure_attrs
  pvm_elemsof
  pvm_array_rem
  pvm_env_set_var
  pvm_get_struct_method
  pvm_make_closure_type
  pvm_make_void_type
  pvm_make_cls
  pvm_val_writer
  pvm_print_string
  pvm_print_val_with_params
  pvm_refo_struct
  pvm_sizeof
  ios_close
  ios_cur
  ios_flags
  ios_flush
  ios_get_id
  ios_map
  ios_handler
  ios_size
  ios_volatile_p
  ios_open
  ios_read_int
  ios_read_uint
  ios_write_int
  ios_write_uint
  ios_search_by_id
  ios_set_bias
  ios_get_bias
  ios_get_dev_if_name
  ios_set_cur
  pvm_random
  pvm_srandom
  pvm_secure_getenv
  pvm_gettime
  pvm_asprintf
  pvm_memcpy
  pvm_strlen
  pvm_strcmp
  pvm_strcpy
  pvm_strncpy
  pvm_strcat
  pvm_nanosleep
  pvm_snprintf
  pvm_stof
  pvm_stod
  pvm_popcount
end

wrapped-globals
  pvm_literal_empty
  pvm_literal_c
  pvm_literal_code
  pvm_literal_enomem
  pvm_literal_no_toplevel_var
  pvm_literal_eindex
  pvm_literal_notmappable
  pvm_literal_newline
  pvm_literal_formatf_fmt
  pvm_literal_formatf_styles
  pvm_literal_dispatch_name
  libpoke_term_if
  pvm_exception_names
end


## Embedded C code.

initial-header-c
  code
#   include <config.h>
  end
end

early-header-c
  code
#   include "pvm.h"
#   include "pvm-val.h"
#   include "ios.h"
#   include "pkt.h"
#   include "pk-utils.h"

    /* Exception handlers, that are installed in the "exceptionstack".

       EXCEPTION is the exception type, either one of the E_* values defined
       above, or any integer >= 256 for user-defined exceptions.

       MAIN_STACK_HEIGHT and RETURN_STACK_HEIGHT are the heights of
       the main and return stacks, to restore before transferring
       control to the exception handler.

       CODE is the program point where the exception handler starts.

       ENV is the run-time environment to restore before transferring
       control to the exception handler.  */

    struct pvm_exception_handler
    {
      int exception;
      jitter_stack_height main_stack_height;
      jitter_stack_height return_stack_height;
      pvm_program_point code;
      pvm_env env;
    };
  end
end

initial-vm1-c
  code
#   include <config.h>
  end
end

initial-vm2-c
  code
#   include <config.h>
  end
end

early-c
  code
#   include <config.h>
#   include <stdlib.h>
#   include <assert.h>
#   include <errno.h>
#   include "intprops.h"

#   include "pvm-alloc.h"
#   include "pvm-wrappers.h"
  end
end

late-header-c
  code
    /* Macros to raise an exception from within an instruction.  This
       is used in the RAISE instruction itself, and also in instructions
       that can fail, such as integer division or IO.

       The code in the macro looks for the first matching exception
       handler in the exception handlers stack.  Then it restores the
       heights of the main stack and the return stack, restores the
       original dynamic environment, and then pushes the exception
       type as an integer in the main stack, before branching to the
       exception handler.  */

#ifdef _WIN32
#undef raise
#endif

#define PVM_RAISE_DIRECT(EXCEPTION)                                   \
  do                                                                  \
  {                                                                   \
   int exception_code                                                 \
     = PVM_VAL_INT (pvm_ref_struct_cstr ((EXCEPTION), pvm_literal_code));\
                                                                      \
   while (1)                                                          \
   {                                                                  \
     struct pvm_exception_handler ehandler                            \
       = JITTER_TOP_EXCEPTIONSTACK ();                                \
     int handler_exception = ehandler.exception;                      \
                                                                      \
     JITTER_DROP_EXCEPTIONSTACK ();                                   \
                                                                      \
     if (handler_exception == 0                                       \
         || handler_exception == exception_code)                      \
     {                                                                \
       JITTER_SET_HEIGHT_STACK (ehandler.main_stack_height);          \
       JITTER_SET_HEIGHT_RETURNSTACK (ehandler.return_stack_height);  \
                                                                      \
       JITTER_PUSH_STACK ((EXCEPTION));                               \
                                                                      \
       PVM_STATE_RUNTIME_FIELD (env) = ehandler.env;                  \
       JITTER_BRANCH (ehandler.code);                                 \
       break;                                                         \
     }                                                                \
   }                                                                  \
 } while (0)


#define PVM_RAISE(CODE,STR,ESTATUS)                                   \
 do                                                                   \
 {                                                                    \
   pvm_val exception = pvm_make_exception ((CODE),(STR),(ESTATUS),    \
                                           NULL, NULL);               \
   PVM_RAISE_DIRECT (exception);                                      \
 } while (0)

#define PVM_MAKE_DFL_EXCEPTION(BASE)                                  \
  pvm_make_exception (BASE,pvm_exception_names[BASE],BASE##_ESTATUS,  \
                      NULL, NULL)

#define PVM_RAISE_DFL(BASE)                                           \
 do                                                                   \
 {                                                                    \
   PVM_RAISE (BASE,pvm_exception_names[BASE],BASE##_ESTATUS);         \
 } while (0)

    /* Macros to implement different kind of instructions.  These are to
       avoid flagrant code replication below.  */

/* Binary numeric operations generating a boolean on the stack.
   ( TYPE TYPE -- TYPE TYPE INT ) */
# define PVM_BOOL_BINOP(TYPE,OP)                                             \
   do                                                                        \
    {                                                                        \
      PVM_ASSERT (PVM_IS_##TYPE (JITTER_UNDER_TOP_STACK ()));                \
      PVM_ASSERT (PVM_IS_##TYPE (JITTER_TOP_STACK ()));                      \
      pvm_val res = PVM_MAKE_INT (PVM_VAL_##TYPE (JITTER_UNDER_TOP_STACK ()) \
                                  OP PVM_VAL_##TYPE (JITTER_TOP_STACK ()), 32); \
      JITTER_PUSH_STACK (res);                                               \
    } while (0)

/* Unary numeric operations.
   ( TYPE -- TYPE TYPE) */
# define PVM_UNOP(TYPE,TYPER,TYPERLC,OP)                                     \
   do                                                                        \
    {                                                                        \
      int size = PVM_VAL_##TYPER##_SIZE (JITTER_TOP_STACK ());               \
      pvm_val res = pvm_make_##TYPERLC (OP PVM_VAL_##TYPE (JITTER_TOP_STACK ()), size); \
      JITTER_PUSH_STACK (res);                                               \
    } while (0)

/* Binary numeric operations.
  ( TYPE TYPE -- TYPE TYPE TYPE ) */
# define PVM_BINOP(TYPEA,TYPEB,TYPER,OP)                                     \
   do                                                                        \
    {                                                                        \
      int size = PVM_VAL_##TYPER##_SIZE (JITTER_UNDER_TOP_STACK ());       \
      pvm_val res = PVM_MAKE_##TYPER (PVM_VAL_##TYPEA (JITTER_UNDER_TOP_STACK ()) \
                                      OP PVM_VAL_##TYPEB (JITTER_TOP_STACK ()), size); \
      JITTER_PUSH_STACK (res);                                               \
    } while (0)

/* Unsigned exponentiation.  */

# define PVM_POWOP(TYPE,TYPEC,TYPELC)                                       \
  do                                                                        \
  {                                                                         \
     uint64_t size = PVM_VAL_##TYPE##_SIZE (JITTER_UNDER_TOP_STACK ());     \
     TYPEC res                                                              \
      = (TYPEC) pk_upow (PVM_VAL_##TYPE (JITTER_UNDER_TOP_STACK ()),        \
                         PVM_VAL_UINT (JITTER_TOP_STACK ()));               \
                                                                            \
     JITTER_PUSH_STACK (pvm_make_##TYPELC (res, size));                     \
  }                                                                         \
  while (0)

/* Conversion instructions.
   ( TYPE -- TYPE RTYPE )  */
#define PVM_CONVOP(TYPE, TYPEC, RTYPELC, RTYPEC)                             \
   do                                                                        \
    {                                                                        \
      jitter_uint tsize = JITTER_ARGN0;                                      \
      TYPEC val = PVM_VAL_##TYPE (JITTER_TOP_STACK ());                      \
      JITTER_PUSH_STACK (pvm_make_##RTYPELC ((RTYPEC) val, tsize));          \
    } while (0)

/* Auxiliary macros used in PVM_PEEK and PVM_POKE below.  */
#define PVM_IOS_ARGS_INT                                                     \
  io, offset, 0, bits, endian, nenc, &value
#define PVM_IOS_ARGS_UINT                                                    \
  io, offset, 0, bits, endian, &value
#define PVM_IOS_ARGS_WRITE_INT                                               \
  io, offset, 0, bits, endian, nenc, value
#define PVM_IOS_ARGS_WRITE_UINT                                              \
  io, offset, 0, bits, endian, value

/* Integral peek instructions.
   ( IOS BOFF -- [VAL] EXCEPTION|null )  */
#define PVM_PEEK(TYPE,IOTYPE,NENC,ENDIAN,BITS,IOARGS)                        \
  do                                                                         \
   {                                                                         \
     int ret;                                                                \
     __attribute__((unused)) enum ios_nenc nenc = (NENC);                    \
     enum ios_endian endian = (ENDIAN);                                      \
     int bits = (BITS);                                                      \
     IOTYPE##64_t value;                                                     \
     ios io;                                                                 \
     ios_off offset;                                                         \
     ios_context ios_ctx = PVM_STATE_BACKING_FIELD (ios_ctx);                \
                                                                             \
     offset = PVM_VAL_ULONG (JITTER_TOP_STACK ());                           \
     if (JITTER_UNDER_TOP_STACK () == PVM_NULL)                              \
       io = ios_cur (ios_ctx);                                               \
     else                                                                    \
       io = ios_search_by_id (ios_ctx, PVM_VAL_INT (JITTER_UNDER_TOP_STACK ()));\
                                                                             \
     if (io == NULL)                                                         \
       JITTER_TOP_STACK () = PVM_MAKE_DFL_EXCEPTION (PVM_E_NO_IOS);          \
     else                                                                    \
       {                                                                     \
         JITTER_DROP_STACK ();                                               \
         if ((ret = ios_read_##IOTYPE (IOARGS)) == IOS_OK)                   \
           {                                                                 \
             JITTER_TOP_STACK () = pvm_make_##TYPE (value, bits);            \
             JITTER_PUSH_STACK (PVM_NULL);                                   \
           }                                                                 \
         else if (ret == IOS_EOF)                                            \
           JITTER_TOP_STACK () = PVM_MAKE_DFL_EXCEPTION (PVM_E_EOF);         \
         else if (ret == IOS_ENOMEM)                                         \
           JITTER_TOP_STACK () = pvm_make_exception (PVM_E_IO,               \
                                                     pvm_literal_enomem,     \
                                                     PVM_E_IO_ESTATUS, NULL, NULL); \
         else if (ret == IOS_EPERM)                                          \
           JITTER_TOP_STACK () = PVM_MAKE_DFL_EXCEPTION (PVM_E_PERM);        \
         else                                                                \
           JITTER_TOP_STACK () = PVM_MAKE_DFL_EXCEPTION (PVM_E_IO);          \
      }                                                                      \
   } while (0)

/* Integral poke instructions.
   ( IOS BOFF VAL -- EXCEPTION|null )  */
#define PVM_POKE(TYPE,IOTYPE,NENC,ENDIAN,BITS,IOARGS)                        \
  do                                                                         \
   {                                                                         \
     int ret;                                                                \
     __attribute__((unused)) enum ios_nenc nenc = (NENC);                    \
     enum ios_endian endian = (ENDIAN);                                      \
     int bits = (BITS);                                                      \
     IOTYPE##64_t value = PVM_VAL_##TYPE (JITTER_TOP_STACK ());              \
     pvm_val offset_val = JITTER_UNDER_TOP_STACK ();                         \
     ios io;                                                                 \
     ios_off offset;                                                         \
     ios_context ios_ctx = PVM_STATE_BACKING_FIELD (ios_ctx);                \
                                                                             \
     JITTER_DROP_STACK ();                                                   \
     JITTER_DROP_STACK ();                                                   \
                                                                             \
     if (JITTER_TOP_STACK () == PVM_NULL)                                    \
       io = ios_cur (ios_ctx);                                               \
     else                                                                    \
       io = ios_search_by_id (ios_ctx, PVM_VAL_INT (JITTER_TOP_STACK ()));   \
                                                                             \
     if (io == NULL)                                                         \
       JITTER_TOP_STACK () = PVM_MAKE_DFL_EXCEPTION (PVM_E_NO_IOS);          \
     else                                                                    \
       {                                                                     \
         JITTER_DROP_STACK ();                                               \
                                                                             \
         offset = PVM_VAL_ULONG (offset_val);                                \
         if ((ret = ios_write_##IOTYPE (IOARGS)) == IOS_OK)                  \
           JITTER_PUSH_STACK (PVM_NULL);                                     \
         else if (ret == IOS_EOF)                                            \
           JITTER_PUSH_STACK (PVM_MAKE_DFL_EXCEPTION (PVM_E_EOF));           \
         else if (ret == IOS_EPERM)                                          \
           JITTER_PUSH_STACK (PVM_MAKE_DFL_EXCEPTION (PVM_E_PERM));          \
         else                                                                \
           JITTER_PUSH_STACK (PVM_MAKE_DFL_EXCEPTION (PVM_E_IO));            \
      }                                                                      \
 } while (0)

/* Macro to call to a closure.  This is used in the instruction CALL,
   and also other instructions required to... call :D The argument
   should be a closure (surprise.)  */

#define PVM_CALL(CLS)                                                        \
   do                                                                        \
    {                                                                        \
       /* Push the name of the caller.  This can be PVM_NULL for */          \
       /* anonymous functions.  */                                           \
       JITTER_PUSH_RETURNSTACK (PVM_VAL_CLS_NAME ((CLS)));                   \
                                                                             \
       /* Make place for the return address in the return stack.  */         \
       /* actual value will be written by the callee. */                     \
       JITTER_PUSH_UNSPECIFIED_RETURNSTACK();                                \
                                                                             \
       /* Save the current environment and use the callee's environment. */  \
       JITTER_PUSH_RETURNSTACK (                                             \
         (jitter_uint) (uintptr_t) PVM_STATE_RUNTIME_FIELD (env));           \
       PVM_STATE_RUNTIME_FIELD (env) = PVM_VAL_CLS_ENV ((CLS));              \
                                                                             \
       /* Branch-and-link to the native code, whose first instruction will */\
       /*  be a prolog. */                                                   \
       JITTER_BRANCH_AND_LINK (PVM_VAL_CLS_ENTRY_POINT ((CLS)));           \
    } while (0)

/* Macros to implement printi* and printl* instructions.  */

#define PVM_PRINTI(TYPE,TYPEC,SIGNED_P,BASE)                                \
  do                                                                        \
  {                                                                         \
    TYPEC val = PVM_VAL_##TYPE (JITTER_UNDER_TOP_STACK ());                 \
    char fmt[16];  /* %0NNd */                                              \
    char *iformat = pvm_literal_empty;                                      \
    uint32_t mask                                                           \
        = JITTER_ARGN0 == 32 ? (uint32_t)-1                                 \
                             : (((uint32_t)1 << JITTER_ARGN0) - 1);         \
                                                                            \
    fmt[0] = '%';                                                           \
    fmt[1] = '0';                                                           \
    fmt[2] = '\0';                                                          \
    if ((BASE) == 10)                                                       \
    {                                                                       \
      iformat = SIGNED_P ? PRIi32 : PRIu32;                                 \
      pvm_strcat (fmt, iformat);                                            \
    }                                                                       \
    else                                                                    \
    {                                                                       \
      char *basefmt = pvm_literal_empty;                                    \
      int prec = 0;                                                         \
                                                                            \
      if ((BASE) == 256)                                                    \
      {                                                                     \
        iformat = pvm_literal_c;                                            \
        prec = 1;                                                           \
      }                                                                     \
      else if ((BASE) == 16)                                                \
      {                                                                     \
        iformat = PRIx32;                                                   \
        prec = (JITTER_ARGN0 / 4) + ((JITTER_ARGN0 % 4) != 0);              \
      }                                                                     \
      else if ((BASE) == 8)                                                 \
      {                                                                     \
        basefmt = PRIo32;                                                   \
        prec = (JITTER_ARGN0 / 3) + ((JITTER_ARGN0 % 3) != 0);              \
      }                                                                     \
      else if ((BASE) == 2)                                                 \
      {                                                                     \
        PK_PRINT_BINARY (val, JITTER_ARGN0);                                \
        JITTER_DROP_STACK ();                                               \
        JITTER_DROP_STACK ();                                               \
        break;                                                              \
      }                                                                     \
                                                                            \
      PVM_ASSERT (prec != 0);                                               \
      fmt[2] = '0' + (prec / 10);                                           \
      fmt[3] = '0' + prec - (prec / 10 * 10);                               \
      fmt[4] = '\0';                                                        \
      pvm_strcat (fmt, iformat);                                            \
      pvm_strcat (fmt, basefmt);                                            \
    }                                                                       \
                                                                            \
    pk_printf (fmt, (BASE) == 10 ? val : val & mask);                       \
    JITTER_DROP_STACK ();                                                   \
    JITTER_DROP_STACK ();                                                   \
  } while (0)

#define PVM_PRINTL(TYPE,TYPEC,SIGNED_P,BASE)                                \
  do                                                                        \
  {                                                                         \
    TYPEC val = PVM_VAL_##TYPE (JITTER_UNDER_TOP_STACK ());                 \
    char fmt[16];  /* %0NNfff */                                            \
    char *iformat = pvm_literal_empty;                                      \
    uint64_t mask                                                           \
        = JITTER_ARGN0 == 64 ? (uint64_t)-1                                 \
                             : (((uint64_t)1 << JITTER_ARGN0) - 1);         \
                                                                            \
    fmt[0] = '%';                                                           \
    fmt[1] = '0';                                                           \
    fmt[2] = '\0';                                                          \
    if ((BASE) == 10)                                                       \
    {                                                                       \
      iformat = SIGNED_P ? PRIi64 : PRIu64;                                 \
      pvm_strcat (fmt, iformat);                                            \
    }                                                                       \
    else                                                                    \
    {                                                                       \
      char *basefmt = pvm_literal_empty;                                    \
      int prec = 0;                                                         \
                                                                            \
      if ((BASE) == 16)                                                     \
      {                                                                     \
        iformat = PRIx64;                                                   \
        prec = (JITTER_ARGN0 / 4) + ((JITTER_ARGN0 % 4) != 0);              \
      }                                                                     \
      else if ((BASE) == 8)                                                 \
      {                                                                     \
        basefmt = PRIo64;                                                   \
        prec = (JITTER_ARGN0 / 3) + ((JITTER_ARGN0 % 3) != 0);              \
      }                                                                     \
      else if ((BASE) == 2)                                                 \
      {                                                                     \
        PK_PRINT_BINARY (val, JITTER_ARGN0);                                \
        JITTER_DROP_STACK ();                                               \
        JITTER_DROP_STACK ();                                               \
        break;                                                              \
      }                                                                     \
                                                                            \
      fmt[2] = '0' + (prec / 10);                                           \
      fmt[3] = '0' + prec - (prec / 10 * 10);                               \
      fmt[4] = '\0';                                                        \
      pvm_strcat (fmt, iformat);                                            \
      pvm_strcat (fmt, basefmt);                                            \
    }                                                                       \
                                                                            \
    pk_printf (fmt, (BASE) == 10 ? val : val & mask);                       \
    JITTER_DROP_STACK ();                                                   \
    JITTER_DROP_STACK ();                                                   \
  } while (0)

/* Macros to implement formati* and formatl* instructions.  */

#define PVM_FORMATI(OUT,OUTLEN,TYPE,TYPEC,SIGNED_P,BASE)                    \
  do                                                                        \
  {                                                                         \
    TYPEC val = PVM_VAL_##TYPE (JITTER_UNDER_TOP_STACK ());                 \
    char fmt[16];  /* %0NNd */                                              \
    char *iformat = pvm_literal_empty;                                      \
    int n;                                                                  \
    uint32_t mask                                                           \
        = JITTER_ARGN0 == 32 ? (uint32_t)-1                                 \
                             : (((uint32_t)1 << JITTER_ARGN0) - 1);         \
                                                                            \
    fmt[0] = '%';                                                           \
    fmt[1] = '0';                                                           \
    fmt[2] = '\0';                                                          \
    if ((BASE) == 10)                                                       \
    {                                                                       \
      iformat = SIGNED_P ? PRIi32 : PRIu32;                                 \
      pvm_strcat (fmt, iformat);                                            \
    }                                                                       \
    else                                                                    \
    {                                                                       \
      char *basefmt = pvm_literal_empty;                                    \
      int prec = 0;                                                         \
                                                                            \
      if ((BASE) == 256)                                                    \
      {                                                                     \
        iformat = pvm_literal_c;                                            \
        prec = 1;                                                           \
      }                                                                     \
      else if ((BASE) == 16)                                                \
      {                                                                     \
        iformat = PRIx32;                                                   \
        prec = (JITTER_ARGN0 / 4) + ((JITTER_ARGN0 % 4) != 0);              \
      }                                                                     \
      else if ((BASE) == 8)                                                 \
      {                                                                     \
        basefmt = PRIo32;                                                   \
        prec = (JITTER_ARGN0 / 3) + ((JITTER_ARGN0 % 3) != 0);              \
      }                                                                     \
      else if ((BASE) == 2)                                                 \
      {                                                                     \
        n = pk_format_binary ((OUT), (OUTLEN), val, JITTER_ARGN0, SIGNED_P, 0);\
        PVM_ASSERT (n == 0);                                                \
        JITTER_DROP_STACK ();                                               \
        JITTER_DROP_STACK ();                                               \
        JITTER_PUSH_STACK (pvm_make_string ((OUT)));                        \
        break;                                                              \
      }                                                                     \
                                                                            \
      PVM_ASSERT (prec != 0);                                               \
      fmt[2] = '0' + (prec / 10);                                           \
      fmt[3] = '0' + prec - (prec / 10 * 10);                               \
      fmt[4] = '\0';                                                        \
      pvm_strcat (fmt, iformat);                                            \
      pvm_strcat (fmt, basefmt);                                            \
    }                                                                       \
                                                                            \
    n = pvm_snprintf ((OUT), (OUTLEN), fmt,  (BASE) == 10 ? val : val & mask);  \
    PVM_ASSERT (n < (OUTLEN));                                              \
    JITTER_DROP_STACK ();                                                   \
    JITTER_DROP_STACK ();                                                   \
    JITTER_PUSH_STACK (pvm_make_string ((OUT)));                            \
  } while (0)

#define PVM_FORMATL(OUT,OUTLEN,TYPE,TYPEC,SIGNED_P,BASE)                    \
  do                                                                        \
  {                                                                         \
    TYPEC val = PVM_VAL_##TYPE (JITTER_UNDER_TOP_STACK ());                 \
    char fmt[16];  /* %0NNfff */                                            \
    char *iformat = pvm_literal_empty;                                      \
    int n;                                                                  \
    uint64_t mask                                                           \
        = JITTER_ARGN0 == 64 ? (uint64_t)-1                                 \
                             : (((uint64_t)1 << JITTER_ARGN0) - 1);         \
                                                                            \
    fmt[0] = '%';                                                           \
    fmt[1] = '0';                                                           \
    fmt[2] = '\0';                                                          \
    if ((BASE) == 10)                                                       \
    {                                                                       \
      iformat = SIGNED_P ? PRIi64 : PRIu64;                                 \
      pvm_strcat (fmt, iformat);                                            \
    }                                                                       \
    else                                                                    \
    {                                                                       \
      char *basefmt = pvm_literal_empty;                                    \
      int prec = 0;                                                         \
                                                                            \
      if ((BASE) == 16)                                                     \
      {                                                                     \
        iformat = PRIx64;                                                   \
        prec = (JITTER_ARGN0 / 4) + ((JITTER_ARGN0 % 4) != 0);              \
      }                                                                     \
      else if ((BASE) == 8)                                                 \
      {                                                                     \
        basefmt = PRIo64;                                                   \
        prec = (JITTER_ARGN0 / 3) + ((JITTER_ARGN0 % 3) != 0);              \
      }                                                                     \
      else if ((BASE) == 2)                                                 \
      {                                                                     \
        n = pk_format_binary ((OUT), (OUTLEN), val, JITTER_ARGN0, SIGNED_P, 0);\
        PVM_ASSERT (n == 0);                                                \
        JITTER_DROP_STACK ();                                               \
        JITTER_DROP_STACK ();                                               \
        JITTER_PUSH_STACK (pvm_make_string ((OUT)));                        \
        break;                                                              \
      }                                                                     \
                                                                            \
      fmt[2] = '0' + (prec / 10);                                           \
      fmt[3] = '0' + prec - (prec / 10 * 10);                               \
      fmt[4] = '\0';                                                        \
      pvm_strcat (fmt, iformat);                                            \
      pvm_strcat (fmt, basefmt);                                            \
    }                                                                       \
                                                                            \
    n = pvm_snprintf ((OUT), (OUTLEN), fmt,  (BASE) == 10 ? val : val & mask);  \
    PVM_ASSERT (n < (OUTLEN));                                              \
    JITTER_DROP_STACK ();                                                   \
    JITTER_DROP_STACK ();                                                   \
    JITTER_PUSH_STACK (pvm_make_string ((OUT)));                            \
  } while (0)

#define PVM_FORMATF(RESULT,NUM,PREC,STYLE,TYPEF)                            \
  do                                                                        \
    {                                                                       \
      TYPEF x;                                                              \
      int n;                                                                \
      char fmt[16];                                                         \
                                                                            \
      PVM_ASSERT (sizeof (x) == sizeof (NUM));                              \
      PVM_ASSERT ((STYLE) < 3);                                             \
                                                                            \
      pvm_memcpy (&x, &(NUM), sizeof (NUM));                                \
      n = pvm_snprintf (fmt, sizeof (fmt), pvm_literal_formatf_fmt,         \
                        (unsigned)(PREC), pvm_literal_formatf_styles[(STYLE)]); \
      if (n == -1)                                                          \
        PVM_RAISE_DFL (PVM_E_CONV);                                         \
      n = pvm_asprintf (&(RESULT), fmt, x);                                 \
      if (n == -1)                                                          \
        PVM_RAISE_DFL (PVM_E_CONV);                                         \
    }                                                                       \
  while (0)

#define RTRACE(N)                                                           \
  do                                                                        \
    {                                                                       \
      int i = 0;                                                            \
      int num_elems = (N);                                                  \
      int num_elems_in_stack;                                               \
                                                                            \
      PVM_ASSERT (PVM_STATE_BACKING_FIELD (canary_stack) != NULL);          \
      num_elems_in_stack = (pvm_val *)JITTER_HEIGHT_RETURNSTACK ()          \
                            - (pvm_val *)PVM_STATE_BACKING_FIELD (canary_returnstack); \
      if (num_elems == 0 || num_elems > num_elems_in_stack)                 \
        num_elems = num_elems_in_stack;                                     \
                                                                            \
      PVM_ASSERT (num_elems_in_stack % 3 == 0);                             \
      for (i = 2; i < num_elems; i += 3)                                    \
        {                                                                   \
          pvm_val name = JITTER_AT_DEPTH_RETURNSTACK (i);                   \
                                                                            \
          if (name == PVM_NULL)                                             \
            pk_printf ("<lambda>\n");                                       \
          else                                                              \
            pk_printf ("%s\n", PVM_VAL_STR (name));                         \
        }                                                                   \
    }                                                                       \
  while (0)

  end
end

late-c
  code
    void
    pvm_handle_signal (int signal_number)
    {
      struct vmprefix_state *s;

      /* For every state... */
      VMPREFIX_FOR_EACH_STATE (s)
      {
        /* ...Mark the signal signal_number as pending... */
        VMPREFIX_STATE_AND_SIGNAL_TO_PENDING_SIGNAL_NOTIFICATION
           (s, signal_number) = true;
        /* ...And record the fact that there is at least one notification to
           handle. */
        VMPREFIX_STATE_TO_PENDING_NOTIFICATIONS (s) = true;
      }
    }

    /* These are not `const' to suppress compiler warnings.  */
    static char *pvm_literal_empty = "";
    static char *pvm_literal_c = "c";

    static const char *pvm_literal_code = "code";
    static const char *pvm_literal_enomem = "out of memory";
    static const char *pvm_literal_no_toplevel_var = "no top-level variable found";
    static const char *pvm_literal_eindex = "invalid index in ains";
    static const char *pvm_literal_notmappable = "not mappable value";
    static const char *pvm_literal_newline = "\n";
    static const char *pvm_literal_formatf_fmt = "%%.%u%c";
    static const char pvm_literal_formatf_styles[3] = { 'f', 'e', 'g' };
    static const char *pvm_literal_dispatch_name = PVM_DISPATCH_HUMAN_READABLE;

#define E(key) [PVM_E_##key] = PVM_E_##key##_NAME,
    static const char *pvm_exception_names[] = {
      PVM_EXCEPTIONS(E)
    };
#undef E

    struct ionum_ctx
    {
      uint64_t count;
    };

    static void
    ionum_callback (ios io, void *data)
    {
      struct ionum_ctx *ctx = data;

      ++ctx->count;
    }

    struct ioref_ctx
    {
      uint64_t index;
      int ios_id;
    };

    static void
    ioref_callback (ios io, void *data)
    {
      struct ioref_ctx *ctx = data;

      if (ctx->ios_id != -1)
        return;
      if (ctx->index == 0)
        ctx->ios_id = ios_get_id (io);
      else
        --ctx->index;
    }
  end
end

printer-c
  code
    static jitter_uint printer_hi;

    static void
    pvm_literal_printer_cast (jitter_print_context out, jitter_uint val,
                              void *user_data __attribute__ ((unused)))
    {
      pk_printf ("%" JITTER_PRIu, val);
      pk_term_flush ();
    }

    static void
    pvm_literal_printer (jitter_print_context out, jitter_uint val,
                         void *user_data __attribute__ ((unused)))
    {
      pvm_print_val_with_params (NULL /* not used since no
                                         pretty-print */,
                                 (pvm_val) val,
                                 1 /* depth */,
                                 PVM_PRINT_FLAT,
                                 16 /* base */,
                                 0 /* indent */,
                                 2 /* acutoff */,
                                 0 /* flags */,
                                 NULL /* exit_exception */);
      pk_term_flush ();
    }

    static void
    pvm_literal_printer_hi (jitter_print_context out, jitter_uint hi,
                            void *user_data __attribute__ ((unused)))
    {
      pk_printf ("%%hi(0x%" JITTER_PRIx ")", hi);
      pk_term_flush ();
      printer_hi = hi; /* This sucks */
    }

    static void
    pvm_literal_printer_lo (jitter_print_context out, jitter_uint lo,
                            void *user_data __attribute__ ((unused)))
    {
      pk_printf ("%%lo(0x%" JITTER_PRIx") (", lo);

      pvm_print_val_with_params (NULL /* not used since no
                                         pretty-print */,
                                 ((pvm_val) printer_hi << 32) | lo,
                                 1 /* depth */,
                                 PVM_PRINT_FLAT,
                                 16 /* base */,
                                 0 /* indent */,
                                 2 /* acutoff */,
                                 0 /* flags */,
                                 NULL /* exit_exception */);
      pk_puts (")");
      pk_term_flush ();
      printer_hi = 0;
    }

    static void
    popf_printer (jitter_print_context out, jitter_uint nframes,
                  void *user_data __attribute__ ((unused)))
    {
      pk_printf ("%" JITTER_PRIu, nframes);
      pk_term_flush ();
    }

    static void
    bits_printer (jitter_print_context out, jitter_uint val,
                  void *user_data __attribute__ ((unused)))
    {
      pk_printf ("%" JITTER_PRIu, val);
      pk_term_flush ();
    }

    static void
    endian_printer (jitter_print_context out, jitter_uint val,
                    void *user_data __attribute__ ((unused)))
    {
      pk_printf ("%s", val == IOS_ENDIAN_MSB ? "big" : "little");
      pk_term_flush ();
    }

    static void
    nenc_printer (jitter_print_context out, jitter_uint val,
                  void *user_data __attribute__ ((unused)))
    {
      pk_printf ("%s", val == IOS_NENC_1 ? "1c" : "2c");
      pk_term_flush ();
    }
  end
end


## PVM state.

# Jitter supports maintaining a VM state which is split in
# `backing' and `runtime', so the question arises what to put in either
# part of the state.  According to the comments generated by jitterc:
#
# "The machine state is separated into the backing and the more
#  compact runtime data structures, to be allocated in registers as
#  far as possible.  These are just a forward-declarations: the actual
#  definitions are machine-generated."
#
# and:
#
# "The state backing and runtime are initialized at the same time, and
#  in fact the distinction between them is invisible to the VM user."
#
# So it looks like both `backing' and `runtime' are available at
# runtime, but accessing runtime is much more efficient because it is
# kept in host machine registers if possible.

state-struct-backing-c
  code
      enum pvm_exit_code exit_code;
      pvm_val result_value;
      pvm_val exit_exception_value;
      jitter_stack_height canary_stack;
      jitter_stack_height canary_returnstack;
      jitter_stack_height canary_exceptionstack;
      pvm vm;
      ios_context ios_ctx;
  end
end

state-struct-runtime-c
  code
      pvm_env env;
      uint32_t push_hi;
      uint32_t endian;
      uint32_t nenc;
      uint32_t pretty_print;
      enum pvm_omode omode;
      int obase;
      int omaps;
      uint32_t odepth;
      uint32_t oindent;
      uint32_t oacutoff;
      uint32_t autoremap;
  end
end

state-initialization-c
  code
      jitter_state_backing->vm = NULL;
      jitter_state_backing->canary_stack = NULL;
      jitter_state_backing->canary_returnstack = NULL;
      jitter_state_backing->canary_exceptionstack = NULL;
      jitter_state_backing->exit_code = PVM_EXIT_OK;
      jitter_state_backing->result_value = PVM_NULL;
      jitter_state_backing->ios_ctx = NULL;
      jitter_state_runtime->endian = IOS_ENDIAN_MSB;
      jitter_state_runtime->nenc = IOS_NENC_2;
      jitter_state_runtime->pretty_print = 0;
      jitter_state_runtime->omode = PVM_PRINT_FLAT;
      jitter_state_runtime->obase = 10;
      jitter_state_runtime->omaps = 0;
      jitter_state_runtime->odepth = 0;
      jitter_state_runtime->oindent = 2;
      jitter_state_runtime->oacutoff = 0;
      jitter_state_runtime->autoremap = 1;
  end
end

state-finalization-c
  code
   /* Finalize extra state here.  */
  end
end


### Begin of instructions

# In the instruction descriptions below, references to "the stack"
# refer to the main stack.  References to the other stacks (exceptions
# stack, return stack) are always explicit.

## VM instructions

# Instruction: canary
#
# This instruction installs a canary to mark the bottom of the stack,
# which is checked by the `exit' instruction.  To be most effective
# this should be executed before the stack is used for the first time.
#
# Stack: ( -- )

instruction canary ()
  code
     PVM_STATE_BACKING_FIELD (canary_stack) = JITTER_HEIGHT_STACK ();
     PVM_STATE_BACKING_FIELD (canary_returnstack) =
       JITTER_HEIGHT_RETURNSTACK ();
     PVM_STATE_BACKING_FIELD (canary_exceptionstack) =
       JITTER_HEIGHT_EXCEPTIONSTACK ();
  end
end

# Instruction: exit
#
# Do some cleanup and finish execution of a PVM program.  This checks
# the stack sentinel installed by the `canary' instruction.
#
# Stack: ( -- )

instruction exit ()
  branching
  code
    /* The element at the top of the stack is the exit
       code to report to the PVM caller.  */
    PVM_STATE_BACKING_FIELD (exit_code)
      = PVM_VAL_INT (JITTER_TOP_STACK());

    JITTER_DROP_STACK ();

    /* Get the result of the execution, if any.  */
    PVM_STATE_BACKING_FIELD (result_value)
                = JITTER_TOP_STACK();
    JITTER_DROP_STACK ();

    /* Check for the stack sentinel, but only if it was
       installed.  */
    if (PVM_STATE_BACKING_FIELD (canary_stack) != NULL)
      PVM_ASSERT (PVM_STATE_BACKING_FIELD (canary_stack)
                  == JITTER_HEIGHT_STACK ());
    if (PVM_STATE_BACKING_FIELD (canary_returnstack) != NULL)
      PVM_ASSERT (PVM_STATE_BACKING_FIELD (canary_returnstack)
                  == JITTER_HEIGHT_RETURNSTACK ());
    if (PVM_STATE_BACKING_FIELD (canary_exceptionstack) != NULL)
      PVM_ASSERT (PVM_STATE_BACKING_FIELD (canary_exceptionstack)
                  == JITTER_HEIGHT_EXCEPTIONSTACK ());

    /* Clear pending signals.  */
    {
      int i;
      for (i = 0; i < JITTER_SIGNAL_NO; i ++)
        if (JITTER_PENDING_SIGNAL_NOTIFICATION (i))
          JITTER_PENDING_SIGNAL_NOTIFICATION (i) = false;
      JITTER_PENDING_NOTIFICATIONS = false;
    }

    JITTER_EXIT ();
  end
end

# Instruction: pushend
#
# Push the current endianness on the stack.  This endianness is part
# of the global state of the PVM.
#
# Stack: ( -- INT )

instruction pushend ()
  code
    int endian = PVM_STATE_RUNTIME_FIELD (endian);
    JITTER_PUSH_STACK (PVM_MAKE_INT (endian, 32));
  end
end

# Instruction: popend
#
# Pop a signed integer from the stack and make it the current
# endianness in the PVM.  The possible values for endianness are
# IOS_ENDIAN_LSB and IOS_ENDIAN_MSB.
#
# Stack: ( INT -- )

instruction popend ()
  code
    uint32_t endian = PVM_VAL_INT (JITTER_TOP_STACK ());
    PVM_STATE_RUNTIME_FIELD (endian) = endian;
    JITTER_DROP_STACK ();
  end
end

# Instruction: pushob
#
# Push output base.
#
# This instruction pushes a signed integer value with the output base
# that is used when printing PVM values.  Valid values are 2, 8, 10
# and 16.
#
# Stack: ( -- INT )

instruction pushob ()
  code
    int obase = PVM_STATE_RUNTIME_FIELD (obase);
    JITTER_PUSH_STACK (PVM_MAKE_INT (obase, 32));
  end
end

# Instruction: popob
#
# Pop and set output base.
#
# This instructions pops a signed integer from the stack and uses it
# to set the new output base to be used when printing PVM values.
# Valid values are 2, 8, 10 and 16.  If an invalid value is provided
# then the instruction is a NOP.
#
# Stack: ( INT -- )

instruction popob ()
  code
    int obase = PVM_VAL_INT (JITTER_TOP_STACK ());

    if (obase == 2 || obase == 8 || obase == 10 || obase == 16)
    {
      PVM_STATE_RUNTIME_FIELD (obase) = obase;
      JITTER_DROP_STACK ();
    }
  end
end

# Instruction: pushom
#
# Push output mode.
#
# This instruction pushes a signed integer value with the output mode
# that is used when printing PVM values.  Valid values are 0 for flat
# mode, and 1 for tree mode.
#
# Stack: ( -- INT )

instruction pushom ()
  code
    int omode = PVM_STATE_RUNTIME_FIELD (omode);
    JITTER_PUSH_STACK (PVM_MAKE_INT (omode, 32));
  end
end

# Instruction: popom
#
# Pop and set output mode.
#
# This instructions pops a signed integer from the stack and uses it
# to set the new output mode to be used when printing PVM values.
# Valid values are 0 for flat mode and 1 for tree mode.  If an invalid
# value is provided then this instruction is a no-op.
#
# Stack: ( INT -- )

instruction popom ()
  code
    int omode = PVM_VAL_INT (JITTER_TOP_STACK ());

    if (omode == PVM_PRINT_FLAT || omode == PVM_PRINT_TREE)
    {
      PVM_STATE_RUNTIME_FIELD (omode) = omode;
      JITTER_DROP_STACK ();
    }
  end
end

# Instruction: pushoo
#
# Push output offsets mode.
#
# This instruction pushes a boolean encoded in a signed integer value
# indicating whether to show offsets when printing PVM values.
#
# Stack: ( -- INT )

instruction pushoo ()
  code
    int omaps = PVM_STATE_RUNTIME_FIELD (omaps);
    JITTER_PUSH_STACK (PVM_MAKE_INT (omaps, 32));
  end
end

# Instruction: popoo
#
# Pop and set output offsets mode.
#
# This instructions pops a boolean encoded in a signed integer from
# the stack and uses it to set the new output offset mode to be used
# when printing PVM values.
#
# Stack: ( INT -- )

instruction popoo ()
  code
    int omaps = PVM_VAL_INT (JITTER_TOP_STACK ());

    PVM_STATE_RUNTIME_FIELD (omaps) = omaps;
    JITTER_DROP_STACK ();
  end
end

# Instruction: pushoi
#
# Push output indentation mode.
#
# This instructions pushes an integer to the stack with the current
# indentation step configured in the VM.  The indentation step
# determines how many white characters to use in each indentation
# level when printing output.
#
# Stack: ( -- INT )

instruction pushoi ()
  code
    int oindent = PVM_STATE_RUNTIME_FIELD (oindent);
    JITTER_PUSH_STACK (PVM_MAKE_INT (oindent, 32));
  end
end

# Instruction: popoi
#
# Pop and set output indentation step mode.
#
# This instructions pops an integer from the stack and uses it to
# set the current indentation step in the VM.  The indentation step
# determines how many white characters to use in each indentation
# level when printing output.
#
# Stack: ( INT -- )

instruction popoi ()
  code
    int oindent = PVM_VAL_INT (JITTER_TOP_STACK ());

    PVM_STATE_RUNTIME_FIELD (oindent) = oindent;
    JITTER_DROP_STACK ();
  end
end

# Instruction: pushod
#
# Push output depth.
#
# This instruction pushes a signed integer indicating the depth to use
# when printing PVM values.
#
# Stack: ( -- INT )

instruction pushod ()
  code
    int odepth = PVM_STATE_RUNTIME_FIELD (odepth);
    JITTER_PUSH_STACK (PVM_MAKE_INT (odepth, 32));
  end
end

# Instruction: popod
#
# Pop and set output depth.
#
# This instructions pops a signed integer indicating the maximum depth
# included by the VM when printing values.
#
# Stack: ( INT -- )

instruction popod ()
  code
    int odepth = PVM_VAL_INT (JITTER_TOP_STACK ());

    PVM_STATE_RUNTIME_FIELD (odepth) = odepth;
    JITTER_DROP_STACK ();
  end
end

# Instruction: pushoac
#
# Push output array cutoff.
#
# This instruction pushes a signed integer indicating the number of
# elements that the VM includes in the printed representation of PVM
# array values.
#
# Stack: ( -- INT )

instruction pushoac ()
  code
    int oacutoff = PVM_STATE_RUNTIME_FIELD (oacutoff);
    JITTER_PUSH_STACK (PVM_MAKE_INT (oacutoff, 32));
  end
end

# Instruction: popoac
#
# Pop and set output array cutoff.
#
# This instructions pops a signed integer indicating the number of
# elements that the VM includes in the printed representation of PVM
# array values.
#
# Stack: ( INT -- )

instruction popoac ()
  code
    int oacutoff = PVM_VAL_INT (JITTER_TOP_STACK ());

    PVM_STATE_RUNTIME_FIELD (oacutoff) = oacutoff;
    JITTER_DROP_STACK ();
  end
end

# Instruction: pushopp
#
# Push pretty-print usage.
#
# This instruction pushes a signed integer indicating whether the VM
# is configured to use pretty-printers.
#
# Stack: ( -- INT )

instruction pushopp ()
  code
    int pp = PVM_STATE_RUNTIME_FIELD (pretty_print);
    JITTER_PUSH_STACK (PVM_MAKE_INT (!!pp, 32));
  end
end

# Instruction: popopp
#
# Pop and set usage of pretty-printers.
#
# This instructions pops a signed integer indicating whether to use
# pretty-printers when printing values and sets it in the VM.
#
# Stack: ( INT -- )

instruction popopp ()
  code
    int pp = PVM_VAL_INT (JITTER_TOP_STACK ());

    PVM_STATE_RUNTIME_FIELD (pretty_print) = pp;
    JITTER_DROP_STACK ();
  end
end

# Instruction: pushoc
#
# Push the current output color to the stack, encoded as a
# RGB triplet.
#
# Stack: ( -- INT INT INT )

instruction pushoc ()
  code
    struct pk_color color = pk_term_get_color ();

    JITTER_PUSH_STACK (PVM_MAKE_INT (color.red, 32));
    JITTER_PUSH_STACK (PVM_MAKE_INT (color.green, 32));
    JITTER_PUSH_STACK (PVM_MAKE_INT (color.blue, 32));
  end
end

# Instruction: popoc
#
# Pop the RGB triplet at the top of the stack and use it to set
# the new terminal output color.
#
# Stack: ( INT INT INT -- )

instruction popoc ()
  code
    struct pk_color color;

    color.blue = PVM_VAL_INT (JITTER_TOP_STACK ());
    color.green = PVM_VAL_INT (JITTER_UNDER_TOP_STACK ());
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    color.red = PVM_VAL_INT (JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();

    pk_term_set_color (color);
  end
end

# Instruction: pushobc
#
# Push the current output background color to the stack, encoded as a
# RGB triplet.
#
# Stack: ( -- INT INT INT )

instruction pushobc ()
  code
    struct pk_color color = pk_term_get_bgcolor ();

    JITTER_PUSH_STACK (PVM_MAKE_INT (color.red, 32));
    JITTER_PUSH_STACK (PVM_MAKE_INT (color.green, 32));
    JITTER_PUSH_STACK (PVM_MAKE_INT (color.blue, 32));
  end
end

# Instruction: popobc
#
# Pop the RGB triplet at the top of the stack and use it to set
# the new terminal output background color.
#
# Stack: ( INT INT INT -- )

instruction popobc ()
  code
    struct pk_color color;

    color.blue = PVM_VAL_INT (JITTER_TOP_STACK ());
    color.green = PVM_VAL_INT (JITTER_UNDER_TOP_STACK ());
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    color.red = PVM_VAL_INT (JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();

    pk_term_set_bgcolor (color);
  end
end

# Instruction: sync
#
# Handle pending signals, and raise exceptions accordingly.  This
# instruction should be emitted in strategic places, such as before
# backwards jumps and at function prolog, to assure signals are
# eventually attended to.
#
# Stack: ( -- )
# Exceptions: PVM_E_SIGNAL

instruction sync ()
  branching # because of PVM_RAISE_DIRECT
  code
    /* XXX for now we treat all signals the same way.
       As soon as we support exception arguments, we shall
       pass the mask of signals to the signal handler.  */
    if (JITTER_PENDING_NOTIFICATIONS)
      PVM_RAISE_DFL (PVM_E_SIGNAL);
  end
end

# Instruction: pusharem
#
# Push autoremap flag.
#
# This instruction pushes a signed integer indicating whether the
# VM is in `autoremap' mode.
#
# Stack: ( -- INT )

instruction pusharem ()
  code
    int autoremap = PVM_STATE_RUNTIME_FIELD (autoremap);
    JITTER_PUSH_STACK (PVM_MAKE_INT (autoremap, 32));
  end
end

# Instruction: poparem
#
# Pop and set the autoremap flag.
#
# This instruction pops a signed integer from the stack and sets
# it as the new value of the `autoremap' flag.
#
# Stack: ( INT -- )

instruction poparem ()
  code
    int autoremap = PVM_VAL_INT (JITTER_TOP_STACK ());
    PVM_STATE_RUNTIME_FIELD (autoremap) = autoremap;
    JITTER_DROP_STACK ();
  end
end


## IOS related instructions

# Instruction: open
#
# Open a new IO space.  The handler string and a set of flags are
# passed on the stack.  The descriptor of the opened IOS is pushed to
# the stack as a signed integer.
#
# If there is no other IO space opened when this instruction is
# executed, then the just opened space becomes the current IO space.
#
# If there is an error condition opening the IO space, a negative
# number indicating the condition is pushed on the stack.  Note that
# valid IOS descriptors are non-negative.  The possible error
# conditions are:
#
# -1 for an unspecified error condition.
# -3 invalid flags specified
# -4 memory allocation failure.
# -5 end of file
# -6 invalid argument passed to open
# -7 IO space already opened
# -8 Insufficient permissions to perform the requested operation.
#
# Stack: ( STR ULONG -- INT )

instruction open ()
  code
     char *filename = PVM_VAL_STR (JITTER_UNDER_TOP_STACK ());
     uint64_t flags = PVM_VAL_ULONG (JITTER_TOP_STACK ());
     ios_context ios_ctx = PVM_STATE_BACKING_FIELD (ios_ctx);

     int ret = ios_open (ios_ctx, filename, flags, 0);
     JITTER_DROP_STACK ();
     JITTER_TOP_STACK () = PVM_MAKE_INT (ret, 32);
  end
end

# Instruction: close
#
# Close an IO space.  The descriptor of the space to close is provided
# on the stack as a signed integer.
#
# If the specified IO space doesn't exist, this instruction pushes
# PVM_E_NO_IOS. If the operation fails, it pushes PVM_E_IO.  Otherwise,
# it pushes PVM_NULL
#
# Stack: ( INT -- EXCEPTION|null )

instruction close ()
  code
    int io_id = PVM_VAL_INT (JITTER_TOP_STACK ());
    ios_context ios_ctx = PVM_STATE_BACKING_FIELD (ios_ctx);
    ios io = ios_search_by_id (ios_ctx, io_id);

    if (io == NULL)
      JITTER_TOP_STACK () = PVM_MAKE_DFL_EXCEPTION (PVM_E_NO_IOS);
    else if (ios_close (ios_ctx, io) != IOS_OK)
      JITTER_TOP_STACK () = PVM_MAKE_DFL_EXCEPTION (PVM_E_IO);
    else
      JITTER_TOP_STACK () = PVM_NULL;
  end
end

# Instruction: flush
#
#
# Flush an IO space.  The descriptor of the space to flush, and the
# bit-offset up to which perform the flushing are provided on the stack.
#
# If the specified IO space doesn't exist, this instruction pushes
# PVM_E_NO_IOS. If the operation fails, it pushes PVM_E_IO.  Otherwise,
# it pushes PVM_NULL
#
# Stack: ( INT ULONG -- EXCEPTION|null )

instruction flush ()
  code
    ios_off offset = PVM_VAL_ULONG (JITTER_TOP_STACK ());
    int io_id = PVM_VAL_INT (JITTER_UNDER_TOP_STACK ());
    ios_context ios_ctx = PVM_STATE_BACKING_FIELD (ios_ctx);
    ios io = ios_search_by_id (ios_ctx, io_id);

    JITTER_DROP_STACK ();

    if (io == NULL)
      JITTER_TOP_STACK () = PVM_MAKE_DFL_EXCEPTION (PVM_E_NO_IOS);
    else if (ios_flush (io, offset) != IOS_OK)
      JITTER_TOP_STACK () = PVM_MAKE_DFL_EXCEPTION (PVM_E_IO);
    else
      JITTER_TOP_STACK () = PVM_NULL;
  end
end

# Instruction: isios
#
# Push 1 if the given IO space descriptor on the stack is a valid one;
# otherwise push 0.
#
# Stack: ( INT -- INT INT )

instruction isios ()
  code
    ios_context ios_ctx = PVM_STATE_BACKING_FIELD (ios_ctx);
    ios io = ios_search_by_id (ios_ctx, PVM_VAL_INT (JITTER_TOP_STACK ()));

    JITTER_PUSH_STACK (PVM_MAKE_INT (io != NULL, 32));
  end
end

# Instruction: pushios
#
# Push the descriptor of the current IO space on the stack, as a
# signed integer.  If no IO space is currently opened, push a negative
# number.
#
# Stack: ( -- INT )

instruction pushios ()
  code
    ios_context ios_ctx = PVM_STATE_BACKING_FIELD (ios_ctx);
    ios cur_io = ios_cur (ios_ctx);

    if (cur_io == NULL)
       JITTER_PUSH_STACK (PVM_MAKE_INT (-1, 32));
    else
       JITTER_PUSH_STACK (PVM_MAKE_INT (ios_get_id (cur_io), 32));
  end
end

# Instruction: popios
#
# Pop an IO space descriptor from the stack and set it as the current
# IO space.
# The given IO space must exist.
#
# Stack: ( INT -- )

instruction popios ()
  code
    ios_context ios_ctx = PVM_STATE_BACKING_FIELD (ios_ctx);
    ios io = ios_search_by_id (ios_ctx, PVM_VAL_INT (JITTER_TOP_STACK ()));

    PVM_ASSERT (io != NULL);

    JITTER_DROP_STACK ();
    ios_set_cur (ios_ctx, io);
  end
end

# Instruction: ioflags
#
# Push an unsigned 64-bit integer with the flags of the given IO space
# on the stack.  The IO space is identified by a descriptor, which is
# a signed integer.
# The given IO space must exist.
#
# Stack: ( INT -- INT ULONG )

instruction ioflags ()
  code
    ios_context ios_ctx = PVM_STATE_BACKING_FIELD (ios_ctx);
    ios io = ios_search_by_id (ios_ctx, PVM_VAL_INT (JITTER_TOP_STACK ()));

    PVM_ASSERT (io != NULL);
    JITTER_PUSH_STACK (PVM_MAKE_ULONG (ios_flags (io), 64));
  end
end

# Instruction: iosize
#
# Push the size of the given IO space on the stack, as an offset.  The
# IO space is identified by a descriptor, which is a signed integer.
# The given IO space must exist.
#
# Stack: ( INT -- INT OFF )

instruction iosize ()
  code
    ios_context ios_ctx = PVM_STATE_BACKING_FIELD (ios_ctx);
    ios io = ios_search_by_id (ios_ctx, PVM_VAL_INT (JITTER_TOP_STACK ()));
    pvm_val magnitude;
    pvm_val type;

    PVM_ASSERT (io != NULL);

    magnitude = PVM_MAKE_ULONG (ios_size (io), 64);
    type = pvm_make_offset_type (pvm_typeof (magnitude),
                                 PVM_MAKE_ULONG (8, 64), PVM_NULL /* ref_type */);

    JITTER_PUSH_STACK (pvm_make_offset (PVM_MAKE_ULONG (ios_size (io), 64), type));
  end
end

# Instruction: ionum
#
# Push the number of IO spaces on the stack.
#
# Stack: ( -- ULONG )

instruction ionum ()
  code
    struct ionum_ctx ctx;
    ios_context ios_ctx = PVM_STATE_BACKING_FIELD (ios_ctx);

    ctx.count = 0;
    ios_map (ios_ctx, ionum_callback, &ctx);
    JITTER_PUSH_STACK (PVM_MAKE_ULONG (ctx.count, 64));
  end
end

# Instruction: ioref
#
# Given an index ULONG, push the descriptor of the IO space on
# the stack as a signed integer.
#
# If the provided index is out of bounds, push a negative number.
#
# Stack: ( ULONG -- ULONG IOS )

instruction ioref ()
  code
    ios_context ios_ctx = PVM_STATE_BACKING_FIELD (ios_ctx);
    struct ioref_ctx ctx;

    ctx.index = PVM_VAL_ULONG (JITTER_TOP_STACK ());
    ctx.ios_id = -1;
    ios_map (ios_ctx, ioref_callback, &ctx);
    JITTER_PUSH_STACK (PVM_MAKE_INT (ctx.ios_id, 32));
  end
end

# Instruction: iotype
#
# Push the name of the inteface that is implemented of the given IO
# space on the stack, as a string.  The IO space is identified by a
# descriptor, which is a signed integer.
# The given IO space must exist.
#
# Stack: ( INT -- INT STR )

instruction iotype ()
  code
    ios_context ios_ctx = PVM_STATE_BACKING_FIELD (ios_ctx);
    ios io = ios_search_by_id (ios_ctx, PVM_VAL_INT (JITTER_TOP_STACK ()));

    PVM_ASSERT (io != NULL);
    JITTER_PUSH_STACK (pvm_make_string (ios_get_dev_if_name (io)));
  end
end

# Instruction: iohandler
#
# Push the handler of the given IO space on the stack, as a string.  The
# IO space is identified by a descriptor, which is a signed integer.
# The given IO space must exist.
#
# Stack: ( INT -- INT OFF )

instruction iohandler ()
  code
    ios_context ios_ctx = PVM_STATE_BACKING_FIELD (ios_ctx);
    ios io = ios_search_by_id (ios_ctx, PVM_VAL_INT (JITTER_TOP_STACK ()));

    PVM_ASSERT (io != NULL);
    JITTER_PUSH_STACK (pvm_make_string (ios_handler (io)));
  end
end

# Instruction: iogetv
#
# Push 1 on the stack if the IO space on the stack is volatile.
# Push 0 otherwise.
# The given IO space must exist.
#
# Stack: ( INT - INT INT )

instruction iogetv ()
  code
    ios_context ios_ctx = PVM_STATE_BACKING_FIELD (ios_ctx);
    ios io = ios_search_by_id (ios_ctx, PVM_VAL_INT (JITTER_TOP_STACK ()));

    PVM_ASSERT (io != NULL);
    JITTER_PUSH_STACK (pvm_make_int (ios_volatile_p (io), 32));
  end
end

# Instruction: iogetb
#
# Each IO space has a bias associated with it, which by default is 0
# bits.  This bias is applied to the offset given to every read/write
# operation.
#
# This instruction pushes the bias associated to the given IO space to
# the stack, as an offset.
# The given IO space must exist.
#
# Stack: ( INT - INT OFF )

instruction iogetb ()
  code
    pvm_val type, magnitude, unit;
    ios_context ios_ctx = PVM_STATE_BACKING_FIELD (ios_ctx);
    ios io = ios_search_by_id (ios_ctx, PVM_VAL_INT (JITTER_TOP_STACK ()));

    PVM_ASSERT (io != NULL);

    magnitude = PVM_MAKE_ULONG (ios_get_bias (io), 64);
    unit = PVM_MAKE_ULONG (1, 64);
    type = pvm_make_offset_type (pvm_typeof (magnitude), unit, PVM_NULL /* ref_type */);
    JITTER_PUSH_STACK (pvm_make_offset (magnitude, type));
  end
end

# Instruction: iosetb
#
# Each IO space has a bias associated with it, which by default is 0
# bits.  This bias is applied to the offset given to every read/write
# operation.
#
# This instruction sets the bias associated to the given IO space.
# The bias is specified as an offset.
# The given IO space must exist.
#
# Stack: ( OFF INT -- OFF )

instruction iosetb ()
  code
    pvm_val bias = JITTER_UNDER_TOP_STACK();
    pvm_val bias_type = PVM_VAL_OFF_TYPE (bias);
    ios_context ios_ctx = PVM_STATE_BACKING_FIELD (ios_ctx);
    ios io = ios_search_by_id (ios_ctx, PVM_VAL_INT (JITTER_TOP_STACK ()));

    PVM_ASSERT (io != NULL);

    JITTER_DROP_STACK ();
    ios_set_bias (io,
                  (PVM_VAL_INTEGRAL (PVM_VAL_OFF_MAGNITUDE (bias))
                   * PVM_VAL_INTEGRAL (PVM_VAL_TYP_O_UNIT (bias_type))));
  end
end


## Function management instructions

# Instruction: call
#
# Call a closure on the stack, passing the specified arguments.  After
# the execution of the closure, control is transferred to the
# instruction immediately following the call instruction.
#
# Stack: ( ARG1 ... ARGN CLOSURE -- RETVAL )

instruction call ()
  caller
  code
    pvm_val closure = JITTER_TOP_STACK ();

    PVM_ASSERT (PVM_VAL_CLS_ENV (closure) != NULL);
    JITTER_DROP_STACK ();
    PVM_CALL (closure);
  end
end

# Instruction: prolog
#
# Prepare the PVM for the execution of a function.  This instruction
# shall be the target of every `call' instruction and shall be the
# first instruction in every function body.
#
# Stack: ( -- )

instruction prolog ()
  callee
  code
    /* Fill the return stack slot with the return address.  The return
       stack has already been pushesd (with an unspecified value on the
       under top) by the caller. */
    JITTER_UNDER_TOP_RETURNSTACK() = (jitter_uint) JITTER_LINK;
  end
end

# Instruction: return
#
# Return from a function.  A function can have many `return'
# instructions.
#
# Stack: ( -- )

instruction return ()
  returning
  code
    jitter_uint return_address;

    /* Restore the environment of the caller.  Note the cast to
       jitter_uint is to avoid a warning in 32-bit.  */
    PVM_STATE_RUNTIME_FIELD (env)
      = (pvm_env) (jitter_uint) JITTER_TOP_RETURNSTACK ();
    JITTER_DROP_RETURNSTACK();

    return_address = JITTER_TOP_RETURNSTACK();
    JITTER_DROP_RETURNSTACK();

    /* Drop the caller's name.  */
    JITTER_DROP_RETURNSTACK();

    JITTER_RETURN (return_address);
  end
end


## Environment instructions

# Instruction: pushf N
#
# Push a new lexical frame.  If the argument N is bigger than zero, it
# indicates the number of entries in the frame.  If N is 0, it means
# we don't know how many entries will be stored in the frame.
#
# Stack: ( -- )

instruction pushf (?n popf_printer)
  code
    PVM_STATE_RUNTIME_FIELD (env)
       = pvm_env_push_frame (PVM_STATE_RUNTIME_FIELD (env),
                             JITTER_ARGN0);
  end
end

# Instruction: popf N
#
# Pop N lexical frames.
#
# Stack: ( -- )

instruction popf (?n popf_printer)
  code
    jitter_uint i;

    for (i = 0; i < JITTER_ARGU0; ++i)
        PVM_STATE_RUNTIME_FIELD (env)
           = pvm_env_pop_frame (PVM_STATE_RUNTIME_FIELD (env));
  end
end

# Instruction: pushvar BACK, OVER
#
# Retrieve the value of a variable from the lexical environment and
# push it on the stack.  The lexical address of the variable is
# specified as arguments to the instruction.
#
# Stack: ( -- VAL )

instruction pushvar (?n 0, ?n 0 1 2 3 4 5)
  code
    JITTER_PUSH_STACK (pvm_env_lookup (PVM_STATE_RUNTIME_FIELD (env),
                                       (int) JITTER_ARGN0,
                                       (int) JITTER_ARGN1));
  end
end

# Instruction: pushtopvar OVER
#
# Retrieve the value of a variable from the top-level frame of the
# lexical environment and put it on the stack.  The OVER part of the
# lexical address of the variable is specified as an argument to the
# instruction.
#
# If the variable is not found then raise E_INVAL.
#
# Stack: ( -- VAL )

instruction pushtopvar (?n)
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_env topenv = pvm_env_toplevel (PVM_STATE_RUNTIME_FIELD (env));
    pvm_val val = pvm_env_lookup (topenv, 0 /* back */,
                                  (int) JITTER_ARGN0 /* over */);

    if (val == PVM_NULL)
      PVM_RAISE (PVM_E_INVAL, pvm_literal_no_toplevel_var,
                 PVM_E_INVAL_ESTATUS);

    JITTER_PUSH_STACK (val);
  end
end

# Instruction: popvar BACK, OVER
#
# Pop a value from the stack and set it as the value of a variable
# having the lexical address specified in the arguments, in the
# current lexical environment.
#
# Stack: ( VAL -- )

instruction popvar (?n, ?n)
  code
    pvm_env_set_var (PVM_STATE_RUNTIME_FIELD (env),
                     (int) JITTER_ARGN0,
                     (int) JITTER_ARGN1,
                     JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: regvar
#
# Pop a value from the stack and use it as the value for a new
# variable in the current lexical environment.
#
# Stack: ( VAL -- )

instruction regvar ()
  code
    pvm_env_register (PVM_STATE_RUNTIME_FIELD (env),
                      JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: duc
#
# Make a copy of the closure at the top of the stack, and
# replace it.
#
# Stack: ( CLS -- CLS )

instruction duc ()
  code
    pvm_val cls = JITTER_TOP_STACK ();
    pvm_val new_cls = pvm_make_cls (PVM_VAL_CLS_PROGRAM (cls),
                                    PVM_VAL_CLS_NAME (cls));

    JITTER_DROP_STACK ();
    JITTER_PUSH_STACK (new_cls);
  end
end

# Instruction: pec
#
# Put the current lexical environment to the closure at the top of the
# stack.
#
# Stack: ( CLS -- CLS )

instruction pec ()
  code
    pvm_val cls = JITTER_TOP_STACK ();

    PVM_VAL_CLS_ENV (cls) = PVM_STATE_RUNTIME_FIELD (env);
  end
end


## Printing Instructions

# In the following instructions the meaning of the argument BASE is
# the following:
#
# 2 - print the number in binary.
# 8 - print the number in octal.
# 16 - print the number in hexadecimal.
# Any other value - print the number in decimal.

# Instruction: printi BITS
#
# Given a signed integer and a numeration base in the stack, print the
# integer to the terminal.
#
# Stack: ( INT INT -- )

instruction printi (?n popf_printer)
  non-relocatable
  code
    int base = PVM_VAL_INT (JITTER_TOP_STACK ());
    PVM_PRINTI (INT, int32_t, 1 /* signed_p */, base);
  end
end

# Instruction: printiu BITS
#
# Given an unsigned integer and a numeration base in the stack, print
# the integer to the terminal.
#
# Stack: ( UINT INT -- )

instruction printiu (?n popf_printer)
  non-relocatable
  code
    int base = PVM_VAL_INT (JITTER_TOP_STACK ());
    PVM_PRINTI (UINT, uint32_t, 0 /* signed_p */, base);
  end
end

# Instruction: printl BITS
#
# Given a long and a numeration base in the stack, print the integer
# to the terminal.
#
# Stack: ( LONG INT -- )

instruction printl (?n popf_printer)
  non-relocatable
  code
    int base = PVM_VAL_INT (JITTER_TOP_STACK ());
    PVM_PRINTL (LONG, int64_t, 1 /* signed_p */, base);
  end
end

# Instruction: printlu BITS
#
# Given an unsigned long and a numeration base in the stack, print the
# integer to the terminal.
#
# Stack: ( ULONG INT -- )

instruction printlu (?n popf_printer)
  non-relocatable
  code
   int base = PVM_VAL_INT (JITTER_TOP_STACK ());
   PVM_PRINTL (ULONG, uint64_t, 0 /* signed_p */, base);
  end
end

# Instruction: prints
#
# Print the string at the top of the stack.
#
# Stack: ( STR -- )

instruction prints ()
  non-relocatable
  code
    pvm_print_string (JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: beghl
#
# Begin an hyperlink, using the URL and ID on the stack.
#
# Stack: ( STR STR -- )

instruction beghl ()
  non-relocatable
  code
    char *url = PVM_VAL_STR (JITTER_UNDER_TOP_STACK ());
    char *id = PVM_VAL_STR (JITTER_TOP_STACK ());

    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    pk_term_hyperlink (url, id);
  end
end

# Instruction: endhl
#
# End the current hyperlink.
#
# If no hyperlink is currently being generated, this instruction
# pushes int<32>1 in the stack, otherwise it pushes int<32>0.
#
# Stack: ( -- )
# Exceptions: PVM_E_GENERIC

instruction endhl ()
  non-relocatable
  code
    JITTER_PUSH_STACK (pvm_make_int (!!pk_term_end_hyperlink (), 32));
  end
end

# Instruction: begsc
#
# Begin the styling class whose name is found on the stack.  This
# class will be in effect in subsequent print operations until it is
# explicitly ended by a `endsc' instruction.
#
# Stack: ( STR -- )

instruction begsc ()
  non-relocatable
  code
    pk_term_class (PVM_VAL_STR (JITTER_TOP_STACK ()));
    JITTER_DROP_STACK ();
  end
end

# Instruction: endsc
#
# End the styling class whose name is found on the stack.  This class
# should have been previously began by a `begsc' instruction.
#
# If the specified class is not currently being used, this function
# pushes int<32>0 on the stack.  Otherwise it pushes int<32>1.
#
# Stack: ( STR -- INT )

instruction endsc ()
  non-relocatable
  code
    pvm_val str = JITTER_TOP_STACK ();

    JITTER_DROP_STACK ();
    JITTER_PUSH_STACK (pvm_make_int (!!pk_term_end_class (PVM_VAL_STR (str)), 32));
  end
end


## Format Instructions

# In the following instructions the meaning of the argument BASE is
# the following:
#
# 2 - format the number in binary.
# 8 - format the number in octal.
# 16 - format the number in hexadecimal.
# Any other value - format the number in decimal.

# Instruction: formati BITS
#
# Given a signed integer and a numeration base in the stack, push the
# string representation to the stack.
#
# Stack: ( INT INT -- STR )

instruction formati (?n)
  non-relocatable
  code
    int base = PVM_VAL_INT (JITTER_TOP_STACK ());
    char res[32 + 2 /* suffix */ + 1 /* nul */];

    PVM_FORMATI (res, sizeof (res), INT, int32_t, 1 /* signed_p */, base);
  end
end

# Instruction: formatiu BITS
#
# Given an unsigned integer and a numeration base in the stack, push the
# string representation to the stack.
#
# Stack: ( UINT INT -- STR )

instruction formatiu (?n)
  non-relocatable
  code
    int base = PVM_VAL_INT (JITTER_TOP_STACK ());
    char res[32 + 2 /* suffix */ + 1 /* nul */];

    PVM_FORMATI (res, sizeof (res), UINT, uint32_t, 0 /* signed_p */, base);
  end
end

# Instruction: formatl BITS
#
# Given a long and a numeration base in the stack, push the string
# representation to the stack.
#
# Stack: ( LONG INT -- STR )

instruction formatl (?n)
  non-relocatable
  code
    int base = PVM_VAL_INT (JITTER_TOP_STACK ());
    char res[64 + 2 /* suffix */ + 1 /* nul */];

    PVM_FORMATL (res, sizeof (res), LONG, int64_t, 1 /* signed_p */, base);
  end
end

# Instruction: formatlu BITS
#
# Given an unsigned long and a numeration base in the stack, push the
# string representation to the stack.
#
# Stack: ( ULONG INT -- STR )

instruction formatlu (?n)
  non-relocatable
  code
    int base = PVM_VAL_INT (JITTER_TOP_STACK ());
    char res[64 + 2 /* suffix */ + 1 /* nul */];

    PVM_FORMATL (res, sizeof (res), ULONG, uint64_t, 0 /* signed_p */, base);
  end
end

# Instruction: formatf32 STYLE
#
# Given a UINT (that should be interpreted as a 32-bit floating-point
# number), and a UINT (as the conversion precision), push the string
# representation of the floating-point number with specified precision.
#
# The formatting style is given by a literal parameters.
# Style 0 corresponds to %f-tag which converts the number in the style
# [-]ddd.ddd where the number of digits after the decimal-point character
# is the equal to the precision.
# Style 1 corresponds to %e-tag which converts the number in the style
# [-]d.ddde+-dd (so called scientific notation).  Precision for this
# style also means the number of digits after the decimal-point character.
# Style 2 corresponds to %g-tag which choose either %f style or %e based
# on the length of the repsentation.  For this style, precision specify
# the number of significant numbers.
#
# Stack: ( UINT UINT -- STR )

instruction formatf32 (?n 0 1 2)
  branching # because of PVM_RAISE_DIRECT
  code
    char *result = NULL;
    uint32_t num = PVM_VAL_UINT (JITTER_UNDER_TOP_STACK ());
    unsigned style = (unsigned)JITTER_ARGN0;
    uint32_t precision = PVM_VAL_UINT (JITTER_TOP_STACK ());

    JITTER_DROP_STACK ();
    PVM_FORMATF (result, num, precision, style, float);
    JITTER_TOP_STACK () = pvm_make_string (result);
    pvm_free (result);
  end
end

# Instruction: formatf64 STYLE
#
# Given a ULONG (that should be interpreted as a 64-bit floating-point
# number), and a UINT (as the conversion precision), push the string
# representation of the floating-point number with specified precision.
# The formatting style is given by a literal parameters.
#
# The formatting style is given by a literal parameters.
# Style 0 corresponds to %f-tag which converts the number in the style
# [-]ddd.ddd where the number of digits after the decimal-point character
# is the equal to the precision.
# Style 1 corresponds to %e-tag which converts the number in the style
# [-]d.ddde+-dd (so called scientific notation).  Precision for this
# style also means the number of digits after the decimal-point character.
# Style 2 corresponds to %g-tag which choose either %f style or %e based
# on the length of the repsentation.  For this style, precision specify
# the number of significant numbers.
#
# Stack: ( ULONG UINT -- STR )

instruction formatf64 (?n 0 1 2)
  branching # because of PVM_RAISE_DIRECT
  code
    char *result = NULL;
    uint64_t num = PVM_VAL_ULONG (JITTER_UNDER_TOP_STACK ());
    unsigned style = (unsigned)JITTER_ARGN0;
    uint32_t precision = PVM_VAL_UINT (JITTER_TOP_STACK ());

    JITTER_DROP_STACK ();
    PVM_FORMATF (result, num, precision, style, double);
    JITTER_TOP_STACK () = pvm_make_string (result);
    pvm_free (result);
  end
end


## Floating-point conversion instructions

# Instruction: stof
#
# Given a string containing only a floating-point number, push the
# corresponding 32-bit floating-point number to the stack,
# represented as a UINT.  On conversion failure, push NULL.
#
# Note that leading (not trailing) whitespaces will be ignored.
#
# Stack: ( STR -- UINT )

instruction stof ()
  code
    union
    {
      float f32;
      uint32_t u32;
    } u;

    if (pvm_stof (PVM_VAL_STR (JITTER_TOP_STACK()), &u.f32) == 0)
      JITTER_TOP_STACK () = PVM_MAKE_UINT (u.u32, 32);
    else
      JITTER_TOP_STACK () = PVM_NULL;
  end
end

# Instruction: stod
#
# Given a string containing only a floating-point number, push the
# corresponding 64-bit floating-point number to the stack,
# represented as a ULONG.  On conversion failure, push NULL.
#
# Note that leading (not trailing) whitespaces will be ignored.
#
# Stack: ( STR -- ULONG )

instruction stod ()
  code
    union
    {
      double f64;
      uint64_t u64;
    } u;

    if (pvm_stod (PVM_VAL_STR (JITTER_TOP_STACK()), &u.f64) == 0)
      JITTER_TOP_STACK () = PVM_MAKE_ULONG (u.u64, 64);
    else
      JITTER_TOP_STACK () = PVM_NULL;
  end
end


## Main stack manipulation instructions

# Instruction: push VAL
#
# Push the value given as an argument to the main stack.
#
# Stack: ( -- VAL )

instruction push (?nl pvm_literal_printer)
  code
    pvm_val k = JITTER_ARGN0;
    JITTER_PUSH_STACK(k);
  end
end

# Instruction: drop
#
# Pop the value at the top of the main stack, and discard it.
#
# Stack: ( VAL -- )

instruction drop ()
  code
    JITTER_DROP_STACK();
  end
end

# Instruction: drop2
#
# Pop the two values at the top of the main stack, and discard them.
#
# Stack: ( VAL VAL -- )

instruction drop2 ()
  code
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
  end
end

# Instruction: drop3
#
# Pop the three values at the top of the main stack, and discard them.
#
# Stack: ( VAL VAL VAL -- )

instruction drop3 ()
  code
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
  end
end

# Instruction: drop4
#
# Pop the four values at the top of the stack, and discard them.
#
# Stack: ( VAL VAL VAL VAL -- )

instruction drop4 ()
  code
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
    JITTER_DROP_STACK();
  end
end

# Instruction: swap
#
# Exchange the two elements at the top of the stack.
#
# Stack: ( A B -- B A)

instruction swap ()
  code
    pvm_val tmp = JITTER_UNDER_TOP_STACK ();
    JITTER_UNDER_TOP_STACK () = JITTER_TOP_STACK ();
    JITTER_TOP_STACK () = tmp;
  end
end

# Instruction: nip
#
# Discard the element at the under top of the main stack.
#
# Stack: ( A B -- B )

instruction nip ()
  code
    JITTER_NIP_STACK();
  end
end

# Instruction: nip2
#
# Discard the two elements at the under top of the main stack.
#
# Stack: ( A B C -- C )

instruction nip2 ()
  code
    JITTER_NIP_STACK ();
    JITTER_NIP_STACK ();
  end
end

# Instruction: nip3
#
# Discard the three elements at the under top of the main stack.
#
# Stack: ( A B C D -- D )

instruction nip3 ()
  code
    JITTER_NIP_STACK ();
    JITTER_NIP_STACK ();
    JITTER_NIP_STACK ();
  end
end

# Instruction: dup
#
# Push a copy of the element at the top of the main stack.
#
# Stack: ( A -- A A )

instruction dup ()
  code
    JITTER_DUP_STACK ();
  end
end

# Instruction: over
#
# Push a copy of the element at the under top of the main stack.
#
# Stack: ( A B -- A B A )

instruction over ()
  code
    JITTER_PUSH_STACK (JITTER_UNDER_TOP_STACK ());
  end
end

# Instruction: oover
#
# Push a copy of the element under the under top of the main stack.
#
# Stack: ( A B C -- A B C A )

instruction oover ()
  code
    pvm_val c = JITTER_TOP_STACK ();
    pvm_val a;
    JITTER_DROP_STACK ();
    a = JITTER_UNDER_TOP_STACK ();
    JITTER_PUSH_STACK (c);
    JITTER_PUSH_STACK (a);
  end
end

# Instruction: rot
#
# Rotate the three elements at the top of the main stack, clock-wise.
#
# Stack: ( A B C -- B C A )

instruction rot ()
  code
    JITTER_ROT_STACK ();
  end
end

# Instruction: nrot
#
# Rotate the three elements at the top of the stack, counter
# clock-wise.
#
# Stack: ( A B C -- C A B )

instruction nrot ()
  code
    JITTER_MROT_STACK ();
  end
end

# Instruction: tuck
#
# Tuck a copy of the element at the top of the stack down two
# positions.
#
# Stack: ( A B -- B A B )

instruction tuck ()
  code
    JITTER_TUCK_STACK ();
  end
end

# Instruction: quake
#
# Swap the two elements at the under top of the stack.
#
# Stack: ( A B C - B A C )

instruction quake ()
  code
    JITTER_QUAKE_STACK ();
  end
end

# Instruction: revn N
#
# Reverse the N elements at the top of the stack.
#
# Stack: ( VAL... -- VAL... )

instruction revn (?n 3 4 popf_printer)
  code
    JITTER_REVERSE_STACK (JITTER_ARGU0);
  end
end

# Instruction: push32 HI LO
#
# Push the value passed as two arguments on the stack.
# This instruction is a workaround to a limitation of Jitter.
#
# Stack: ( -- VAL )

instruction push32 (?nl pvm_literal_printer_hi, ?nl pvm_literal_printer_lo)
  code
    pvm_val k = ((pvm_val) JITTER_ARGN0 << 32) | JITTER_ARGN1;
    JITTER_PUSH_STACK (k);
  end
end


## Registers manipulation instructions

# Instruction: pushr REGNO
#
# Push the contents of the register REGNO on the stack.
#
# Stack: ( -- VAL )

instruction pushr (?R)
  code
    JITTER_PUSH_STACK (JITTER_ARG0);
  end
end

# Instruction: popr REGNO
#
# Pop the element at the top of the stack and put it in the
# register REGNO.
#
# Stack: ( VAL -- )

instruction popr (!R)
  code
    JITTER_ARG0 = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();
  end
end

# Instruction: setr REGNO
#
# Set the element at the top of the stack to the value of the
# register REGNO.
#
# Stack: ( -- )

instruction setr (!R)
  code
    JITTER_ARG0 = JITTER_TOP_STACK();
  end
end


## Return stack manipulation instructions

# Instruction: saver REGNO
#
# Push the contents of the register REGNO to the return stack.
#
# Stack: ( -- )
# ReturnStack: ( -- VAL )

instruction saver (?R)
  code
    JITTER_PUSH_RETURNSTACK (JITTER_ARG0);
  end
end

# Instruction: restorer REGNO
#
# Pop the element at the top of the return stack and put it in the
# register REGNO.
#
# Stack: ( -- )
# ReturnStack: ( VAL -- )

instruction restorer (!R)
  code
    JITTER_ARG0 = JITTER_TOP_RETURNSTACK ();
    JITTER_DROP_RETURNSTACK ();
  end
end

# Instruction: tor
#
# Pop an element from the stack and push it in the return stack.
#
# Stack: ( VAL -- )
# ReturnStack: ( -- VAL )

instruction tor ()
  code
    JITTER_PUSH_RETURNSTACK (JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: fromr
#
# Pop an element from the return stack and push it on the stack.
#
# Stack: ( -- VAL)
# ReturnStack: ( VAL -- )

instruction fromr ()
  code
    JITTER_PUSH_STACK (JITTER_TOP_RETURNSTACK ());
    JITTER_DROP_RETURNSTACK ();
  end
end

# Instruction: atr
#
# Push a copy of the element at the top of the return stack into the
# stack.
#
# Stack: ( -- VAL )

instruction atr ()
  code
    JITTER_PUSH_STACK (JITTER_TOP_RETURNSTACK ());
  end
end


## Integer overflow checking instructions.

# The following instructions check for overflow conditions
# in signed integer operations.

# Instruction: addiof
#
# Push 1 on the stack if adding the given two signed integer
# values would overflow.  Push 0 on the stack otherwise.
#
# Stack: ( INT INT -- INT INT INT )

instruction addiof ()
  code
    int32_t a = PVM_VAL_INT (JITTER_UNDER_TOP_STACK ());
    int32_t b = PVM_VAL_INT (JITTER_TOP_STACK ());
    int size = PVM_VAL_INT_SIZE (JITTER_TOP_STACK ());
    int64_t a64 = ((uint64_t)(int64_t) a) << (64 - size);
    int64_t b64 = ((uint64_t)(int64_t) b) << (64 - size);

    JITTER_PUSH_STACK (pvm_make_int (INT_ADD_OVERFLOW (a64, b64),32));
  end
end

# Instruction: addlof
#
# Push 1 on the stack if adding the given two signed long
# values would overflow.  Push 0 on the stack otherwise.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction addlof ()
  code
    int64_t a = PVM_VAL_LONG (JITTER_UNDER_TOP_STACK ());
    int64_t b = PVM_VAL_LONG (JITTER_TOP_STACK ());
    int size = PVM_VAL_LONG_SIZE (JITTER_TOP_STACK ());
    int64_t a64 = ((uint64_t)(int64_t) a) << (64 - size);
    int64_t b64 = ((uint64_t)(int64_t) b) << (64 - size);

    JITTER_PUSH_STACK (pvm_make_int (INT_ADD_OVERFLOW (a64, b64),32));
  end
end

# Instruction: subiof
#
# Push 1 on the stack if subtracting the given two signed integer
# values would overflow.  Push 0 on the stack otherwise.
#
# Stack: ( INT INT -- INT INT INT )

instruction subiof ()
  code
    int32_t a = PVM_VAL_INT (JITTER_UNDER_TOP_STACK ());
    int32_t b = PVM_VAL_INT (JITTER_TOP_STACK ());
    int size = PVM_VAL_INT_SIZE (JITTER_TOP_STACK ());
    int64_t a64 = ((uint64_t)(int64_t) a) << (64 - size);
    int64_t b64 = ((uint64_t)(int64_t) b) << (64 - size);

    JITTER_PUSH_STACK (pvm_make_int (INT_SUBTRACT_OVERFLOW (a64, b64),32));
  end
end

# Instruction: sublof
#
# Push 1 on the stack if subtracting the given two signed long
# values would overflow.  Push 0 on the stack otherwise.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction sublof ()
  code
    int64_t a = PVM_VAL_LONG (JITTER_UNDER_TOP_STACK ());
    int64_t b = PVM_VAL_LONG (JITTER_TOP_STACK ());
    int size = PVM_VAL_LONG_SIZE (JITTER_TOP_STACK ());
    int64_t a64 = ((uint64_t)(int64_t) a) << (64 - size);
    int64_t b64 = ((uint64_t)(int64_t) b) << (64 - size);

    JITTER_PUSH_STACK (pvm_make_int (INT_SUBTRACT_OVERFLOW (a64, b64), 32));
  end
end

# Instruction: muliof
#
# Push 1 on the stack if multiplying the given two signed integer
# values would overflow.  Push 0 on the stack otherwise.
#
# Stack: ( INT INT -- INT INT INT )

instruction muliof ()
  code
    int32_t a = PVM_VAL_INT (JITTER_UNDER_TOP_STACK ());
    int32_t b = PVM_VAL_INT (JITTER_TOP_STACK ());
    int size = PVM_VAL_INT_SIZE (JITTER_TOP_STACK ());
    int64_t a64 = ((uint64_t)(int64_t) a) << (64 - size);

    JITTER_PUSH_STACK (pvm_make_int (INT_MULTIPLY_OVERFLOW (a64, b),32));
  end
end

# Instruction: mullof
#
# Push 1 on the stack if multiplying the given two signed long
# values would overflow.  Push 0 on the stack otherwise.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction mullof ()
  code
    int64_t a = PVM_VAL_LONG (JITTER_UNDER_TOP_STACK ());
    int64_t b = PVM_VAL_LONG (JITTER_TOP_STACK ());
    int size = PVM_VAL_LONG_SIZE (JITTER_TOP_STACK ());
    int64_t a64 = ((uint64_t)(int64_t) a) << (64 - size);

    JITTER_PUSH_STACK (pvm_make_int (INT_MULTIPLY_OVERFLOW (a64, b), 32));
  end
end

# Instruction: diviof
#
# Push 1 on the stack if dividing the given two signed integer
# values would overflow.  Push 0 on the stack otherwise.
#
# Stack: ( INT INT -- INT INT INT )

instruction diviof ()
  code
    int32_t a = PVM_VAL_INT (JITTER_UNDER_TOP_STACK ());
    int32_t b = PVM_VAL_INT (JITTER_TOP_STACK ());
    int size = PVM_VAL_INT_SIZE (JITTER_TOP_STACK ());
    int64_t a64 = ((uint64_t)(int64_t) a) << (64 - size);

    JITTER_PUSH_STACK (pvm_make_int (INT_DIVIDE_OVERFLOW (a64, b),32));
  end
end

# Instruction: divlof
#
# Push 1 on the stack if dividing the given two signed long
# values would overflow.  Push 0 on the stack otherwise.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction divlof ()
  code
    int64_t a = PVM_VAL_LONG (JITTER_UNDER_TOP_STACK ());
    int64_t b = PVM_VAL_LONG (JITTER_TOP_STACK ());
    int size = PVM_VAL_LONG_SIZE (JITTER_TOP_STACK ());
    int64_t a64 = ((uint64_t)(int64_t) a) << (64 - size);

    JITTER_PUSH_STACK (pvm_make_int (INT_DIVIDE_OVERFLOW (a64, b), 32));
  end
end

# Instruction: modiof
#
# Push 1 on the stack if calculating the remainder of the given two
# signed integer values would overflow.  Push 0 on the stack otherwise.
#
# Stack: ( INT INT -- INT INT INT )

instruction modiof ()
  code
    int32_t a = PVM_VAL_INT (JITTER_UNDER_TOP_STACK ());
    int32_t b = PVM_VAL_INT (JITTER_TOP_STACK ());
    int size = PVM_VAL_INT_SIZE (JITTER_TOP_STACK ());
    int64_t a64 = ((uint64_t)(int64_t) a) << (64 - size);

    JITTER_PUSH_STACK (pvm_make_int (INT_DIVIDE_OVERFLOW (a64, b),32));
  end
end

# Instruction: modlof
#
# Push 1 on the stack if calculating the remainder of the given two signed long
# values would overflow.  Push 0 on the stack otherwise.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction modlof ()
  code
    int64_t a = PVM_VAL_LONG (JITTER_UNDER_TOP_STACK ());
    int64_t b = PVM_VAL_LONG (JITTER_TOP_STACK ());
    int size = PVM_VAL_LONG_SIZE (JITTER_TOP_STACK ());
    int64_t a64 = ((uint64_t)(int64_t) a) << (64 - size);

    JITTER_PUSH_STACK (pvm_make_int (INT_DIVIDE_OVERFLOW (a64, b), 32));
  end
end

# Instruction: negiof
#
# Push 1 on the stack if calculating the negation of the given
# signed integer value would overflow.  Push 0 on the stack otherwise.
#
# Stack: ( INT -- INT INT )

instruction negiof ()
  code
    int32_t a = PVM_VAL_INT (JITTER_TOP_STACK ());
    int size = PVM_VAL_INT_SIZE (JITTER_TOP_STACK ());
    int64_t a64 = ((uint64_t)(int64_t) a) << (64 - size);

    JITTER_PUSH_STACK (pvm_make_int (INT_NEGATE_OVERFLOW (a64), 32));
  end
end

# Instruction: neglof
#
# Push 1 on the stack if calculating the negation of the given
# value would overflow.  Push 0 on the stack otherwise.
#
# Stack: ( LONG -- LONG INT )

instruction neglof ()
  code
    int64_t a = PVM_VAL_LONG (JITTER_TOP_STACK ());
    int size = PVM_VAL_LONG_SIZE (JITTER_TOP_STACK ());
    int64_t a64 = ((uint64_t)(int64_t) a) << (64 - size);

    JITTER_PUSH_STACK (pvm_make_int (INT_NEGATE_OVERFLOW (a64), 32));
  end
end

# Instruction: powiof
#
# Push 1 on the stack if calculating the power of the first value
# by the second would overflow.  Push 0 on the stack otherwise.
#
# Stack: ( INT INT -- INT INT INT )

instruction powiof ()
  code
    int overflow_p;
    uint32_t i;
    uint64_t size = PVM_VAL_INT_SIZE (JITTER_UNDER_TOP_STACK ());
    int32_t a = PVM_VAL_INT (JITTER_UNDER_TOP_STACK ());
    uint32_t b = PVM_VAL_UINT (JITTER_TOP_STACK ());
    int64_t res64 = ((uint64_t) 1) << (64 - size);

    overflow_p = 0;
    for (i = 0; i < b; ++i)
      {
       if (INT_MULTIPLY_OVERFLOW (res64, a))
         {
           overflow_p = 1;
           break;
         }

       res64 *= a;
      }

    JITTER_PUSH_STACK (pvm_make_int (overflow_p, 32));
  end
end

# Instruction: powlof
#
# Push 1 on the stack if calculating the power of the first value
# by the second would overflow.  Push 0 on the stack otherwise.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction powlof ()
  code
    int overflow_p;
    uint64_t i;
    uint64_t size = PVM_VAL_LONG_SIZE (JITTER_UNDER_TOP_STACK ());
    int64_t a = PVM_VAL_LONG (JITTER_UNDER_TOP_STACK ());
    uint32_t b = PVM_VAL_UINT (JITTER_TOP_STACK ());
    int64_t res64 = ((uint64_t) 1) << (64 - size);

    overflow_p = 0;
    for (i = 0; i < b; ++i)
      {
       if (INT_MULTIPLY_OVERFLOW (res64, a))
         {
           overflow_p = 1;
           break;
         }

       res64 *= a;
      }

    JITTER_PUSH_STACK (pvm_make_int (overflow_p, 32));
  end
end


## Arithmetic instructions

# The following instructions assume that both operands have the same
# size in bits.

# Instruction: addi
#
# Push the result of adding the two integers at the top of the stack.
# If the operation would result in overflow, raise PVM_E_OVERFLOW.
#
# Note that this instruction does NOT check for signed overflow, and
# in case it occurs, the result contents are UB.
#
# Stack: ( INT INT -- INT INT INT )
# Exceptions: PVM_E_OVERFLOW

instruction addi ()
  code
    PVM_BINOP (INT, INT, INT, +);
  end
end

# Instruction: addiu
#
# Push the result of adding the two unsigned integers at the top of
# the stack.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction addiu ()
  code
    PVM_BINOP (UINT, UINT, UINT, +);
  end
end

# Instruction: addl
#
# Push the result of adding the two longs at the top of the stack.
# If the operation would result in overflow, raise PVM_E_OVERFLOW.
#
# Note that this instruction does NOT check for signed overflow, and
# in case it occurs, the result contents are UB.
#
# Stack: ( LONG LONG -- LONG LONG LONG )
# Exceptions: PVM_E_OVERFLOW

instruction addl ()
  code
    PVM_BINOP (LONG, LONG, LONG, +);
  end
end

# Instruction: addlu
#
# Push the result of adding the two unsigned longs at the top of
# the stack.
#
# Stack: ( ULONG ULONG -- ULONG ULONG ULONG )

instruction addlu ()
  code
    PVM_BINOP (ULONG, ULONG, ULONG, +);
  end
end

# Instruction: subi
#
# Push the result of subtracting the two integers at the top of
# the stack.
#
# Note that this instruction does NOT check for signed overflow, and
# in case it occurs, the result contents are UB.
#
# Stack: ( INT INT -- INT INT INT )

instruction subi ()
  code
    PVM_BINOP (INT, INT, INT, -);
  end
end

# Instruction: subiu
#
# Push the result of subtracting the two unsigned integers at the
# top of the stack.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction subiu ()
  code
    PVM_BINOP (UINT, UINT, UINT, -);
  end
end

# Instruction: subl
#
# Push the result of subtracting the two longs at the top
# of the stack.
#
# Note that this instruction does NOT check for signed overflow, and
# in case it occurs, the result contents are UB.
#
# Stack: ( LONG LONG -- LONG LONG LONG )

instruction subl ()
  code
    PVM_BINOP (LONG, LONG, LONG, -);
  end
end

# Instruction: sublu
#
# Push the result of subtracting the two unsigned longs at the
# top of the stack.
#
# Stack: ( ULONG ULONG -- ULONG ULONG ULONG )

instruction sublu ()
  code
    PVM_BINOP (ULONG, ULONG, ULONG, -);
  end
end

# Instruction: muli
#
# Push the result of multiplying the two integers at the top of the
# stack.
#
# Note that this instruction does NOT check for signed overflow, and
# in case it occurs, the result contents are UB.
#
# Stack: ( INT INT -- INT INT INT )

instruction muli ()
  code
    PVM_BINOP (INT, INT, INT, *);
  end
end

# Instruction: muliu
#
# Push the result of multiplying the two unsigned integers at the
# top of the stack.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction muliu ()
  code
    PVM_BINOP (UINT, UINT, UINT, *);
  end
end

# Instruction: mull
#
# Push the result of multiplying the two longs at the top of the
# stack.
#
# Note that this instruction does NOT check for signed overflow, and
# in case it occurs, the result contents are UB.
#
# Stack: ( LONG LONG -- LONG LONG LONG )

instruction mull ()
  code
    PVM_BINOP (LONG, LONG, LONG, *);
  end
end

# Instruction: mullu
#
# Push the result of multiplying the two unsigned longs at the top
# of the stack.
#
# Stack: ( ULONG ULONG -- ULONG ULONG ULONG )

instruction mullu ()
  # branching # because of PVM_RAISE_DIRECT
  code
    PVM_BINOP (ULONG, ULONG, ULONG, *);
  end
end

# Instruction: divi
#
# Push the result of the integer division of the two integers at the
# top of the stack.  If the denominator is zero, raise
# PVM_E_DIV_BY_ZERO.
#
# Note that this instruction does NOT check for signed overflow, and
# in case it occurs, the result contents are UB.
#
# Likewise, this instruction does NOT check for division by zero, so
# if it is attempted, the poke process will be aborted.
#
# Stack: ( INT INT -- INT INT INT )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction divi ()
  code
    PVM_BINOP (INT, INT, INT, /);
  end
end

# Instruction: diviu
#
# Push the result of the integer division of the two unsigned integers
# at the top of the stack.  If the denominator is zero, raise
# PVM_E_DIV_BY_ZERO.
#
# This instruction does NOT check for division by zero, so
# if it is attempted, the poke process will be aborted.
#
# Stack: ( UINT UINT -- UINT UINT UINT )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction diviu ()
  code
    PVM_BINOP (UINT, UINT, UINT, /);
  end
end

# Instruction: divl
#
# Push the result of the integer division of the two longs at the top
# of the stack.  If the denominator is zero, raise PVM_E_DIV_BY_ZERO.
#
# Note that this instruction does NOT check for signed overflow, and
# in case it occurs, the result contents are UB.
#
# Likewise, this instruction does NOT check for division by zero, so
# if it is attempted, the poke process will be aborted.
#
# Stack: ( LONG LONG -- LONG LONG LONG )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction divl ()
  code
    PVM_BINOP (LONG, LONG, LONG, /);
  end
end

# Instruction: divlu
#
# Push the result of the integer division of the two unsigned
# longs at the top of the stack.  If the denominator is zero,
# raise PVM_E_DIV_BY_ZERO.
#
# This instruction does NOT check for division by zero, so
# if it is attempted, the poke process will be aborted.
#
# Stack: ( ULONG ULONG -- ULONG ULONG ULONG )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction divlu ()
  code
    PVM_BINOP (ULONG, ULONG, ULONG, /);
  end
end

# Instruction: modi
#
# Push the result of the modulus of the two integers at the top of the
# stack.  If the denominator is zero, raise PVM_E_DIV_BY_ZERO.
#
# Note that this instruction does NOT check for signed overflow, and
# in case it occurs, the result contents are UB.
#
# Likewise, this instruction does NOT check for division by zero, so
# if it is attempted, the poke process will be aborted.
#
# Stack: ( INT INT -- INT INT INT )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction modi ()
  code
    PVM_BINOP (INT, INT, INT, %);
  end
end

# Instruction: modiu
#
# Push the result of the modulus of the two unsigned integers at the
# top of the stack.  If the denominator is zero, raise
# PVM_E_DIV_BY_ZERO.
#
# This instruction does NOT check for division by zero, so
# if it is attempted, the poke process will be aborted.
#
# Stack: ( UINT UINT -- UINT UINT UINT )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction modiu ()
  code
    PVM_BINOP (UINT, UINT, UINT, %);
  end
end

# Instruction: modl
#
# Push the result of the modulus of the two longs at the top of the
# stack.  If the denominator is zero, raise PVM_E_DIV_BY_ZERO.
#
# Note that this instruction does NOT check for signed overflow, and
# in case it occurs, the result contents are UB.
#
# This instruction does NOT check for division by zero, so
# if it is attempted, the poke process will be aborted.
#
# Stack: ( LONG LONG -- LONG LONG LONG )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction modl ()
  code
    PVM_BINOP (LONG, LONG, LONG, %);
  end
end

# Instruction: modlu
#
# Push the result of the modulus of the two unsigned longs at the top
# of the stack.  If the denominator is zero, raise PVM_E_DIV_BY_ZERO.
#
# This instruction does NOT check for division by zero, so
# if it is attempted, the poke process will be aborted.
#
# Stack: ( ULONG ULONG -- ULONG ULONG ULONG )
# Exceptions: PVM_E_DIV_BY_ZERO

instruction modlu ()
  code
    PVM_BINOP (ULONG, ULONG, ULONG, %);
  end
end

# Instruction: negi
#
# Push the result of the negation of the integer at the top of the
# stack.
#
# Note that this instruction does NOT check for signed overflow, and
# in case it occurs, the result contents are UB.
#
# Stack: ( INT -- INT INT )

instruction negi ()
  code
    PVM_UNOP (INT, INT, int, -);
  end
end

# Instruction: negiu
#
# Push the result of the negation of the unsigned integer at the
# top of the stack.
#
# Stack: ( UINT -- UINT UINT UINT )

instruction negiu ()
  code
    PVM_UNOP (UINT, UINT, uint, -);
  end
end

# Instruction: negl
#
# Push the result of the negation of the long at the top of the
# stack.
#
# Note that this instruction does NOT check for signed overflow, and
# in case it occurs, the result contents are UB.
#
# Stack: ( LONG -- LONG LONG )

instruction negl ()
  code
    PVM_UNOP (LONG, LONG, long, -);
  end
end

# Instruction: neglu
#
# Push the result of the negation of the unsigned long at the top of
# the stack.
#
# Stack: ( ULONG -- ULONG ULONG )

instruction neglu ()
  code
    PVM_UNOP (ULONG, ULONG, ulong, -);
  end
end

# Instruction: powi
#
# Perform the exponentiation of the integer at the under top of the
# stack.  The exponent is the unsigned integer at the top of the
# stack.  If the exponent is 0, the result is 1.
#
# Note that this instruction does NOT check for signed overflow, and
# in case it occurs, the result contents are UB.
#
# Stack: ( INT UINT -- INT UINT INT )

instruction powi ()
  code
    PVM_POWOP (INT,int32_t,int);
  end
end

# Instruction: powiu
#
# Perform the exponentiation of the unsigned integer at the under top
# of the stack.  The exponent is the unsigned integer at the top of
# the stack.  If the exponent is 0, the result is 1.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction powiu ()
  code
    PVM_POWOP (UINT,uint64_t,uint);
  end
end

# Instruction: powl
#
# Perform the exponentiation of the long at the under top of the
# stack.  The exponent is the unsigned integer at the top of the
# stack.  If the exponent is 0, the result is 1.
#
# Note that this instruction does NOT check for signed overflow, and
# in case it occurs, the result contents are UB.
#
# Stack: ( LONG UINT -- LONG UINT LONG )

instruction powl ()
  code
    PVM_POWOP (LONG,int64_t,long);
  end
end

# Instruction: powlu
#
# Perform the exponentiation of the unsigned long at the under top of
# the stack.  The exponent is the unsigned integer at the top of the
# stack.  If the exponent is 0, the result is 1.
#
# Stack: ( ULONG UINT -- ULONG UINT ULONG )

instruction powlu ()
  code
    PVM_POWOP (ULONG,uint64_t,ulong);
  end
end


## Relational instructions

# Instruction: eqi
#
# Push 1 on the stack if the two integers at the top of the stack are
# equal.  Otherwise push 0.
#
# Stack: ( INT INT -- INT INT INT )

instruction eqi ()
  code
     PVM_BOOL_BINOP (INT, ==);
  end
end

# Instruction: eqiu
#
# Push 1 on the stack if the two unsigned integers at the top of the
# stack are equal.  Otherwise push 0.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction eqiu ()
  code
     PVM_BOOL_BINOP (UINT, ==);
  end
end

# Instruction: eql
#
# Push 1 on the stack if the two longs at the top of the stack are
# equal.  Otherwise push 0.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction eql ()
  code
     PVM_BOOL_BINOP (LONG, ==);
  end
end

# Instruction: eqlu
#
# Push 1 on the stack if the two unsigned longs at the top of the
# stack are equal.  Otherwise push 0.
#
# Stack: ( ULONG ULONG -- ULONG ULONG INT )

instruction eqlu ()
  code
     PVM_BOOL_BINOP (ULONG, ==);
  end
end

# Instruction: eqs
#
# Push 1 on the stack if the two strings at the top of the stack are
# equal.  Otherwise push 0.
#
# Stack: ( STR STR -- STR STR INT )

instruction eqs ()
  code
    pvm_val res
      = PVM_MAKE_INT (pvm_strcmp (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                  PVM_VAL_STR (JITTER_TOP_STACK ())) == 0,
                      32);
    JITTER_PUSH_STACK (res);
  end
end

# Instruction: nei
#
# Push 1 on the stack if the two integers at the top of the stack are
# not equal.  Otherwise push 0.
#
# Stack: ( INT INT -- INT INT INT )

instruction nei ()
  code
     PVM_BOOL_BINOP (INT, !=);
  end
end

# Instruction: neiu
#
# Push 1 on the stack if the two unsigned integers at the top of the
# stack are not equal.  Otherwise push 0.
#
# Stack: ( UINT UINT -- UINT UINT INT )

instruction neiu ()
  code
     PVM_BOOL_BINOP (UINT, !=);
  end
end

# Instruction: nel
#
# Push 1 on the stack if the two longs at the top of the stack are not
# equal.  Otherwise push 0.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction nel ()
  code
     PVM_BOOL_BINOP (LONG, !=);
  end
end

# Instruction: nelu
#
# Push 1 on the stack if the two unsigned longs at the top of the
# stack are not equal.  Otherwise push 0.
#
# Stack: ( ULONG ULONG -- ULONG ULONG INT )

instruction nelu ()
  code
     PVM_BOOL_BINOP (ULONG, !=);
  end
end

# Instruction: nes
#
# Push 1 on the stack if the two strings at the top of the stack are
# not equal.  Otherwise push 0.
#
# Stack: ( STR STR -- STR STR INT )

instruction nes ()
  code
    pvm_val res
      = PVM_MAKE_INT (pvm_strcmp (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                  PVM_VAL_STR (JITTER_TOP_STACK ())) != 0,
                      32);
    JITTER_PUSH_STACK (res);
  end
end

# Instruction: nn
#
# Push 0 on the stack if the value at the top of the stack equals
# PVM_NULL.  Otherwise push 1.
#
# Stack: ( VAL -- VAL INT )

instruction nn ()
  code
     JITTER_PUSH_STACK (PVM_MAKE_INT (JITTER_TOP_STACK () != PVM_NULL,
                                      32));
  end
end

# Instruction: nnn
#
# Push 1 on the stack if the value at the top of the stack equals
# PVM_NULL.  Otherwise push 0.
#
# Stack: ( VAL -- VAL INT )

instruction nnn ()
  code
     JITTER_PUSH_STACK (PVM_MAKE_INT (JITTER_TOP_STACK () == PVM_NULL,
                                      32));
  end
end

# Instruction: lti
#
# Push 1 on the stack if the integer at the under top is less that the
# integer at the top.  Otherwise push 0.
#
# Stack: ( INT INT -- INT INT INT )

instruction lti ()
  code
     PVM_BOOL_BINOP (INT, <);
  end
end

# Instruction: ltiu
#
# Push 1 on the stack if the unsigned integer at the under top is less
# that the unsigned integer at the top.  Otherwise push 0.
#
# Stack: ( UINT INT -- UINT UINT INT )

instruction ltiu () # ( UINT UINT -- UINT UINT INT )
  code
     PVM_BOOL_BINOP (UINT, <);
  end
end

# Instruction: ltl
#
# Push 1 on the stack if the long at the under top is less that the
# long at the top.  Otherwise push 0.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction ltl () # ( LONG LONG -- LONG LONG INT )
  code
     PVM_BOOL_BINOP (LONG, <);
  end
end

# Instruction: ltlu
#
# Push 1 on the stack if the unsigned long at the under top is less
# that the unsigned long at the top.  Otherwise push 0.
#
# Stack: ( ULONG ULONG -- ULONG ULONG INT )

instruction ltlu ()
  code
     PVM_BOOL_BINOP (ULONG, <);
  end
end

# Instruction: lei
#
# Push 1 on the stack if the integer at the under top is less or equal
# that the integer at the top.  Otherwise push 0.
#
# Stack: ( INT INT -- INT INT INT )

instruction lei () # ( INT INT -- INT INT INT )
  code
     PVM_BOOL_BINOP (INT, <=);
  end
end

# Instruction: leiu
#
# Push 1 on the stack if the unsigned integer at the under top is less
# or equal that the unsigned integer at the top.  Otherwise push 0.
#
# Stack: ( UINT UINT -- UINT UINT INT )

instruction leiu () # ( UINT UINT -- UINT UINT INT )
  code
     PVM_BOOL_BINOP (UINT, <=);
  end
end

# Instruction: lel
#
# Push 1 on the stack if the long at the under top is less or equal
# that the long at the top.  Otherwise push 0.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction lel () # ( LONG LONG -- LONG LONG INT )
  code
     PVM_BOOL_BINOP (LONG, <=);
  end
end

# Instruction: lelu
#
# Push 1 on the stack if the unsigned long at the under top is less or
# equal that the unsigned long at the top.  Otherwise push 0.
#
# Stack: ( ULONG ULONG -- ULONG ULONG INT )

instruction lelu ()
  code
     PVM_BOOL_BINOP (ULONG, <=);
  end
end

# Instruction: gti
#
# Push 1 on the stack if the integer at the under top is greater than
# the integer at the top.  Otherwise push 0.
#
# Stack: ( INT INT -- INT INT INT )

instruction gti ()
  code
     PVM_BOOL_BINOP (INT, >);
  end
end

# Instruction: gtiu
#
# Push 1 on the stack if the unsigned integer at the under top is
# greater than the unsigned integer at the top.  Otherwise push 0.
#
# Stack: ( UINT UINT -- UINT UINT INT )

instruction gtiu ()
  code
     PVM_BOOL_BINOP (UINT, >);
  end
end

# Instruction: gtl
#
# Push 1 on the stack if the long at the under top is greater than the
# long at the top.  Otherwise push 0.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction gtl ()
  code
     PVM_BOOL_BINOP (LONG, >);
  end
end

# Instruction: gtlu
#
# Push 1 on the stack if the unsigned long at the under top is greater
# than the unsigned long at the top.  Otherwise push 0.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction gtlu ()
  code
     PVM_BOOL_BINOP (ULONG, >);
  end
end

# Instruction: gei
#
# Push 1 on the stack if the integer at the under top is greater or
# equal than the integer at the top.  Otherwise push 0.
#
# Stack: ( INT INT -- INT INT INT )

instruction gei ()
  code
     PVM_BOOL_BINOP (INT, >=);
  end
end

# Instruction: geiu
#
# Push 1 on the stack if the unsigned integer at the under top is
# greater or equal than the unsigned integer at the top.  Otherwise
# push 0.
#
# Stack: ( UINT UINT -- UINT UINT INT )

instruction geiu ()
  code
     PVM_BOOL_BINOP (UINT, >=);
  end
end

# Instruction: gel
#
# Push 1 on the stack if the long at the under top is greater or equal
# than the long at the top.  Otherwise push 0.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction gel ()
  code
     PVM_BOOL_BINOP (LONG, >=);
  end
end

# Instruction: gelu
#
# Push 1 on the stack if the unsigned long at the under top is greater
# or equal than the unsigned long at the top.  Otherwise push 0.
#
# Stack: ( ULONG ULONG -- ULONG ULONG INT )

instruction gelu ()
  code
     PVM_BOOL_BINOP (ULONG, >=);
  end
end

# Instruction: lts
#
# Push 1 on the stack if the string at the under top is less than the
# string at the top, in lexicographic order.  Otherwise push 0.
#
# Stack: ( STR STR -- STR STR INT )

instruction lts ()
  code
    pvm_val res
      = PVM_MAKE_INT (pvm_strcmp (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                  PVM_VAL_STR (JITTER_TOP_STACK ())) < 0, 32);
    JITTER_PUSH_STACK (res);
  end
end

# Instruction: gts
#
# Push 1 on the stack if the string at the under top is greater than
# the string at the top, in lexicographic order.  Otherwise push 0.
#
# Stack: ( STR STR -- STR STR INT )

instruction gts ()
  code
    pvm_val res
      = PVM_MAKE_INT (pvm_strcmp (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                  PVM_VAL_STR (JITTER_TOP_STACK ())) > 0, 32);
    JITTER_PUSH_STACK (res);
  end
end

# Instruction: ges
#
# Push 1 on the stack if the string at the under top is greater or
# equal than the string at the top, in lexicographic order.  Otherwise
# push 0.
#
# Stack: ( STR STR -- STR STR INT )

instruction ges ()
  code
    pvm_val res
      = PVM_MAKE_INT (pvm_strcmp (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                  PVM_VAL_STR (JITTER_TOP_STACK ())) >= 0, 32);
    JITTER_PUSH_STACK (res);
  end
end

# Instruction: les
#
# Push 1 on the stack if the string at the under top is less or equal
# than the string at the top, in lexicographic order.  Otherwise push
# 0.
#
# Stack: ( STR STR -- STR STR INT )

instruction les ()
  code
    pvm_val res
      = PVM_MAKE_INT (pvm_strcmp (PVM_VAL_STR (JITTER_UNDER_TOP_STACK ()),
                                  PVM_VAL_STR (JITTER_TOP_STACK ())) <= 0, 32);
    JITTER_PUSH_STACK (res);
  end
end

# Instruction: eqc
#
# Push 1 on the stack if the two closures at the top of the stack are
# equal.  Otherwise push 0.
#
# Stack: ( CLS CLS -- CLS CLS INT )

instruction eqc ()
  code
    pvm_val res = PVM_MAKE_INT (JITTER_UNDER_TOP_STACK ()
                                == JITTER_TOP_STACK (),
                                32);
    JITTER_PUSH_STACK (res);
  end
end

# Instruction: nec
#
# Push 1 on the stack if the two closures at the top of the stack are
# not equal.  Otherwise push 0.
#
# Stack: ( CLS CLS -- CLS CLS INT )

instruction nec ()
  code
    pvm_val res = PVM_MAKE_INT (JITTER_UNDER_TOP_STACK ()
                                != JITTER_TOP_STACK (),
                                32);
    JITTER_PUSH_STACK (res);
  end
end


## Concatenation instructions

# Instruction: sconc
#
# Push the concatenation of the two strings at the top of the stack.
#
# Stack: ( STR STR -- STR STR STR )

instruction sconc ()
  code
     pvm_val res;
     char *sa = PVM_VAL_STR (JITTER_UNDER_TOP_STACK ());
     char *sb = PVM_VAL_STR (JITTER_TOP_STACK ());
     char *s = pvm_alloc (pvm_strlen (sa) + pvm_strlen (sb) + 1);
     pvm_strcpy (s, sa);
     pvm_strcat (s, sb);
     res = pvm_make_string_nodup (s);

     JITTER_PUSH_STACK (res);
  end
end


## Logical instructions

# Instruction: and
#
# Push the logical and of the two elements at the top of the stack.
#
# Stack: ( INT INT -- INT INT INT )

instruction and ()
  code
    PVM_BOOL_BINOP (INT, &&);
  end
end

# Instruction: or
#
# Push the logical or of the two elements at the top of the stack.
#
# Stack: ( INT INT -- INT INT INT )

instruction or ()
  code
    PVM_BOOL_BINOP (INT, ||);
  end
end

# Instruction: not
#
# Push the logical not of the element at the top of the stack.
#
# Stack: ( INT -- INT INT )

instruction not ()
  code
    pvm_val res = PVM_MAKE_INT (! PVM_VAL_INT (JITTER_TOP_STACK ()), 32);
    JITTER_PUSH_STACK (res);
  end
end


## Bitwise instructions

# Instruction: bxori
#
# Push the bitwise exclusive or of the two integers at the top of the
# stack.
#
# Stack: ( INT INT -- INT INT INT )

instruction bxori ()
  code
    PVM_BINOP (INT, INT, INT, ^);
  end
end

# Instruction: bxoriu
#
# Push the bitwise exclusive or of the two unsigned integers at the
# top of the stack.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction bxoriu ()
  code
    PVM_BINOP (UINT, UINT, UINT, ^);
  end
end

# Instruction: bxorl
#
# Push the bitwise exclusive or of the two longs at the top of the
# stack.
#
# Stack: ( LONG LONG -- LONG LONG LONG )

instruction bxorl ()
  code
    PVM_BINOP (LONG, LONG, LONG, ^);
  end
end

# Instruction: bxorlu
#
# Push the bitwise exclusive or of the two unsigned longs at the top
# of the stack.
#
# Stack: ( ULONG ULONG -- ULONG ULONG ULONG )

instruction bxorlu ()
  code
    PVM_BINOP (ULONG, ULONG, ULONG, ^);
  end
end

# Instruction: bori
#
# Push the bitwise or of the two integers at the top of the stack.
#
# Stack: ( INT INT -- INT INT INT )

instruction bori ()
  code
    PVM_BINOP (INT, INT, INT, |);
  end
end

# Instruction: boriu
#
# Push the bitwise or of the two unsigned integers at the top of the
# stack.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction boriu ()
  code
    PVM_BINOP (UINT, UINT, UINT, |);
  end
end

# Instruction: borl
#
# Push the bitwise or of the two longs at the top of the stack.
#
# Stack: ( LONG LONG -- LONG LONG LONG )

instruction borl ()
  code
    PVM_BINOP (LONG, LONG, LONG, |);
  end
end

# Instruction: borlu
#
# Push the bitwise or of the two longs at the top of the stack.
#
# Stack: ( ULONG ULONG  -- ULONG ULONG ULONG )

instruction borlu ()
  code
    PVM_BINOP (ULONG, ULONG, ULONG, |);
  end
end

# Instruction: bandi
#
# Push the bitwise and of the two integers at the top of the stack.
#
# Stack: ( INT INT -- INT INT INT )

instruction bandi ()
  code
    PVM_BINOP (INT, INT, INT, &);
  end
end

# Instruction: bandiu
#
# Push the bitwise and of the two unsigned integers at the top of the
# stack.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction bandiu ()
  code
    PVM_BINOP (UINT, UINT, UINT, &);
  end
end

# Instruction: bandl
#
# Push the bitwise and of the two longs at the top of the stack.
#
# Stack: ( LONG LONG -- LONG LONG LONG )

instruction bandl ()
  code
    PVM_BINOP (LONG, LONG, LONG, &);
  end
end

# Instruction: bandlu
#
# Push the bitwise and of the two unsigned longs at the top of the
# stack.
#
# Stack: ( ULONG ULONG -- ULONG ULONG ULONG )

instruction bandlu ()
  code
    PVM_BINOP (ULONG, ULONG, ULONG, &);
  end
end

# Instruction: bnoti
#
# Push the bitwise not of the integer at the top of the stack.
#
# Stack: ( INT -- INT INT INT )

instruction bnoti ()
  code
    PVM_UNOP (INT, INT, int, ~);
  end
end

# Instruction: bnotiu
#
# Push the bitwise not of the unsigned integer at the top of the
# stack.
#
# Stack: ( UINT -- UINT UINT )

instruction bnotiu ()
  code
    PVM_UNOP (UINT, UINT, uint, ~);
  end
end

# Instruction: bnotl
#
# Push the bitwise not of the long at the top of the stack.
#
# Stack: ( LONG -- LONG LONG )

instruction bnotl () # ( LONG -- LONG LONG )
  code
    PVM_UNOP (LONG, LONG, long, ~);
  end
end

# Instruction: bnotlu
#
# Push the bitwise not of the unsigned long at the top of the stack.
#
# Stack: ( ULONG -- ULONG ULONG )

instruction bnotlu ()
  code
    PVM_UNOP (ULONG, ULONG, ulong, ~);
  end
end

# Instruction: popcountiu
#
# Push the number of 1 bits in the unsigned int value at the top of
# the stack.
#
# Stack: ( UINT - UINT INT )

instruction popcountiu ()
  code
    uint32_t val;

    val = PVM_VAL_UINT (JITTER_TOP_STACK ());
    JITTER_PUSH_STACK (PVM_MAKE_INT (pvm_popcount (val), 32));
  end
end

# Instruction: popcountlu
#
# Push the number of 1 bits in the unsigned long value at the top of
# the stack.
#
# Stack: ( ULONG - ULONG INT )

instruction popcountlu ()
  code
    uint64_t val;

    val = PVM_VAL_ULONG (JITTER_TOP_STACK ());
    JITTER_PUSH_STACK (PVM_MAKE_INT (pvm_popcount (val), 32));
  end
end


## Shift instructions

# Instruction: bsli
#
# Left-shift the integer at the under top of the stack the number of
# bits indicated by the unsigned int at the top of the stack.
#
# If the bit count is equal or bigger than the size of the left
# operand, then UB happens.
#
# Stack: ( INT UINT -- INT UINT INT )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction bsli () # ( INT UINT -- INT UINT INT )
  code
    PVM_BINOP (INT, UINT, INT, <<);
  end
end

# Instruction: bsliu
#
# Left-shift the unsigned integer at the under top of the stack the
# number of bits indicated by the unsigned int at the top of the
# stack.
#
# If the bit count is equal or bigger than the size of the left
# operand, then UB happens.
#
# Stack: ( UINT UINT -- UINT UINT UINT )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction bsliu () # ( UINT UINT -- UINT UINT UINT )
  code
    PVM_BINOP (UINT, UINT, UINT, <<);
  end
end

# Instruction: bsll
#
# Left-shift the long at the under top of the stack the number of bits
# indicated by the unsigned int at the top of the stack.
#
# If the bit count is equal or bigger than the size of the left
# operand, then UB happens.
#
# Stack: ( LONG UINT -- LONG UINT LONG )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction bsll () # ( LONG UINT -- LONG UINT LONG )
  code
    PVM_BINOP (LONG, UINT, LONG, <<);
  end
end

# Instruction: bsllu
#
# Left-shift the unsigned long at the under top of the stack the
# number of bits indicated by the unsigned int at the top of the
# stack.
#
# If the bit count is equal or bigger than the size of the left
# operand, then UB happens.
#
# Stack: ( ULONG UINT -- ULONG UINT ULONG )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction bsllu () # ( ULONG UINT -- ULONG UINT ULONG )
  code
    PVM_BINOP (ULONG, UINT, ULONG, <<);
  end
end

# Instruction: bsri
#
# Right-shift the integer at the under top of the stack the number of
# tis indicated by the unsigned int at the top of the stack.
#
# Stack: ( INT UINT -- INT UINT INT )

instruction bsri ()
  code
    PVM_BINOP (INT, UINT, INT, >>);
  end
end

# Instruction: bsriu
#
# Right-shift the unsigned integer at the under top of the stack the
# number of tis indicated by the unsigned int at the top of the stack.
#
# Stack: ( UINT UINT -- UINT UINT UINT )

instruction bsriu ()
  code
    PVM_BINOP (UINT, UINT, UINT, >>);
  end
end

# Instruction: bsrl
#
# Right-shift the long at the under top of the stack the number of tis
# indicated by the unsigned int at the top of the stack.
#
# Stack: ( LONG UINT -- LONG UINT LONG )

instruction bsrl ()
  code
    PVM_BINOP (LONG, UINT, LONG, >>);
  end
end

# Instruction: bsrlu
#
# Right-shift the unsigned long at the under top of the stack the
# number of tis indicated by the unsigned int at the top of the stack.
#
# Stack: ( ULONG UINT -- ULONG UINT ULONG )

instruction bsrlu ()
  code
    PVM_BINOP (ULONG, UINT, ULONG, >>);
  end
end


## Compare-and-swap instructions

# Instruction: swapgti
#
# Swap the two integers at the top of the stack if the element at the
# under-top is greater than the element at the top.
#
# Stack: ( INT INT -- INT INT )

instruction swapgti ()
  code
     pvm_val a = JITTER_UNDER_TOP_STACK ();
     pvm_val b = JITTER_TOP_STACK ();
     if (PVM_VAL_INT (a) > PVM_VAL_INT (b))
     {
       JITTER_UNDER_TOP_STACK () = b;
       JITTER_TOP_STACK () = a;
     }
  end
end

# Instruction: swapgtiu
#
# Swap the two unsigned integers at the top of the stack if the
# element at the under-top is greater than the element at the top.
#
# Stack: ( UINT UINT -- UINT UINT )

instruction swapgtiu ()
  code
     pvm_val a = JITTER_UNDER_TOP_STACK ();
     pvm_val b = JITTER_TOP_STACK ();
     if (PVM_VAL_UINT (a) > PVM_VAL_UINT (b))
     {
       JITTER_UNDER_TOP_STACK () = b;
       JITTER_TOP_STACK () = a;
     }
  end
end

# Instruction: swapgtl
#
# Swap the two longs at the top of the stack if the element at the
# under-top is greater than the element at the top.
#
# Stack: ( LONG LONG -- LONG LONG )

instruction swapgtl ()
  code
     pvm_val a = JITTER_UNDER_TOP_STACK ();
     pvm_val b = JITTER_TOP_STACK ();
     if (PVM_VAL_LONG (a) > PVM_VAL_LONG (b))
     {
       JITTER_UNDER_TOP_STACK () = b;
       JITTER_TOP_STACK () = a;
     }
  end
end

# Instruction: swapgtlu
#
# Swap the two unsigned longs at the top of the stack if the element
# at the under-top is greater than the element at the top.
#
# Stack: ( ULONG ULONG -- ULONG ULONG )

instruction swapgtlu ()
  code
     pvm_val a = JITTER_UNDER_TOP_STACK ();
     pvm_val b = JITTER_TOP_STACK ();
     if (PVM_VAL_ULONG (a) > PVM_VAL_ULONG (b))
     {
       JITTER_UNDER_TOP_STACK () = b;
       JITTER_TOP_STACK () = a;
     }
  end
end


## Branch instructions

# Instruction: ba LABEL
#
# Branch unconditionally to the given LABEL.
#
# Stack: ( -- )

instruction ba (?f)
  branching
  code
    JITTER_BRANCH_FAST(JITTER_ARGF0);
  end
end

# Instruction: bn LABEL
#
# Branch to the given LABEL if the value at the top of the stack is
# PVM_NULL.
#
# Stack: ( VAL -- VAL )

instruction bn (?f)
  branching
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (tmp != PVM_NULL, JITTER_ARGF0);
  end
end

# Instruction: bnn LABEL
#
# Branch to the given LABEL if the value at the top of the stack is
# not PVM_NULL.
#
# Stack: ( VAL -- VAL )

instruction bnn (?f)
  branching
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (tmp == PVM_NULL, JITTER_ARGF0);
  end
end

# Instruction: bzi LABEL
#
# Branch to the given LABEL if the integer at the top of the stack is
# zero.
#
# Stack: ( INT -- INT )

instruction bzi (?f)
  branching
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_INT (tmp), JITTER_ARGF0);
  end
end

# Instruction: bziu LABEL
#
# Branch to the given LABEL if the unsigned integer at the top of
# the stack is zero.
#
# Stack: ( UINT -- UINT )

instruction bziu (?f)
  branching
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_ZERO (PVM_VAL_UINT (tmp), JITTER_ARGF0);
  end
end

# Instruction: bzl LABEL
#
# Branch to the given LABEL if the long at the top of the stack
# is zero.
#
# Stack: ( LONG -- LONG )

instruction bzl (?f)
  branching
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    /* JITTER_BRANCH_FAST_IF_ZERO expects word-size value for condition;
       PVM_VAL_LONG values are not word-size on 32-bit machines.  */
    JITTER_BRANCH_FAST_IF_ZERO (!!PVM_VAL_LONG (tmp), JITTER_ARGF0);
  end
end

# Instruction: bzlu LABEL
#
# Branch to the given LABEL if the unsigned long at the top of the
# stack is zero.
#
# Stack: ( ULONG -- ULONG )

instruction bzlu (?f)
  branching
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    /* JITTER_BRANCH_FAST_IF_ZERO expects word-size value for condition;
       PVM_VAL_LONG values are not word-size on 32-bit machines.  */
    JITTER_BRANCH_FAST_IF_ZERO (!!PVM_VAL_ULONG (tmp), JITTER_ARGF0);
  end
end

# Instruction: bnzi LABEL
#
# Branch to the given LABEL if the integer at the top of the stack
# is nonzero.
#
# Stack: ( INT -- INT )

instruction bnzi (?f)
  branching
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_NONZERO (PVM_VAL_INT (tmp), JITTER_ARGF0);
  end
end

# Instruction: bnziu LABEL
#
# Branch to the given LABEL if the unsigned integer at the top of the
# stack is nonzero.
#
# Stack: ( UINT -- UINT )

instruction bnziu (?f)
  branching
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    JITTER_BRANCH_FAST_IF_NONZERO (PVM_VAL_UINT (tmp), JITTER_ARGF0);
  end
end

# Instruction: bnzl LABEL
#
# Branch to the given LABEL if the long at the top of the stack is
# nonzero.
#
# Stack: ( LONG -- LONG )

instruction bnzl (?f)
  branching
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    /* JITTER_BRANCH_FAST_IF_ZERO expects word-size value for condition;
       PVM_VAL_LONG values are not word-size on 32-bit machines.  */
    JITTER_BRANCH_FAST_IF_NONZERO (!!PVM_VAL_LONG (tmp), JITTER_ARGF0);
  end
end

# Instruction: bnzlu LABEL
#
# Branch to the given LABEL if the unsigned long at the top of the
# stack is nonzero.
#
# Stack: ( ULONG -- ULONG )

instruction bnzlu (?f)
  branching
  code
    pvm_val tmp = JITTER_TOP_STACK ();
    /* JITTER_BRANCH_FAST_IF_ZERO expects word-size value for condition;
       PVM_VAL_LONG values are not word-size on 32-bit machines.  */
    JITTER_BRANCH_FAST_IF_NONZERO (!!PVM_VAL_ULONG (tmp), JITTER_ARGF0);
  end
end


## Conversion instructions

# Instruction: ctos
#
# Convert the character encoded as an unsigned integer at the top of
# the stack to a string that contains just that character.
#
# Stack: ( UINT -- UINT STR )

instruction ctos ()
  code
    uint8_t c = PVM_VAL_UINT (JITTER_TOP_STACK ());
    char *str = pvm_alloc (2);
    str[0] = c;
    str[1] = '\0';

    JITTER_PUSH_STACK (pvm_make_string_nodup (str));
  end
end

# Instruction: itoi NBITS
#
# Convert the integer at the top of the stack to an integer
# featuring NBITS bits.
#
# NBITS can be any number from 1 to 32.
#
# Stack: ( INT -- INT INT )

instruction itoi (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (INT, int32_t, int, int32_t);
  end
end

# Instruction: itoiu NBITS
#
# Convert the integer at the top of the stack to an unsigned integer
# featuring NBITS bits.
#
# NBITS can be any number from 1 to 32.
#
# Stack: ( INT -- INT UINT )

instruction itoiu (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (INT, int32_t, uint, uint32_t);
  end
end

# Instruction: itol NBITS
#
# Convert the integer at the top of the stack to a long featuring
# NBITS bits.
#
# NBITS can be any number from 1 to 64.
#
# Stack: ( INT -- INT LONG )

instruction itol (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (INT, int32_t, long, int64_t);
  end
end

# Instruction: itolu NBITS
#
# Convert the integer at the top of the stack to an unsigned long
# featuring NBITS bits.
#
# NBITS can be any number from 1 to 64.
#
# Stack: ( INT -- INT ULONG )

instruction itolu (?n pvm_literal_printer_cast) # ( INT -- INT ULONG )
  code
    PVM_CONVOP (INT, int32_t, ulong, uint64_t);
  end
end

# Instruction: iutoi NBITS
#
# Convert the unsigned integer at the top of the stack to an integer
# featuring NBITS bits.
#
# NBITS can be any number from 1 to 32.
#
# Stack: ( UINT -- UINT INT )

instruction iutoi (?n pvm_literal_printer_cast) # ( UINT -- UINT INT )
  code
    PVM_CONVOP (UINT, uint32_t, int, int32_t);
  end
end

# Instruction: iutoiu NBITS
#
# Convert the unsigned integer at the top of the stack to an unsigned
# integer featuring NBITS bits.
#
# NBITS can be any number from 1 to 32.
#
# Stack: ( UINT -- UINT UINT )

instruction iutoiu (?n pvm_literal_printer_cast) # ( UINT -- UINT UINT )
  code
    PVM_CONVOP (UINT, uint32_t, uint, uint32_t);
  end
end

# Instruction: iutol NBITS
#
# Convert the unsigned integer at the top of the stack to a long
# featuring NBITS bits.
#
# NBITS can be any number from 1 to 64.
#
# Stack: ( UINT -- UINT LONG )

instruction iutol (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (UINT, uint32_t, long, int64_t);
  end
end

# Instruction: iutolu NBITS
#
# Convert the unsigned integer at the top of the stack to an
# unsigned long featuring NBITS bits.
#
# NBITS can be any number from 1 to 64.
#
# Stack: ( UINT -- UINT ULONG )

instruction iutolu (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (UINT, uint32_t, ulong, uint64_t);
  end
end

# Instruction: ltoi NBITS
#
# Convert the long at the top of the stack to an integer
# featuring NBITS bits.
#
# NBITS can be any number from 1 to 32.
#
# Stack: ( LONG -- LONG INT )

instruction ltoi (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (LONG, int64_t, int, int32_t);
  end
end

# Instruction: ltoiu NBITS
#
# Convert the long at the top of the stack to an unsigned
# integer featuring NBITS bits.
#
# NBITS can be any number from 1 to 32.
#
# Stack: ( LONG -- LONG UINT )

instruction ltoiu (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (LONG, int64_t, uint, uint32_t);
  end
end

# Instruction: ltol NBITS
#
# Convert the long at the top of the stack to a long featuring
# NBITS bits.
#
# NBITS can be any number from 1 to 64.
#
# Stack: ( LONG -- LONG LONG )

instruction ltol (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (LONG, int64_t, long, int64_t);
  end
end

# Instruction: ltolu NBITS
#
# Convert the long at the top of the stack to an unsigned long
# featuring NBITS bits.
#
# NBITS can be any number from 1 to 64.
#
# Stack: ( LONG -- LONG ULONG )

instruction ltolu (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (LONG, int64_t, ulong, uint64_t);
  end
end

# Instruction: lutoi NBITS
#
# Convert the unsigned long at the top of the stack to an integer
# featuring NBITS bits.
#
# NBITS can be any number from 1 to 32.
#
# Stack: ( ULONG -- ULONG INT )

instruction lutoi (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (ULONG, uint64_t, int, int32_t);
  end
end

# Instruction: lutoiu NBITS
#
# Convert the unsigned long at the top of the stack to an unsigned
# integer featuring NBITS bits.
#
# NBITS can be any number from 1 to 32.
#
# Stack: ( ULONG -- ULONG UINT )

instruction lutoiu (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (ULONG, uint64_t, uint, uint32_t);
  end
end

# Instruction: lutol NBITS
#
# Convert the unsigned long at the top of the stack to a long
# featuring NBITS bits.
#
# Stack: ( ULONG -- ULONG LONG )

instruction lutol (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (ULONG, uint64_t, long, int64_t);
  end
end

# Instruction: lutolu NBITS
#
# Convert the unsigned long at the top of the stack to an
# unsigned long featuring NBITS bits.
#
# Stack: ( ULONG -- ULONG ULONG )

instruction lutolu (?n pvm_literal_printer_cast)
  code
    PVM_CONVOP (ULONG, uint64_t, ulong, uint64_t);
  end
end


## String instructions

# Instruction: strref
#
# Given a string and an unsigned long at the top of the stack, push an
# unsigned integer with the code of the character that occupies that
# position in the string, on the stack.
#
# The index is zero-based.  If it is less than 0 or exceeds the
# length of the string, then PVM_E_OUT_OF_BOUNDS is raised.
#
# Stack: ( STR ULONG -- STR ULONG UINT )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction strref () # ( STR ULONG -- STR ULONG VAL )
  branching # because of PVM_RAISE_DIRECT
  code
     pvm_val string = JITTER_UNDER_TOP_STACK ();
     pvm_val index = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (index) < 0
        || (PVM_VAL_ULONG (index) >=
            pvm_strlen (PVM_VAL_STR (string))))
      PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    JITTER_PUSH_STACK (PVM_MAKE_UINT (PVM_VAL_STR (string)[PVM_VAL_ULONG (index)],
                                      8));
  end
end

# Instruction: strset
#
# Given a string STR, an index FROM and a string NEWSTR, copy the content
# of NEWSTR to STR at index FROM.
#
# Index is zero-based.
#
# If FROM >= the size of the string, or if FROM+len(NEWSTR) > the size
# of the string, raise the PVM_E_OUT_OF_BOUNDS exception.
#
# Stack: ( STR ULONG NEWSTR -- STR )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction strset ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val newstr = JITTER_TOP_STACK ();
    uint64_t from = PVM_VAL_ULONG (JITTER_UNDER_TOP_STACK ());
    pvm_val str;
    size_t slen, nslen = pvm_strlen (PVM_VAL_STR (newstr));

    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    str = JITTER_TOP_STACK ();
    slen = pvm_strlen (PVM_VAL_STR (str));

    if (from > slen || from + nslen > slen)
      PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    /* Using `pvm_strncpy` will emit a false compiler warning
       (-Wstringop-overflow=).  */
    pvm_memcpy (PVM_VAL_STR (str) + from, PVM_VAL_STR (newstr), nslen);
  end
end

# Instruction: substr
#
# Given a string and two indices FROM and TO conforming a semi-open
# interval [FROM,TO), push the substring enclosed by that interval.
#
# Both indexes are zero-based.
#
# If FROM >= the size of the string, or if TO > the size of the
# string, or if FROM >= TO, raise the PVM_E_OUT_OF_BOUNDS exception.
#
# Stack: ( STR ULONG(from) ULONG(to) -- STR ULONG(from) ULONG(to) STR )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction substr () # ( STR ULONG ULONG -- STR ULONG ULONG STR )
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val str;
    char *s;
    pvm_val to = JITTER_TOP_STACK ();
    pvm_val from = JITTER_UNDER_TOP_STACK ();
    size_t slen = PVM_VAL_ULONG (to) - PVM_VAL_ULONG (from);

    JITTER_DROP_STACK ();
    str = JITTER_UNDER_TOP_STACK ();
    JITTER_PUSH_STACK (to);

    if (PVM_VAL_ULONG (from) >= pvm_strlen (PVM_VAL_STR (str))
        || PVM_VAL_ULONG (to) > pvm_strlen (PVM_VAL_STR (str))
        || PVM_VAL_ULONG (from) > PVM_VAL_ULONG (to))
        PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    s = pvm_alloc (slen + 1);
    pvm_strncpy (s,
                 PVM_VAL_STR (str) + PVM_VAL_ULONG (from),
                 slen);
    s[slen] = '\0';

    JITTER_PUSH_STACK (pvm_make_string_nodup (s));
  end
end

# Instruction: muls
#
# Given a string and an unsigned long on the stack, push a new
# string value whose value is the concatenation of the argument
# string applied to itself as many times as the unsigned long.  If
# the second argument to muls is 0 then the result of the operation
# is the empty string.
#
# Stack: ( STR ULONG -- STR ULONG STR )

instruction muls ()
  code
    pvm_val str = JITTER_UNDER_TOP_STACK ();
    size_t i, num = PVM_VAL_ULONG (JITTER_TOP_STACK ());
    char *res = pvm_alloc (pvm_strlen (PVM_VAL_STR (str)) * num + 1);

    *res = '\0';
    for (i = 0; i < num; ++i)
      pvm_strcat (res, PVM_VAL_STR (str));

    JITTER_PUSH_STACK (pvm_make_string_nodup (res));
  end
end

# Instruction: sprops
#
# Given a string STR, set the styling class of the substring with
# length LEN from index IDX to CLASS.
#
# Stack: ( STR IDX LEN CLASS -- STR )

instruction sprops ()
  code
    /* FIXME not implemented yet */
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
  end
end

# Instruction: sproph
#
# Given a string STR, set the hyperlink property (which characterized
# by a URL and an ID) of the substring with length LEN from index IDX.
#
# Stack: ( STR IDX LEN URL ID -- STR )

instruction sproph ()
  code
    /* FIXME not implemented yet */
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
  end
end


# Instruction: spropc
#
# Given a string on the stack, push the copy of the string with all
# properties cleared.
#
# Stack: ( STR -- STR )

instruction spropc ()
  code
    /* FIXME not implemented yet */
  end
end


## Closure instructions

# Instruction: cgetn
#
# Push the name of the given closure value, or PVM_NULL if the
# closure doesn't have a name.
#
# Stack: ( CLS -- CLS STR|null )

instruction cgetn ()
  code
    JITTER_PUSH_STACK (PVM_VAL_CLS_NAME (JITTER_TOP_STACK ()));
  end
end


## Array instructions

# Instruction: mka
#
# Make a new empty array value.
#
# TYP is the type of the new array.
#
# NELEM is a hint on how many elements to use to initialize the array
# value.  This is to avoid allocating memory that will never be used.
# Use 0UL when the number of elements in the array are not known
# in advance; this will make the PVM to choose a reasonable default.
#
# Stack: ( TYP ULONG(nelem) -- ARR )

instruction mka ()
  code
    pvm_val arr = pvm_make_array (JITTER_TOP_STACK (),
                                  JITTER_UNDER_TOP_STACK ());

    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    JITTER_PUSH_STACK (arr);
  end
end

# Instruction: ains
#
# Insert a new element VAL, at the end of the array ARR, making it grow.
#
# If IDX is less than the current size of the array, the value is
# stored in the referred argument.
#
# If IDX is equal or bigger than the current size of the array, the
# same element is replicated in the previous elements.
#
# Examples:
#
# a = [a1, a2, a3]
#
# [a1, a2, a3] 2 VAL ains -> INVAL exception
# [a1, a2, a3] 3 VAL ains -> [a1, a2, a3, VAL]
# [a1, a2, a3] 5 VAL ains -> [a1, a2, a3, VAL, VAL, VAL]
#
# Stack: ( ARR IDX VAL -- ARR )
# Exceptions: PVM_E_INVAL

instruction ains ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val val = JITTER_TOP_STACK ();
    pvm_val idx = JITTER_UNDER_TOP_STACK ();
    pvm_val arr;

    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    arr = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (idx) < PVM_VAL_ULONG (PVM_VAL_ARR_NELEM (arr)))
      /* Note that pvm_array_set can't return 0 here due
         to the index check.  */
      pvm_array_set (arr, idx, val);
    else
    {
      if (!pvm_array_insert (arr, idx, val))
        PVM_RAISE (PVM_E_INVAL, pvm_literal_eindex,
                   PVM_E_INVAL_ESTATUS);
    }
  end
end

# Instruction: arem
#
# Remove an element from an array at the specified index, making it
# schrink.
#
# If IDX doesn't correspond to an element in the array, raise
# PVM_E_OUT_OF_BOUNDS.  This always happens if the array is empty.
#
# Stack: ( ARR IDX -- ARR )
# Exception: PVM_E_OUT_OF_BOUNDS

instruction arem ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val arr = JITTER_UNDER_TOP_STACK ();
    pvm_val idx = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (idx) >= PVM_VAL_ULONG (PVM_VAL_ARR_NELEM (arr)))
      PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    /* This call can't fail (return 0) due to the index check above.  */
    (void) pvm_array_rem (arr, idx);
    JITTER_DROP_STACK ();
  end
end

# Instruction: aset
#
# Set the value with index ULONG in the array ARR to have the value
# VAL.  The index in ULONG should be in range, since this instruction
# is not checked.
#
# Stack: ( ARR ULONG VAL -- ARR )

instruction aset ()
  code
    pvm_val idx;
    pvm_val val;
    pvm_val arr;
    size_t index;

    val= JITTER_TOP_STACK ();
    idx = JITTER_UNDER_TOP_STACK ();
    index = PVM_VAL_ULONG (idx);
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();

    arr = JITTER_TOP_STACK ();

    PVM_ASSERT (index < PVM_VAL_INTEGRAL (PVM_VAL_ARR_NELEM (arr)));

    /* Note that pvm_aray_set cannot fail here, due to the check
       on index above.  */
    pvm_array_set (arr, idx, val);
  end
end

# Instruction: aref
#
# Given an array ARR and an index ULONG, push the element of the array
# occupying that position on the stack.
#
# If the provided index is out of bounds, then raise
# PVM_E_OUT_OF_BOUNDS.
#
# Stack: ( ARR ULONG -- ARR ULONG VAL )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction aref ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val array = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();

    if ((PVM_VAL_ULONG (index) >=
            PVM_VAL_INTEGRAL (PVM_VAL_ARR_NELEM (array))))
      PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    JITTER_PUSH_STACK (PVM_VAL_ARR_ELEM_VALUE (array,
                                               PVM_VAL_ULONG (index)));
  end
end

# Instruction: arefo
#
# Given an array ARR and an index ULONG, push the offset of the
# element occupying that position in the array.
#
# If the provided index is out of bounds, then raise
# PVM_E_OUT_OF_BOUNDS.
#
# Stack: ( ARR ULONG -- ARR ULONG OFF )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction arefo ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val array = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (index) < 0
        || (PVM_VAL_ULONG (index) >=
            PVM_VAL_INTEGRAL (PVM_VAL_ARR_NELEM (array))))
      PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    JITTER_PUSH_STACK (PVM_VAL_ARR_ELEM_OFFSET (array,
                                                PVM_VAL_ULONG (index)));
  end
end


## Struct instructions

# Instruction: mksct
#
# Given an offset, a list of fields, a list of methods and a struct
# type, create a struct value and push it on the stack.
#
# Each field is specified as a triplet [OFF STR VAL] where OFF is the
# offset of field, STR the name of the field or PVM_NULL if the field
# is anonymous, and VAL is a value.
#

# Each method is specified as a tuple [STR VAL] where STR is the name
# of the method and VAL is the closure value corresponding to the
# method.
#
# Stack: ( OFF [OFF STR VAL]... [STR VAL]... ULONG ULONG TYP -- SCT )

instruction mksct ()
  code
    size_t e;
    pvm_val nfields, nmethods, sct, type;

    type = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    nfields = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    nmethods = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    sct = pvm_make_struct (nfields, nmethods, type);

    for (e = 0; e < PVM_VAL_ULONG (nmethods); ++e)
    {
      PVM_VAL_SCT_METHOD_VALUE (sct, PVM_VAL_ULONG (nmethods) - e - 1)
         = JITTER_TOP_STACK ();
      PVM_VAL_SCT_METHOD_NAME (sct, PVM_VAL_ULONG (nmethods) - e - 1)
         = JITTER_UNDER_TOP_STACK ();

      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();
    }

    for (e = 0; e < PVM_VAL_ULONG (nfields); ++e)
    {
      PVM_VAL_SCT_FIELD_VALUE (sct, PVM_VAL_ULONG (nfields) - e - 1)
          = JITTER_TOP_STACK ();
      PVM_VAL_SCT_FIELD_NAME (sct, PVM_VAL_ULONG (nfields) - e - 1)
          = JITTER_UNDER_TOP_STACK ();

      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();

      PVM_VAL_SCT_FIELD_OFFSET (sct, PVM_VAL_ULONG (nfields) - e -1)
          = JITTER_TOP_STACK ();
      JITTER_DROP_STACK ();
    }

    PVM_VAL_SCT_OFFSET (sct) = JITTER_TOP_STACK();
    JITTER_DROP_STACK ();

    JITTER_PUSH_STACK (sct);
  end
end

# Instruction: sset
#
# Given a struct, a field name and a value, replace the value of
# the referred struct field with the given value.  If the struct
# does not have a field with the given name, then raise PVM_E_ELEM.
#
# Stack: ( SCT STR VAL -- SCT )
# Exceptions: PVM_E_ELEM

instruction sset ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val val = JITTER_TOP_STACK ();
    pvm_val name = JITTER_UNDER_TOP_STACK ();
    pvm_val sct;

    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();

    sct = JITTER_TOP_STACK ();
    if (!pvm_set_struct (sct, name, val))
       PVM_RAISE_DFL (PVM_E_ELEM);
  end
end

# Instruction: sseti
#
# Given a struct, a field index and a value, replace the value
# of the referred struct field with the given value.  If the
# given index does not refer to a struct field, then raise
# PVM_E_ELEM.
#
# Stack: (SCT IDX VAL -- SCT)
# Exceptions: PVM_E_ELEM

instruction sseti ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val val = JITTER_TOP_STACK ();
    pvm_val idx = JITTER_UNDER_TOP_STACK ();
    size_t field_index = PVM_VAL_ULONG (idx);
    pvm_val sct;

    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();

    sct = JITTER_TOP_STACK ();

    if (field_index >= PVM_VAL_SCT_NFIELDS (sct))
      PVM_RAISE_DFL (PVM_E_ELEM);
    PVM_VAL_SCT_FIELD_VALUE (sct, field_index) = val;
  end
end

# Instruction: sref
#
# Given a struct and a field name, push the value contained in the
# referred struct field on the stack.  If the struct does not have a
# field with the given name, or if the field is absent from the struct
# value then raise PVM_E_ELEM.
#
# Stack: ( SCT STR -- SCT STR VAL )
# Exceptions: PVM_E_ELEM

instruction sref ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val val = pvm_ref_struct (JITTER_UNDER_TOP_STACK (),
                                  JITTER_TOP_STACK ());

    if (val == PVM_NULL)
      PVM_RAISE_DFL (PVM_E_ELEM);
    JITTER_PUSH_STACK (val);
  end
end

# Instruction: srefo
#
# Given a struct and a field name, push the bit-offset of the referred
# field on the stack.  If the struct does not have a field with the given
# name, or if the field is absent from the struct value then raise
# PVM_E_ELEM.
#
# Stack: ( SCT STR -- SCT STR BOFF )
# Exceptions: PVM_E_ELEM

instruction srefo ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val sct = JITTER_UNDER_TOP_STACK ();
    pvm_val fname = JITTER_TOP_STACK ();
    pvm_val boff = pvm_refo_struct (sct, fname);

    if (boff == PVM_NULL)
      PVM_RAISE_DFL (PVM_E_ELEM);
    JITTER_PUSH_STACK (boff);
  end
end

# Instruction: srefmnt
#
# Given a struct and a method name, push the closure value corresponding
# to that method on the stack.  If the struct does not have a method with
# the given name then push PVM_NULL.
#
# Stack: ( SCT STR - SCT STR CLS )

instruction srefmnt ()
  code
    pvm_val sct = JITTER_UNDER_TOP_STACK ();
    pvm_val name = JITTER_TOP_STACK ();
    pvm_val cls = pvm_get_struct_method (sct, PVM_VAL_STR (name));

    JITTER_PUSH_STACK (cls);
  end
end

# Instruction: srefnt
#
# Given a struct and a field name, push the value contained in the
# struct field on the stack.  If the struct does not have a field with
# the given name, or if the field is absent from the struct value then
# push PVM_NULL.
#
# Stack: ( SCT STR -- SCT STR VAL )

instruction srefnt ()
  code
    pvm_val val = pvm_ref_struct (JITTER_UNDER_TOP_STACK (),
                                  JITTER_TOP_STACK ());

    JITTER_PUSH_STACK (val);
  end
end

# Instruction: srefi
#
# Given a struct and an index, push the value of the field occupying
# the position specified by the index in the given struct.  If the
# struct doesn't have that many fields, raise PVM_E_OUT_OF_BOUNDS.
#
# Stack: ( SCT ULONG -- SCT ULONG VAL )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction srefi ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val sct = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (index) < 0
        || (PVM_VAL_ULONG (index) >=
            PVM_VAL_INTEGRAL (PVM_VAL_SCT_NFIELDS (sct))))
      PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    JITTER_PUSH_STACK (PVM_VAL_SCT_FIELD_VALUE (sct,
                                               PVM_VAL_ULONG (index)));
  end
end

# Instruction: srefia
#
# Given a struct and an index, push 1 if the field occupying the
# position specified by the index in the given struct is absent.  Push
# 0 otherwise.  If the struct doesn't have that many fields, raise
# PVM_E_OUT_OF_BOUNDS.
#
# Stack: ( SCT ULONG -- SCT ULONG INT )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction srefia ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val sct = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();
    int absent_p;

    if (PVM_VAL_ULONG (index) < 0
        || (PVM_VAL_ULONG (index) >=
            PVM_VAL_INTEGRAL (PVM_VAL_SCT_NFIELDS (sct))))
      PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    absent_p = PVM_VAL_SCT_FIELD_ABSENT_P (sct, PVM_VAL_ULONG (index));
    JITTER_PUSH_STACK (PVM_MAKE_INT (absent_p, 32));
  end
end

# Instruction: srefio
#
# Given a struct and an index, push the offset of the field occupying
# the position specified by the index in the given struct.  If the
# struct doesn't have that many fields, raise PVM_E_OUT_OF_BOUNDS.
#
# Stack: ( SCT ULONG -- SCT ULONG BOFF )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction srefio ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val sct = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (index) < 0
        || (PVM_VAL_ULONG (index) >=
            PVM_VAL_INTEGRAL (PVM_VAL_SCT_NFIELDS (sct))))
      PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    JITTER_PUSH_STACK (PVM_VAL_SCT_FIELD_OFFSET (sct,
                                                 PVM_VAL_ULONG (index)));
  end
end

# Instruction: srefin
#
# Given a struct and an index, push the name of the field occupying
# the position specified by the index in the given struct.  If the
# field is anonymous, push PVM_NULL.  If the struct doesn't have that
# many fields, raise PVM_E_OUT_OF_BOUNDS.
#
# Stack: ( SCT ULONG -- SCT ULONG STR )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction srefin ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val sct = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (index) < 0
        || (PVM_VAL_ULONG (index) >=
            PVM_VAL_INTEGRAL (PVM_VAL_SCT_NFIELDS (sct))))
      PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    JITTER_PUSH_STACK (PVM_VAL_SCT_FIELD_NAME (sct,
                                               PVM_VAL_ULONG (index)));
  end
end

# Instruction: smodi
#
# Given a struct and an index, push the modified flags of the field
# occupying the position specified by the index in the given struct.
# If the struct doesn't have that many fields, raise
# PVM_E_OUT_OF_BOUNDS.
#
# Stack: ( SCT ULONG -- SCT ULONG BOOL )
# Exceptions: PVM_E_OUT_OF_BOUNDS

instruction smodi ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val sct = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();

    if (PVM_VAL_ULONG (index) < 0
        || (PVM_VAL_ULONG (index) >=
            PVM_VAL_INTEGRAL (PVM_VAL_SCT_NFIELDS (sct))))
      PVM_RAISE_DFL (PVM_E_OUT_OF_BOUNDS);

    JITTER_PUSH_STACK (PVM_VAL_SCT_FIELD_MODIFIED (sct,
                                                   PVM_VAL_ULONG (index)));
  end
end


## Offset Instructions

# Instruction: mko
#
# Given an integral magnitude VAL and an offset type,
# make an offset value of that type and push it on the stack.
#
# Stack: ( VAL TYP -- OFF )

instruction mko ()
  code
   PVM_ASSERT (PVM_IS_TYP (JITTER_TOP_STACK ())); /* XXX */

   pvm_val res = pvm_make_offset (JITTER_UNDER_TOP_STACK (),
                                  JITTER_TOP_STACK ());
   JITTER_DROP_STACK ();
   JITTER_TOP_STACK () = res;
  end
end

# Instruction: mkoq
#
# Given an integral magnitude VAL and an unit in an ULONG,
# make an offset type and create an offset value with that type.
#
# Stack: ( VAL ULONG -- OFF )

instruction mkoq ()
  code
   pvm_val type = pvm_make_offset_type (pvm_typeof (JITTER_UNDER_TOP_STACK ()),
                                        JITTER_TOP_STACK (), PVM_NULL /* ref_type */);
   pvm_val res = pvm_make_offset (JITTER_UNDER_TOP_STACK (), type);
   JITTER_DROP_STACK ();
   JITTER_TOP_STACK () = res;
  end
end

# Instruction: ogetm
#
# Given an offset OFF, push its magnitude on the stack.
#
# Stack: ( OFF -- OFF VAL )

instruction ogetm ()
  code
   JITTER_PUSH_STACK (PVM_VAL_OFF_MAGNITUDE (JITTER_TOP_STACK ()));
  end
end

# Instruction: osetm
#
# Given an offset OFF and an integral value VAL, make it the
# offset's magnitude.
#
# Stack: ( OFF VAL -- OFF )

instruction osetm ()
  code
   PVM_VAL_OFF_MAGNITUDE (JITTER_UNDER_TOP_STACK ())
    =  JITTER_TOP_STACK ();
   JITTER_DROP_STACK ();
  end
end

# Instruction: ogetu
#
# Given an offset OFF, push its unit on the stack.
#
# Stack: ( OFF -- OFF ULONG )

instruction ogetu ()
  code
    pvm_val otype = PVM_VAL_OFF_TYPE (JITTER_TOP_STACK ());
    JITTER_PUSH_STACK (PVM_VAL_TYP_O_UNIT (otype));
  end
end

# Instruction: ogetbt
#
# Given an offset OFF, push its base type on the stack.
#
# Stack: ( OFF -- OFF TYP )

instruction ogetbt ()
  code
    pvm_val otype = PVM_VAL_OFF_TYPE (JITTER_TOP_STACK ());
    JITTER_PUSH_STACK (PVM_VAL_TYP_O_BASE_TYPE (otype));
  end
end


## Instructions to handle mapped values

# Instruction: mm
#
# Given a value, push 1 on the stack if the value is mapped.
# Push 0 otherwise.
#
# Stack: ( VAL -- VAL INT )

instruction mm ()
  code
    pvm_val mapped_p = PVM_MAKE_INT (PVM_VAL_MAPPED_P (JITTER_TOP_STACK ()),
                                     32);
    JITTER_PUSH_STACK (mapped_p);
  end
end

# Instruction: map
#
# Given a value, mark it as as mapped.  If the value can't be
# mapped then this is a no-operation.
#
# Stack: ( VAL -- VAL )

instruction map ()
  code
    PVM_VAL_SET_MAPPED_P (JITTER_TOP_STACK (), 1);
  end
end

# Instruction: unmap
#
# Given a value, mark it as as not mapped.  If the value can't be
# mapped then this is a no-operation.
#
# Stack: ( VAL -- VAL )

instruction unmap ()
  code
    pvm_val_unmap (JITTER_TOP_STACK ());
  end
end

# Instruction: reloc
#
# Given a value, a IO space expressed in an ulong, and a bit-offset
# expressed in an ulong, relocate the value to the given bit-offset at
# the given IO space.
#
# If the given value is not map-able then raise PVM_E_INVAL.
#
# Stack: ( VAL ULONG ULONG -- VAL ULONG ULONG )
# Exceptions: PVM_E_INVAL

instruction reloc ()
  branching # because of PVM_RAISE_DIRECT
  code
    pvm_val boffset = JITTER_TOP_STACK ();
    pvm_val ios = JITTER_UNDER_TOP_STACK ();
    pvm_val val;

    JITTER_DROP_STACK ();
    val = JITTER_UNDER_TOP_STACK ();
    JITTER_PUSH_STACK (boffset);

    if (!(PVM_IS_ARR (val) || PVM_IS_SCT (val)))
      PVM_RAISE (PVM_E_INVAL, pvm_literal_notmappable, PVM_E_INVAL_ESTATUS);

    pvm_val_reloc (val, ios, boffset);
  end
end

# Instruction: ureloc
#
# Given a value, undo the last reloc performed on the value.
#
# If the given value is not map-able then raise PVM_E_INVAL.
#
# Stack: ( VAL -- VAL )
# Exceptions: PVM_E_INVAL

instruction ureloc ()
  branching # because of PVM_RAISE_DIRECT
  code
      pvm_val val = JITTER_TOP_STACK ();

      if (!(PVM_IS_ARR (val) || PVM_IS_SCT (val)))
        PVM_RAISE (PVM_E_INVAL, pvm_literal_notmappable, PVM_E_INVAL_ESTATUS);

      pvm_val_ureloc (val);
  end
end

# Instruction: mgets
#
# Given a value, push a boolean indicating whether the
# value is strict.  If the given value is not map-able then push
# false, i.e. 0.
#
# Stack: ( VAL -- VAL INT )

instruction mgets ()
  code
    int strict_p = PVM_VAL_STRICT_P (JITTER_TOP_STACK ());
    JITTER_PUSH_STACK (PVM_MAKE_INT (strict_p, 32));
  end
end

# Instruction: msets
#
# Given a value and a boolean, set the strictness of the value
# to the given boolean.  If the value is not map-able this is
# a no-operation.
#
# Stack: ( VAL INT -- VAL )

instruction msets ()
  code
    int strict_p = PVM_VAL_INT (JITTER_TOP_STACK ());

    PVM_VAL_SET_STRICT_P (JITTER_UNDER_TOP_STACK (), strict_p);
    JITTER_DROP_STACK ();
  end
end

# Instruction: mgeto
#
# Given a map-able value, push its bit-offset on the stack as an
# unsigned long.  If the given value is not map-able then push
# PVM_NULL.
#
# Stack: ( VAL -- VAL ULONG )

instruction mgeto ()
  code
    JITTER_PUSH_STACK (PVM_VAL_OFFSET (JITTER_TOP_STACK ()));
  end
end

# Instruction: mseto
#
# Given a map-able value an a bit-offset, set its offset to the value.
# If the given value is not map-able, then the offset is ignored.
#
# Stack: ( VAL ULONG -- VAL )

instruction mseto ()
  code
    PVM_VAL_SET_OFFSET (JITTER_UNDER_TOP_STACK (),
                        JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: mgetios
#
# Given a map-able value, push its associated IO space on the stack.
# If the given value is not map-able, then push PVM_NULL.
#
# Stack: ( VAL -- VAL INT )

instruction mgetios ()
  code
    JITTER_PUSH_STACK (PVM_VAL_IOS (JITTER_TOP_STACK ()));
  end
end

# Instruction: msetios
#
# Given a map-able value and an IOS descriptor, set it as its
# associated IO space.  If the IOS descriptor is PVM_NULL then it uses
# the current IO space.  If the given value is not map-able then the
# IO space is ignored.
#
# Stack: ( VAL INT -- VAL )

instruction msetios ()
  code
    PVM_VAL_SET_IOS (JITTER_UNDER_TOP_STACK (),
                     JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: mgetm
#
# Given a map-able value, push its mapper closure on the stack.  If
# the given value is not map-able, then push PVM_NULL.
#
# Stack: ( VAL -- VAL CLS )

instruction mgetm ()
  code
     JITTER_PUSH_STACK (PVM_VAL_MAPPER (JITTER_TOP_STACK ()));
  end
end

# Instruction: msetm
#
# Given a map-able value and a closure, set it as its mapper.  If the
# given value is not map-able then the closure is ignored.
#
# Stack: ( VAL CLS -- VAL )

instruction msetm ()
  code
    PVM_VAL_SET_MAPPER (JITTER_UNDER_TOP_STACK (), JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: mgetw
#
# Given a map-able value, push its writer closure on the stack.  If
# the given value is not map-able, then push PVM_NULL.
#
# Stack: ( VAL -- VAL CLS )

instruction mgetw ()
  code
     JITTER_PUSH_STACK (PVM_VAL_WRITER (JITTER_TOP_STACK ()));
  end
end

# Instruction: msetw
#
# Given a map-able value and a closure, set it as its writer.  If the
# given value is not map-able then the closure is ignored.
#
# Stack: ( VAL CLS -- VAL )

instruction msetw ()
  code
    PVM_VAL_SET_WRITER (JITTER_UNDER_TOP_STACK (), JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: mgetsel
#
# Given a map-able value in the TOS, push the number of elements to
# which its mapping is bounded to.  If the value is not mapped, or
# if it is not bounded by number of elements, push PVM_NULL.
#
# Note that only array values can have mappings bounded by number of
# elements.
#
# Stack: ( VAL -- VAL ULONG )

instruction mgetsel ()
  code
    JITTER_PUSH_STACK (PVM_VAL_ELEMS_BOUND (JITTER_TOP_STACK ()));
  end
end

# Instruction: msetsel
#
# Given a map-able value and an unsigned long, set it as the mapping
# bound by number of elements.  If the value is not map-able the
# unsigned long is ignored.
#
# Note that only array values can have mappings bounded by number of
# elements.
#
# Stack: ( VAL ULONG -- VAL )

instruction msetsel ()
  code
    PVM_VAL_SET_ELEMS_BOUND (JITTER_UNDER_TOP_STACK (), JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end

# Instruction: mgetsiz
#
# Given a map-able value in the TOS, push its mapping size-bound as a
# bit-offset.  If the value is not map-able, or if it is not bounded
# by size, push PVM_NULL.
#
# Note that only array values can have mappings bounded by size.
#
# Stack: ( VAL -- VAL ULONG )

instruction mgetsiz ()
  code
    JITTER_PUSH_STACK (PVM_VAL_SIZE_BOUND (JITTER_TOP_STACK ()));
  end
end

# Instruction: msetsiz
#
# Given a map-able value and a bit-offset, set it as the mapping
# size-bound.  If the value is not map-able, the bit-offset is
# ignored.
#
# Note that only array values can have mappings bounded by size.
#
# Stack: ( VAL ULONG -- VAL )

instruction msetsiz ()
  code
    PVM_VAL_SET_SIZE_BOUND (JITTER_UNDER_TOP_STACK (), JITTER_TOP_STACK ());
    JITTER_DROP_STACK ();
  end
end


## Type related instructions

# Instruction: isa
#
# Given a value and a type, push 1 on the stack if the value is of the
# given type.  Push 0 otherwise.
#
# Stack: ( VAL TYPE -- TYPE VAL INT )

instruction isa ()
  code
    pvm_val type = JITTER_TOP_STACK ();
    pvm_val val = JITTER_UNDER_TOP_STACK ();
    pvm_val val_type = pvm_typeof (val);

    JITTER_PUSH_STACK (PVM_MAKE_INT (pvm_type_equal_p (type, val_type),
                                     32));
  end
end

# Instruction: typof
#
# Given a value that is not itself a type, push its type on the stack.
# Given a value that is a type, push the value on the stack.
#
# Stack: ( VAL -- VAL TYPE )

instruction typof ()
  code
    JITTER_PUSH_STACK (pvm_typeof (JITTER_TOP_STACK ()));
  end
end

# Instruction: isty
#
# Given a value, push 1 on the stack if it is a PVM type.
# Push 0 otherwise.
#
# Stack: ( TYPE -- TYPE INT )

instruction isty ()
  code
    int is_type_p = PVM_IS_TYP (JITTER_TOP_STACK ());

    JITTER_PUSH_STACK (PVM_MAKE_INT (is_type_p, 32));
  end
end

# Instruction: tyisi
#
# Given a type, push 1 on the stack if it is an int.
# Push 0 otherwise.
#
# Stack: ( TYPE -- TYPE INT )

instruction tyisi ()
  code
    pvm_val typ = JITTER_TOP_STACK ();
    int isi_p
      = PVM_VAL_TYP_CODE (typ) == PVM_TYPE_INTEGRAL
        && PVM_VAL_INT (PVM_VAL_TYP_I_SIGNED_P (typ))
        && PVM_VAL_ULONG (PVM_VAL_TYP_I_SIZE (typ)) <= 32;

    JITTER_PUSH_STACK (PVM_MAKE_INT (isi_p, 32));
  end
end

# Instruction: tyisiu
#
# Given a type, push 1 on the stack if it is an uint.
# Push 0 otherwise.
#
# Stack: ( TYPE -- TYPE INT )

instruction tyisiu ()
  code
    pvm_val typ = JITTER_TOP_STACK ();
    int isiu_p
      = PVM_VAL_TYP_CODE (typ) == PVM_TYPE_INTEGRAL
        && !PVM_VAL_INT (PVM_VAL_TYP_I_SIGNED_P (typ))
        && PVM_VAL_ULONG (PVM_VAL_TYP_I_SIZE (typ)) <= 32;

    JITTER_PUSH_STACK (PVM_MAKE_INT (isiu_p, 32));
  end
end

# Instruction: tyisl
#
# Given a type, push 1 on the stack if it is a long.
# Push 0 otherwise.
#
# Stack: ( TYPE -- TYPE INT )

instruction tyisl ()
  code
    pvm_val typ = JITTER_TOP_STACK ();
    int isl_p
      = PVM_VAL_TYP_CODE (typ) == PVM_TYPE_INTEGRAL
        && PVM_VAL_INT (PVM_VAL_TYP_I_SIGNED_P (typ))
        && PVM_VAL_ULONG (PVM_VAL_TYP_I_SIZE (typ)) > 32;

    JITTER_PUSH_STACK (PVM_MAKE_INT (isl_p, 32));
  end
end

# Instruction: tyislu
#
# Given a type, push 1 on the stack if it is an ulong.
# Push 0 otherwise.
#
# Stack: ( TYPE -- TYPE INT )

instruction tyislu ()
  code
    pvm_val typ = JITTER_TOP_STACK ();
    int islu_p
      = PVM_VAL_TYP_CODE (typ) == PVM_TYPE_INTEGRAL
        && !PVM_VAL_INT (PVM_VAL_TYP_I_SIGNED_P (typ))
        && PVM_VAL_ULONG (PVM_VAL_TYP_I_SIZE (typ)) > 32;

    JITTER_PUSH_STACK (PVM_MAKE_INT (islu_p, 32));
  end
end

# Instruction: tyiso
#
# Given a type, push 1 on the stack if it is an offset.  Push 0
# otherwise.
#
# Stack: ( TYPE -- TYPE INT )

instruction tyiso ()
  code
    pvm_val typ = JITTER_TOP_STACK ();
    int isoff_p = PVM_VAL_TYP_CODE (typ) == PVM_TYPE_OFFSET;

    JITTER_PUSH_STACK (PVM_MAKE_INT (isoff_p, 32));
  end
end

# Instruction: tyiss
#
# Given a type, push 1 on the stack if it is a string.  Push 0
# otherwise.
#
# Stack: ( TYPE -- TYPE INT )

instruction tyiss ()
  code
    pvm_val typ = JITTER_TOP_STACK ();
    int isstr_p = PVM_VAL_TYP_CODE (typ) == PVM_TYPE_STRING;

    JITTER_PUSH_STACK (PVM_MAKE_INT (isstr_p, 32));
  end
end

# Instruction: tyisa
#
# Given a type, push 1 on the stack if it is an array.  Push 0
# otherwise.
#
# Stack: ( TYPE -- TYPE INT )

instruction tyisa ()
  code
    pvm_val typ = JITTER_TOP_STACK ();
    int isarr_p = PVM_VAL_TYP_CODE (typ) == PVM_TYPE_ARRAY;

    JITTER_PUSH_STACK (PVM_MAKE_INT (isarr_p, 32));
  end
end

# Instruction: tyisc
#
# Given a type, push 1 on the stack if it is a closure.  Push 0
# otherwise.
#
# Stack: ( TYPE -- TYPE INT )

instruction tyisc ()
  code
    pvm_val typ = JITTER_TOP_STACK ();
    int iscls_p = typ == PVM_NULL ? 1
                                  : PVM_VAL_TYP_CODE (typ) == PVM_TYPE_CLOSURE;

    JITTER_PUSH_STACK (PVM_MAKE_INT (iscls_p, 32));
  end
end

# Instruction: tyissct
#
# Given a type, push 1 on the stack if it is a struct.  Push 0
# otherwise.
#
# Stack: ( TYPE -- TYPE INT )

instruction tyissct ()
  code
    pvm_val typ = JITTER_TOP_STACK ();
    int issct_p = PVM_VAL_TYP_CODE (typ) == PVM_TYPE_STRUCT;

    JITTER_PUSH_STACK (PVM_MAKE_INT (issct_p, 32));
  end
end

# Instruction: tyisv
#
# Given a type, push 1 on the stack if it is a void.  Push 0
# otherwise.
#
# Stack: ( TYPE -- TYPE INT)

instruction tyisv ()
  code
    pvm_val typ = JITTER_TOP_STACK ();
    int isv_p = PVM_VAL_TYP_CODE (typ) == PVM_TYPE_VOID;

    JITTER_PUSH_STACK (PVM_MAKE_INT (isv_p, 32));
  end
end

# Instruction: mktyv
#
# Build a "void" type and push it on the stack.
#
# Stack: ( -- TYPE )

instruction mktyv ()
  code
    JITTER_PUSH_STACK (pvm_make_void_type ());
  end
end

# Instruction: mktyi
#
# Given an unsigned long denoting a bit width, and an unsigned int
# denoting signedness (0 is unsigned, 1 is signed), build a an
# integral type with these features and push it on the stack.
#
# Stack: ( ULONG UINT -- TYPE )

instruction mktyi ()
  code
    pvm_val size = JITTER_UNDER_TOP_STACK ();
    pvm_val signed_p = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    JITTER_TOP_STACK () = pvm_make_integral_type (size, signed_p);
  end
end

# Instruction: tyigetsz
#
# Given an integral type, push its size (in bits) to the stack.
#
# Stack: ( ITYPE -- ITYPE ULONG )
instruction tyigetsz ()
  code
    pvm_val size = PVM_VAL_TYP_I_SIZE (JITTER_TOP_STACK ());

    JITTER_PUSH_STACK (size);
  end
end

# Instruction: tyigetsg
#
# Given an integral type, push its sign to the stack.  0 means
# unsigned and 1 means signed.
#
# Stack: ( ITYPE -- ITYPE INT )
instruction tyigetsg ()
  code
    pvm_val sign = PVM_VAL_TYP_I_SIGNED_P (JITTER_TOP_STACK ());

    JITTER_PUSH_STACK (sign);
  end
end

# Instruction: mktys
#
# Push a string type on the stack.
#
# Stack: ( -- TYPE )

instruction mktys ()
  code
    JITTER_PUSH_STACK (pvm_make_string_type ());
  end
end

# Instruction: mktyo
#
# Given a base integral type and an ulong denoting an offset unit
# (multiple of the base unit) construct an offset type having these
# features, and push it on the stack.
#
# Stack: ( TYPE ULONG -- TYPE )

instruction mktyo ()
  code
    pvm_val base_type, unit;

    unit = JITTER_TOP_STACK ();
    base_type = JITTER_UNDER_TOP_STACK ();
    JITTER_DROP_STACK ();
    JITTER_DROP_STACK ();
    JITTER_PUSH_STACK (pvm_make_offset_type (base_type, unit,
                                             PVM_NULL /* ref_type */));
  end
end

# Instruction: tyogetm
#
# Given an offset type, push type of magnitude to the stack.
#
# Stack : ( OTYPE -- OTYPE ITYPE)

instruction tyogetm ()
  code
    JITTER_PUSH_STACK (PVM_VAL_TYP_O_BASE_TYPE (JITTER_TOP_STACK ()));
  end
end

# Instruction: tyogetu
#
# Given an offset type, push unit value to the stack.
#
# Stack : ( OTYPE -- OTYPE ULONG)

instruction tyogetu ()
  code
    JITTER_PUSH_STACK (PVM_VAL_TYP_O_UNIT (JITTER_TOP_STACK ()));
  end
end

# Instruction: tyogetrt
#
# Given an offset type, push the referred type to the stack.
# This can be PVM_NULL if the offset type isn't a reference.
#
# Stack: ( OTYPE -- OTYPE TYPE )

instruction tyogetrt ()
  code
    JITTER_PUSH_STACK (PVM_VAL_TYP_O_REF_TYPE (JITTER_TOP_STACK ()));
  end
end

# Instruction: tyosetrt
#
# Given an offset type and a referred type, make the offset type
# a referring type.  The referred type can be PVM_NULL.  In this
# case the resulting offset type is not a referring offset type.
#
# Stack: ( OTYPE TYPE -- OTYPE )

instruction tyosetrt ()
  code
    PVM_VAL_TYP_O_REF_TYPE (JITTER_UNDER_TOP_STACK ())
      = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();
  end
end

# Instruction: mktya
#
# Given an elements type and a bounder closure, build an array type
# having these features and push it on the stack.  The bounder closure
# can return either PVM_NULL, or an integer, or an offset as the boundary
# of the array type.
#
# Stack: ( TYPE BOUNDER -- TYPE )

instruction mktya ()
  code
     pvm_val bounder = JITTER_TOP_STACK ();
     pvm_val etype = JITTER_UNDER_TOP_STACK ();

     JITTER_DROP_STACK ();
     JITTER_TOP_STACK () = pvm_make_array_type (etype, bounder);
  end
end

# Instruction: tyagett
#
# Given an array type, push the type of its elements on the stack.
#
# Stack: ( TYPE -- TYPE TYPE )

instruction tyagett ()
  code
    JITTER_PUSH_STACK (PVM_VAL_TYP_A_ETYPE (JITTER_TOP_STACK ()));
  end
end

# Instruction: tyagetb
#
# Given an array type, push its bound on the stack.
#
# Stack: ( TYPE -- TYPE (ULONG|NULL) )

instruction tyagetb ()
  code
    JITTER_PUSH_STACK (PVM_VAL_TYP_A_BOUND (JITTER_TOP_STACK ()));
  end
end

# Instruction: tyasetb
#
# Given an array ARR and a closure BOUND, set the later as the array's
# bounder function.  This is a function that, once executed with no
# arguments, returns the size of the array or null.
#
# Stack: ( TYPE BOUND -- TYPE )

instruction tyasetb ()
  code
    pvm_val type = JITTER_UNDER_TOP_STACK ();

    PVM_ASSERT (PVM_VAL_TYP_CODE (type) == PVM_TYPE_ARRAY);
    PVM_VAL_TYP_A_BOUND (type) = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();
  end
end

# Instruction: mktyc
#
# Given a list of argument types, a return type and a number of
# arguments, build a closure type and push it on the stack.
#
# Stack: ( TYPE... TYPE ULONG -- TYPE )

instruction mktyc ()
  code
    size_t i;
    pvm_val nargs, rtype, *atypes;

    nargs = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    rtype = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    pvm_allocate_closure_attrs (nargs, &atypes);

    for (i = 0; i < PVM_VAL_ULONG (nargs); ++i)
    {
      atypes[i] = JITTER_TOP_STACK ();
      JITTER_DROP_STACK ();
    }

    JITTER_PUSH_STACK (pvm_make_closure_type (rtype,
                                              nargs, atypes));
  end
end

# Instruction: mktysct
#
# Given a list of field descriptors and a number of fields, build
# build a struct type and push it on the stack.
#
# Each field descriptor has the form [STRING TYPE] and contains the
# name of the field and its type.
#
# Stack: ( [STRING TYPE]... ULONG -- TYPE )

instruction mktysct ()
  code
    size_t i;
    pvm_val nelem, *etypes, *enames;

    nelem = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();

    pvm_allocate_struct_attrs (nelem, &etypes, &enames);

    for (i = 0; i < PVM_VAL_ULONG (nelem); ++i)
    {
      enames[PVM_VAL_ULONG (nelem) - i - 1] = JITTER_UNDER_TOP_STACK ();
      etypes[PVM_VAL_ULONG (nelem) - i - 1] = JITTER_TOP_STACK ();

      JITTER_DROP_STACK ();
      JITTER_DROP_STACK ();
    }

    JITTER_PUSH_STACK (pvm_make_struct_type (nelem, enames, etypes));
  end
end

# Instruction: tysctgetc
#
# Given a struct type, push its constructor closure to the stack. If
# no constructor closure is installed in the type, push PVM_NULL.
#
# Stack: ( TYP -- TYP CLS|null )

instruction tysctgetc ()
  code
    pvm_val type = JITTER_TOP_STACK ();
    pvm_val constructor = PVM_VAL_TYP_S_CONSTRUCTOR (type);

    JITTER_PUSH_STACK (constructor);
  end
end

# Instruction: tysctsetc
#
# Given a struct type and a closure, install it as the type's
# constructor.
#
# Stack: ( TYP CLS -- TYP )

instruction tysctsetc ()
  code
    pvm_val type = JITTER_UNDER_TOP_STACK ();
    pvm_val constructor = JITTER_TOP_STACK ();

    PVM_VAL_TYP_S_CONSTRUCTOR (type) = constructor;
    JITTER_DROP_STACK ();
  end
end

# Instruction: tysctgetn
#
# Given a struct type, push its name to the stack.  If the struct
# type is not named push PVM_NULL.
#
# Stack: ( TYP -- TYP STR )

instruction tysctgetn ()
  code
    pvm_val type = JITTER_TOP_STACK ();
    pvm_val type_name = PVM_VAL_TYP_S_NAME (type);

    JITTER_PUSH_STACK (type_name);
  end
end

# Instruction: tysctsetn
#
# Given a struct type and a string, set the string as the new
# name of the type.
#
# Stack: ( TYP STR -- TYP )

instruction tysctsetn ()
  code
    pvm_val name = JITTER_TOP_STACK ();
    pvm_val type = JITTER_UNDER_TOP_STACK ();

    JITTER_DROP_STACK ();
    PVM_VAL_TYP_S_NAME (type) = name;
  end
end

# Instruction: tysctgetnf
#
# Given a struct type, push its number of fields to the stack.
#
# Stack: ( SCT -- SCT ULONG )

instruction tysctgetnf ()
  code
    pvm_val type = JITTER_TOP_STACK ();
    pvm_val type_nfields = PVM_VAL_TYP_S_NFIELDS (type);

    JITTER_PUSH_STACK (type_nfields);
  end
end

# Instruction: tysctgetfn
#
# Given a struct type and an index, push the field name to the stack.
# If the field is not named push PVM_NULL.
#
# Stack: ( SCT ULONG -- SCT ULONG STR )

instruction tysctgetfn ()
  code
    pvm_val type = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();
    pvm_val *field_names = PVM_VAL_TYP_S_FNAMES (type);

    JITTER_PUSH_STACK (field_names[PVM_VAL_ULONG (index)]);
  end
end

# Instruction: tysctgetft
#
# Given a struct type and an index, push the field type to the stack.
#
# Stack: ( SCT ULONG -- SCT ULONG TYP )

instruction tysctgetft ()
  code
    pvm_val type = JITTER_UNDER_TOP_STACK ();
    pvm_val index = JITTER_TOP_STACK ();
    pvm_val *field_types = PVM_VAL_TYP_S_FTYPES (type);

    JITTER_PUSH_STACK (field_types[PVM_VAL_ULONG (index)]);
  end
end


## IO instructions

# Instruction: write
#
# If the value at the TOS is mapped, then write it to its associated
# IO space.  Otherwise, this is a no-op.
#
# Stack: ( VAL -- VAL )
# Exceptions: PVM_E_IOS_FULL, PVM_E_CONSTRAINT_ERROR

instruction write ()
  caller
  branching # because of PVM_CALL
  code
     pvm_val val = JITTER_TOP_STACK ();
     pvm_val writer = pvm_val_writer (val);

     if (writer != PVM_NULL)
     {
        JITTER_DUP_STACK ();                      /* VAL VAL */
        JITTER_PUSH_STACK (PVM_VAL_OFFSET (val)); /* VAL VAL OFF */
        PVM_CALL (writer);
      }
  end
end

# Instruction: peeki NENC,ENDIAN,BITS
#
# Given an IOS descriptor and a bit-offset, peek an integer value of
# width BITS bits.  The negative encoding and endianness to be used
# are specified in the instruction arguments.
#
# If there is a problem performing the operation, this function
# pushes an exception in the stack.  Otherwise, it pushes the
# peeked value and PVM_NULL.
#
# Stack: ( INT ULONG -- [INT] EXCEPTION|null )

instruction peeki (?n nenc_printer,?n endian_printer,?n bits_printer)
  code
    PVM_PEEK (int, int, JITTER_ARGN0, JITTER_ARGN1, JITTER_ARGN2,
              PVM_IOS_ARGS_INT);
  end
end

# Instruction: peekiu ENDIAN,BITS
#
# Given an IOS descriptor and a bit-offset, peek an unsigned integer
# value of width BITS bits.  The endianness to be used is specified in
# the instruction arguments.
#
# If there is a problem performing the operation, this function
# pushes an exception in the stack.  Otherwise, it pushes the
# peeked value and PVM_NULL.
#
# Stack: ( INT ULONG -- [INT] EXCEPTION|null )

instruction peekiu (?n endian_printer,?n bits_printer)
  code
   PVM_PEEK (uint, uint, 0 /* unused */, JITTER_ARGN0, JITTER_ARGN1,
             PVM_IOS_ARGS_UINT);
  end
end

# Instruction: peekl NENC,ENDIAN,BITS
#
# Given an IOS descriptor and a bit-offset, peek a long value of width
# BITS bits.  The negative encoding and endianness to be used are
# specified in the instruction arguments.
#
# If there is a problem performing the operation, this function
# pushes an exception in the stack.  Otherwise, it pushes the
# peeked value and PVM_NULL.
#
# Stack: ( INT ULONG -- [LONG] EXCEPTION|null )

instruction peekl (?n nenc_printer,?n endian_printer,?n bits_printer)
  code
    PVM_PEEK (long, int, JITTER_ARGN0, JITTER_ARGN1, JITTER_ARGN2,
              PVM_IOS_ARGS_INT);
  end
end

# Instruction: peeklu ENDIAN,BITS
#
# Given an IOS descriptor and a bit-offset, peek an unsigned long value
# of width BITS bits.  The endianness to be used is specified in the
# instruction arguments.
#
# If there is a problem performing the operation, this function
# pushes an exception in the stack.  Otherwise, it pushes the
# peeked value and PVM_NULL.
#
# Stack: ( INT ULONG -- [ULONG] EXCEPTION|null )

instruction peeklu (?n endian_printer,?n bits_printer)
  code
   PVM_PEEK (ulong, uint, 0 /* unused */, JITTER_ARGN0, JITTER_ARGN1,
             PVM_IOS_ARGS_UINT);
  end
end

# Instruction: peekdi BITS
#
# Given an IOS descriptor and a bit-offset, peek an integer value of
# width BITS bits.  Use the default endianness and negative encoding.
#
# If there is a problem performing the operation, this function
# pushes an exception in the stack.  Otherwise, it pushes the
# peeked value and PVM_NULL.
#
# Stack: ( INT ULONG -- [INT] EXCEPTION|null )

instruction peekdi (?n bits_printer)
  code
    PVM_PEEK (int, int, PVM_STATE_RUNTIME_FIELD (nenc),
              PVM_STATE_RUNTIME_FIELD (endian),
              JITTER_ARGN0, PVM_IOS_ARGS_INT);
  end
end

# Instruction: peekdiu BITS
#
# Given an IOS descriptor and a bit-offset, peek an unsigned integer
# value of width BITS bits.  Use the default endianness.
#
# If there is a problem performing the operation, this function
# pushes an exception in the stack.  Otherwise, it pushes the
# peeked value and PVM_NULL.
#
# Stack: ( INT ULONG -- [UINT] EXCEPTION|null )

instruction peekdiu (?n bits_printer)
  code
    PVM_PEEK (uint, uint, PVM_STATE_RUNTIME_FIELD (nenc),
              PVM_STATE_RUNTIME_FIELD (endian),
              JITTER_ARGN0, PVM_IOS_ARGS_UINT);
  end
end

# Instruction: peekdl BITS
#
# Given an IOS descriptor and a bit-offset, peek a long value of width
# BITS bits.  Use the default endianness and negative encoding.
#
# If there is a problem performing the operation, this function
# pushes an exception in the stack.  Otherwise, it pushes the
# peeked value and PVM_NULL.
#
# Stack: ( INT ULONG -- [LONG] EXCEPTION|null )

instruction peekdl (?n bits_printer)
  code
    PVM_PEEK (long, int, PVM_STATE_RUNTIME_FIELD (nenc),
              PVM_STATE_RUNTIME_FIELD (endian),
              JITTER_ARGN0, PVM_IOS_ARGS_INT);
  end
end

# Instruction: peekdlu BITS
#
# Given an IOS descriptor and a bit-offset, peek an unsigned long value
# of width BITS bits.  Use the default endianness.
#
# If there is a problem performing the operation, this function
# pushes an exception in the stack.  Otherwise, it pushes the
# peeked value and PVM_NULL.
#
# Stack: ( INT ULONG -- [ULONG] EXCEPTION|null )

instruction peekdlu (?n bits_printer)
  code
    PVM_PEEK (ulong, uint, PVM_STATE_RUNTIME_FIELD (nenc),
              PVM_STATE_RUNTIME_FIELD (endian),
              JITTER_ARGN0, PVM_IOS_ARGS_UINT);
  end
end

# Instruction: pokei NENC,ENDIAN,BITS
#
# Given an IOS descriptor, a bit-offset and an integer value of BITS
# bits, poke it.  Use the negative encoding and endianness specified
# in the instruction arguments.
#
# In case of an error, this instruction pushes an exception describing
# the error condition.  Otherwise it pushes PVM_NULL.
#
# Stack: ( INT ULONG INT -- EXCEPTION|null )

instruction pokei (?n nenc_printer,?n endian_printer,?n bits_printer)
  code
    PVM_POKE (INT, int, JITTER_ARGN0, JITTER_ARGN1, JITTER_ARGN2,
              PVM_IOS_ARGS_WRITE_INT);
  end
end

# Instruction: pokeiu ENDIAN,BITS
#
# Given an IOS descriptor, a bit-offset and an unsigned integer value
# of BITS bits, poke it.  Use the endianness specified in the
# instruction arguments.
#
# In case of an error, this instruction pushes an exception describing
# the error condition.  Otherwise it pushes PVM_NULL.
#
# Stack: ( INT ULONG INT -- EXCEPTION|null )

instruction pokeiu (?n endian_printer,?n bits_printer)
  code
   PVM_POKE (UINT, uint, 0 /* unused */, JITTER_ARGN0, JITTER_ARGN1,
             PVM_IOS_ARGS_WRITE_UINT);
  end
end

# Instruction: pokel NENC,ENDIAN,BITS
#
# Given an IOS descriptor, a bit-offset and a long value of BITS bits,
# poke it.  Use the negative encoding and endianness specified in the
# instruction arguments.
#
# In case of an error, this instruction pushes an exception describing
# the error condition.  Otherwise it pushes PVM_NULL.
#
# Stack: ( INT ULONG LONG -- EXCEPTION|null )

instruction pokel (?n nenc_printer,?n endian_printer,?n bits_printer)
  code
    PVM_POKE (LONG, int, JITTER_ARGN0, JITTER_ARGN1, JITTER_ARGN2,
              PVM_IOS_ARGS_WRITE_INT);
  end
end

# Instruction: pokelu ENDIAN,BITS
#
# Given an IOS descriptor, a bit-offset and an unsigned long value of
# BITS bits, poke it.  Use the endianness specified in the instruction
# arguments.
#
# In case of an error, this instruction pushes an exception describing
# the error condition.  Otherwise it pushes PVM_NULL.
#
# Stack: ( INT ULONG ULONG -- EXCEPTION|null)

instruction pokelu (?n endian_printer,?n bits_printer)
  code
   PVM_POKE (ULONG, uint, 0 /* unused */, JITTER_ARGN0, JITTER_ARGN1,
             PVM_IOS_ARGS_WRITE_UINT);
  end
end

# Instruction: pokedi BITS
#
# Given an IOS descriptor, a bit-offset and an integer of BITS bits,
# poke it.  Use the default negative encoding and endianness.
#
# In case of an error, this instruction pushes an exception describing
# the error condition.  Otherwise it pushes PVM_NULL.
#
# Stack: ( INT ULONG INT -- EXCEPTION|null )

instruction pokedi (?n bits_printer)
  code
    PVM_POKE (INT, int, PVM_STATE_RUNTIME_FIELD (nenc),
              PVM_STATE_RUNTIME_FIELD (endian),
              JITTER_ARGN0, PVM_IOS_ARGS_WRITE_INT);
  end
end

# Instruction: pokediu BITS
#
# Given an IOS descriptor, a bit-offset and an unsigned integer of BITS
# bits, poke it.  Use the default endianness.
#
# In case of an error, this instruction pushes an exception describing
# the error condition.  Otherwise it pushes PVM_NULL.
#
# Stack: ( INT ULONG UINT -- EXCEPTION|null )

instruction pokediu (?n bits_printer)
  code
    PVM_POKE (UINT, uint, PVM_STATE_RUNTIME_FIELD (nenc),
              PVM_STATE_RUNTIME_FIELD (endian),
              JITTER_ARGN0, PVM_IOS_ARGS_WRITE_UINT);
  end
end

# Instruction: pokedl BITS
#
# Given an IOS descriptor, a bit-offset and a long of BITS bits, poke
# it.  Use the default negative encoding and endianness.
#
# In case of an error, this instruction pushes an exception describing
# the error condition.  Otherwise it pushes PVM_NULL.
#
# Stack: ( INT ULONG LONG -- EXCEPTION|null )

instruction pokedl (?n bits_printer)
  code
    PVM_POKE (LONG, int, PVM_STATE_RUNTIME_FIELD (nenc),
              PVM_STATE_RUNTIME_FIELD (endian),
              JITTER_ARGN0, PVM_IOS_ARGS_WRITE_INT);
  end
end

# Instruction: pokedlu BITS
#
# Given an IOS descriptor, a bit-offset and an unsigned long of BITS
# bits, poke it.  Use the default endianness.
#
# In case of an error, this instruction pushes an exception describing
# the error condition.  Otherwise it pushes PVM_NULL.
#
# Stack: ( INT ULONG ULONG -- EXCEPTION|null )

instruction pokedlu (?n bits_printer)
  code
    PVM_POKE (ULONG, uint, PVM_STATE_RUNTIME_FIELD (nenc),
              PVM_STATE_RUNTIME_FIELD (endian),
              JITTER_ARGN0, PVM_IOS_ARGS_WRITE_UINT);
  end
end


## Exceptions handling instructions

# Instruction: pushe LABEL
#
# Given an Exception struct in the stack, push a handler for it on the
# exceptions stack.  An exception code 0 means any exception.
#
# Stack: ( EXCEPTION -- )
# Exceptions Stack: ( -- EXCEPTION_HANDLER )

instruction pushe (?l)
  code
   struct pvm_exception_handler ehandler;
   pvm_val exception = JITTER_TOP_STACK ();
   pvm_val exception_code = pvm_ref_struct_cstr (exception, pvm_literal_code);

   ehandler.exception = PVM_VAL_INT (exception_code);
   JITTER_DROP_STACK ();
   ehandler.main_stack_height = JITTER_HEIGHT_STACK ();
   ehandler.return_stack_height = JITTER_HEIGHT_RETURNSTACK ();
   ehandler.code = JITTER_ARGP0;
   ehandler.env = PVM_STATE_RUNTIME_FIELD (env);

   JITTER_PUSH_EXCEPTIONSTACK (ehandler);
  end
end

# Instruction: pope
#
# Pop an exception handler from the exceptions stack.
#
# Stack: ( -- )
# Exceptions Stack: ( EXCEPTION_HANDLER -- )

instruction pope ()
  code
    JITTER_DROP_EXCEPTIONSTACK ();
  end
end

# Instruction: raise
#
# Raise the given exception.
#
# Stack: ( EXCEPTION -- )
# Exceptions Stack: ( -- )

instruction raise ()
  branching # because of PVM_RAISE_DIRECT

  # XXX change the generated code to jump to raise instructions like this, rather
  # than using PVM_RAISE_* from instruction bodies.  That will dramatically
  # improve code locality and code size, and reduce the number of taken branches.

  code
    pvm_val exception = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();
    PVM_RAISE_DIRECT (exception);
  end
end

# Instruction: popexite
#
# Pops the exception on the stack and sets it in the VM.
#
# Stack: ( EXCEPTION  -- )
# Exceptions Stack: ( -- )

instruction popexite ()
  code
    PVM_STATE_BACKING_FIELD (exit_exception_value) = JITTER_TOP_STACK ();
    JITTER_DROP_STACK ();
  end
end


## Debugging Instructions

# Instruction: strace DEPTH
#
# Print a debugging trace with the elements of the top of the stack.
# The number of elements to print is specified in DEPTH.  A depth of
# zero means to print the whole stack.
#
# Stack: ( -- )

instruction strace (?n)
  non-relocatable
  code
    int i = 0;
    int num_elems = (int) JITTER_ARGN0;
    int num_elems_in_stack;

    PVM_ASSERT (PVM_STATE_BACKING_FIELD (canary_stack) != NULL);

    num_elems_in_stack = (pvm_val *)JITTER_HEIGHT_STACK ()
                         - (pvm_val *)PVM_STATE_BACKING_FIELD (canary_stack);
    if (num_elems == 0 || num_elems > num_elems_in_stack)
      num_elems = num_elems_in_stack;

    while (i < num_elems)
      {
        pvm_print_val_with_params (PVM_STATE_BACKING_FIELD (vm),
                                   JITTER_AT_DEPTH_STACK (i),
                                   0 /* depth */,
                                   PVM_PRINT_FLAT,
                                   16 /* base */,
                                   2 /* indent */,
                                   0 /* acutoff */,
                                   PVM_PRINT_F_MAPS,
                                   NULL /* exit_exception */);
        pk_puts (pvm_literal_newline);
        i++;
      }
  end
end

# Instruction: rtrace DEPTH
#
# Print a debugging call trace.
# The number of elements to print is specified in DEPTH.  A depth of
# zero means to print the whole call trace.
#
# Stack: ( -- )

instruction rtrace (?n)
  non-relocatable
  code
    RTRACE ((int) JITTER_ARGN0);
  end
end

# Instruction: disas
#
# Print out the disassembling of the program executed by the
# closure in the top of the stack.
#
# Stack: ( CLS -- CLS )

instruction disas ()
  non-relocatable
  code
    pvm_val cls = JITTER_TOP_STACK ();
    pvm_disassemble_program (PVM_VAL_CLS_PROGRAM (cls));
  end
end

# Instruction: note VALUE
#
# This instruction is intended to be used to insert annotations that
# help to understand disassemblies.  Most of the times VALUE is a
# string.
#
# Semantically, this instruction does nothing.
#
# Stack: ( -- )

instruction note (?n pvm_literal_printer)
  code
  end
end

# Instruction: vmdisp
#
# Pushes the current dispatching strategy of current VM to the stack.
#
# Stack: ( -- STR )

instruction vmdisp ()
  code
    JITTER_PUSH_STACK (pvm_make_string (pvm_literal_dispatch_name));
  end
end


## System Interaction Instructions

# Instruction: getenv
#
# This instruction gets the name of an environment variable on the
# stack and pushes the value of the corresponding environment
# variable.  If no variable with the given name is defined on the
# environment, then push PVM_NULL.
#
# Stack: ( STR -- STR STR )

instruction getenv ()
  code
    const char *varname = PVM_VAL_STR (JITTER_TOP_STACK ());
    char *value = pvm_secure_getenv (varname);

    if (value == NULL)
      JITTER_PUSH_STACK (PVM_NULL);
    else
      JITTER_PUSH_STACK (pvm_make_string (value));
  end
end


## Miscellaneous Instructions

# Instruction: nop
#
# Do nothing.
#
# Stack: ( -- )

instruction nop ()
  code
  end
end

# Instruction: rand
#
# Push a pseudo-random integer to the stack.
#
# If the argument is 0U then it is ignored.  Otherwise it is
# used to set the seed for a new sequence of pseudo-random numbers.
#
# Stack: ( UINT -- INT )

instruction rand ()
  code
    unsigned int seed = PVM_VAL_UINT (JITTER_TOP_STACK ());

    if (seed != 0)
      pvm_srandom (seed);
    JITTER_DROP_STACK ();
    JITTER_PUSH_STACK (PVM_MAKE_INT (pvm_random (), 32));
  end
end

# Instruction: time
#
# Push the current system time to the stack in the form of
# two long elements containing the number of seconds
# and nanoseconds since the epoch.
#
# Stack: ( -- LONG(sec) LONG(nsec) )

instruction time ()
  code
    struct timespec ts;

    pvm_gettime (&ts);
    JITTER_PUSH_STACK (PVM_MAKE_LONG (ts.tv_sec, 64));
    JITTER_PUSH_STACK (PVM_MAKE_LONG (ts.tv_nsec, 64));
  end
end

# Instruction: sleep
#
# Sleep for a given number of seconds and nanoseconds.
#
# If the provided number of nanoseconds are not in the range 0 to
# 999999999 or the number of provided seconds is negative, pushes
# -1.
#
# If there is any other error performing the operation then push
# -2.
#
# EINTR is treated as no error currently.
#
# Stack: ( LONG LONG -- LONG LONG INT )

instruction sleep ()
  code
    struct timespec ts;

    ts.tv_sec = PVM_VAL_LONG (JITTER_UNDER_TOP_STACK ());
    ts.tv_nsec = PVM_VAL_LONG (JITTER_TOP_STACK ());

    if (ts.tv_sec < 0 || ts.tv_nsec < 0 || ts.tv_nsec > 999999999)
      JITTER_PUSH_STACK (PVM_MAKE_INT (-1, 32));
    else if (pvm_nanosleep (&ts, NULL) == -1 && errno != EINTR)
    {
      if (errno == EINVAL)
        JITTER_PUSH_STACK (PVM_MAKE_INT (-1, 32));
      else
        JITTER_PUSH_STACK (PVM_MAKE_INT (-2, 32));
    } else
      JITTER_PUSH_STACK (PVM_MAKE_INT (0, 32));
  end
end

# Instruction: gc
#
# Run the PVM garbage collector.
#
# Stack: ( -- )

instruction gc ()
  code
    pvm_alloc_gc ();
  end
end

# Instruction: siz
#
# Given a value, push its size as a bit-offset.
# By convention, the following PVM values have size zero:
#   type, closure, null
#
# Stack: ( VAL -- VAL ULONG )

instruction siz ()
  code
    uint64_t size = pvm_sizeof (JITTER_TOP_STACK ());
    JITTER_PUSH_STACK (PVM_MAKE_ULONG (size, 64));
  end
end

# Instruction: sel
#
# Given a value, push its length as an unsigned long.
#
# The length of an array is the number of values contained in it.
# The length of a struct is the number of fields contained in it.
# The length of a string is the number of characters contained in it.
# The length of any other value is 1.
#
# Stack: ( VAL -- VAL ULONG )

instruction sel ()
  code
    JITTER_PUSH_STACK (pvm_elemsof (JITTER_TOP_STACK ()));
  end
end

### End of instructions


## Peephole optimizations

rule dup-swap-to-dup rewrite
  dup; swap
into
  dup
end

rule dup-nip-to-nop rewrite
  dup; nip
into
end

rule swap-tuck-to-over rewrite
  swap; tuck
into
  over
end

rule swap-drop-to-nip rewrite
  swap; drop
into
  nip
end

rule rot-rot-to-nrot rewrite
  rot; rot
into
  nrot
end

rule nip-nip-to-nip2 rewrite
  nip; nip
into
  nip2
end

rule nip2-nip-to-nip3 rewrite
  nip2; nip
into
  nip3
end

rule drop-drop-to-drop2 rewrite
  drop; drop
into
  drop2
end

rule drop2-drop-to-drop3 rewrite
  drop2; drop
into
  drop3
end

rule drop3-drop-to-drop4 rewrite
  drop3; drop
into
  drop4
end

rule swap-over-to-tuck rewrite
  swap; over
into
  tuck
end

rule rot-swap-to-quake rewrite
  rot; swap
into
  quake
end

rule push-drop-to-nop rewrite
  push $a; drop
into
end
