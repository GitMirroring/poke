#+TITLE: GNU Poke - Hacking Notes
#+AUTHOR: The poke hackers

Welcome, adventurous poker! This file contains useful information for
you.

Copyright (C) 2019-2024 The poke authors.

This file is part of GNU poke.

GNU poke is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

GNU poke is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU poke.  If not, see <https://www.gnu.org/licenses/>.

* Coding Style and Conventions
* Writing Documentation

** Documenting Pickles

   The chapter =Pickles= in the Poke manual contains several sections
   organized in thematic areas.  When adding a new pickle, find the
   area appropriate for the abstractions provided by the pickle (or
   create one if it doesn't exist already) and add a section for it.

   Please make sure to document any dependency of your pickle to other
   pickles.

   Keep a tutorial-like tone: for fine details, the user can always go
   and look to the pickle directly.

* Maintenance

  This section describes =make= targets that performs several
  maintenance tasks.

  - syntax-check ::
    Run several syntax-related checks in the source files.  It is
    useful to run this target before submitting code to be reviewed,
    and while reviewing other people's code.

    Note that sometimes the results have to be taken with a pinch of
    salt.  This happens, for example, when a rule oriented to C is
    applied to, say, an AWK file.  In these cases, consider adding a
    =.x-sc_*= fine-tuning file.  But please ask in poke-devel first.

    We provide a pre-push git hook that performs the syntax check
    right before pushing. If the check fails, the push is aborted. You
    should consider enabling this check by coping
    =etc/git-hooks/pre-push= to =.git/hooks/=.
  - coverage ::
    This target builds *poke* with code coverage support, runs the
    testsuite, and generates a nice html report under
    =$(top_builddir)/doc/coverage/=.  It is necessary to have the
    =lcov= program for this to work.  Note also that you need to have jitter
    configured to use a dispatch model other than no-threading.
  - cyclo-poke.html ::
    This target runs the pmccabe utility to calculate the modified
    cyclomatic complexity of the functions composing the poke sources,
    and generates a nice html report.
  - refresh-po ::
    This target download the latest available translations from the
    translation project and installs them in the source tree.
  - update-copyright ::
    Run this rule once per year (usually early in January) to update
    all the copyright years in the project.  By default this excludes
    all variants of COPYING.  Exceptions to this procedure (such as
    =ChangeLog..*= for rotated change logs) can be added in the file
    =.x-update-copyright=.

* Poke Architecture

  This figure depicts the overall architecture of poke:

#+BEGIN_EXAMPLE
  +----------+
  | compiler |
  +----------+      +------+
       |            |      |
       v            |      |
  +----------+      |      |
  |   PVM    | <--->|  IO  |
  +----------+      |      |
       ^            |      |
       |            |      |
       v            +------+
  +----------+
  | command  |
  +----------+
#+END_EXAMPLE

  The compiler, PVM and IO subsystems are provided by a shared library
  =libpoke=.

  The command subsystem resides in the =poke= executable.

* The Poke Compiler
** Compiler Overview

   This figure depicts the architecture of the compiler:

#+BEGIN_EXAMPLE
      /--------\
      | source |
      \---+----/
          |
          v
  +-----------------+
  |      Parser     |
  +-----------------+
  |  analysis and   |
  | transformation  |
  |     phases      |
  +-----------------+
  | code generation |
  |      phase      |
  +-----------------+
  | Macro assembler |
  +-----------------+
          |
          v
     /---------\
     | program |
     \---------/
#+END_EXAMPLE

** The bison Parser in pkl-tab.y

   The only purpose of the bison parser in pkl-tab.y is to do the
   syntactic analysis, build the initial AST, and set the locations of
   the AST nodes.

   Unfortunately, currently it also does some extra work, due to
   limitations in the LARL parser:

   - It builds the compile-time environment and register type, variable
     and function declarations.
   - It annotates variables with their lexical addresses.
   - It links return statements with their containing functions.
   - It annotates return statements with he number of lexical frames they
     should pop before exiting the function.

   As we shall see below, any further analysis and transformations on
   the AST are performed by the compiler phases, which are implemented
   elsewhere.  This greatly helps to keep the parser code clean and
   easy to read, and also eases changing the syntactic structure of
   poke programs.

** The AST

   The compiler operates on an abstract syntax tree that represent the
   program being compiled.  The following subsections discuss some
   useful aspects of the structure of the AST.

*** loop_stmt

    Loop statements are represented with trees like:

    : loop_stmt
    : |
    : +-- [iterator]
    : |       |
    : |       +-- decl
    : |       +-- container
    : |
    : +-- [condition]
    : +-- body

    Different kind of loop statements supported in Poke are
    represented including or not including optional fields.

    =while= statements with a condition:

    : while (CONDITION) BODY

    are represented as:

    : loop_stmt
    :     |
    :     +-- condition
    :     +-- body

    =for= statements without a condition:

    : for (;;) BODY

    are represented as:

    : loop_stmt
    :     |
    :     +-- body

    =for-in= statements:

    : for (VAR in CONTAINER) BODY

    are represented as:

    : loop_stmt
    :     |
    :     +-- iterator
    :     |      |
    :     |      +-- decl (VAR
    :     |      +-- container
    :     |
    :     +-- body

    =for-in-where= statements:

    : for (VAR in CONTAINER where SELECTOR) BODY

    are represented as:

    : loop_stmt
    :     |
    :     +-- iterator
    :     |      |
    :     |      +-- decl (VAR)
    :     |      +-- container
    :     |
    :     +-- condition (SELECTOR)
    :     +-- body

*** try_stmt

    There are several syntactic forms of this statement:

    : try CODE catch HANDLER
    : try CODE catch if EXP HANDLER
    : try CODE catch (ARG) HANDLER
    : try CODE until EXP

    try statements are represented with trees like:

    : try_stmt
    : |
    : +-- try_stmt_body
    : |   |
    : |   +-- code
    : |
    : +-- try_stmt_handler
    : |   |
    : |   +-- code
    : |
    : +-- [arg]
    : +-- [exp]

    where ARG and EXP are exclusive.

*** exp

    Expressions are the application of some *operator* to one or more
    *operators*.  The Poke language supports unary, binary and ternary
    operators.

    Expressions are represented with trees like:

    : exp
    : |
    : +-- code
    : +-- attr
    : +-- flag
    : +-- numops
    : +-- operands[3]
    :     |
    :     +-- [operand]
    :     +-- [operand]
    :     +-- [operand]

    Where =code= identifies the operator of the expression.  Operators
    are defined in the =libpoke/pkl-ops.def= file.

    If the operator is an attribute, then =attr= identifies the
    invoked attribute.  Attributes are defined in the
    =libpoke/pkl-attrs.def= file.  This field =attr= is initialized in
    the =trans1= phase.

    The =exp= AST node is used for all the Poke unary and binary
    operators, which only use two of the =operands=.

    Additionally, the application of an attribute to which an argument
    is passed, like in:

    : foo'elem (1)

    is encoded as an =exp= node with three operands: the first operand
    holds =foo=, the second operand an identifier for the attribute
    =elem= and the third operand the expression passed to the
    attribute (in this case =1=).  A handler in =trans1= transforms
    this ternary expression node in a binary expression, filling
    =attr= in the process.

    Note that the Poke ternary conditional operator =? := is *not*
    implemented using =exp= nodes, but =cond_exp= AST nodes.

*** cond_exp

    This AST node is used to encode Poke's ternary conditional
    operator, which looks like:

    : cond_exp ? then_exp : else_exp

    It uses trees like this:

    : cond_exp
    : |
    : +-- cond
    : +-- thenexp
    : +-- elseexp

** Lexical Handling

The parser needs to build the lexical enviroment as it works through
the source code.  This is because it needs to find the declarations of
all the entities referenced by variable names.  Also, the Poke syntax
requires to determine whether a given identifier is a type name or
not.  It uses a =pkl-env= for this, and it pushes and pops frames
according to the language rules.  The parser annotates each variable
reference with the declaration of the entity being referred, but does
not set the variable's lexical address.  This is because this address
may not be final, as we shall see below.  Once the parsing is done
successfully the lexical environment should consist on just the
top-level definitions, which is kept for the rest of the compilation.
But the inner frames are no longer available.

After the parser, the front-end compiler passes are run.  This
includes analysis and checking of language rules, transformation, type
analysis, constant folding, etc.  These passes can do arbitrary
transformations of the tree, and some of these transformations can
alter the lexical structure of the program.  The only exception is the
top-level environment.  Therefore, these passes shall not rely on the
lexical structure.

Finally, just before the code generator, a lexical pass is run.  This
pass contains a =transl= phase.  At this point no further
transformations of the AST will be performed and it is final.  The
=transl= phase reconstructs the lexical environment (the top-level
environment is preserved) and assigns the lexical addresses (back,
over) to all variable references.  It also performs a few language
rules checks that rely on the relative lexical position of entities.

** Compiler Passes and Phases

   These are the phases currently implemented in the poke compiler:

#+BEGIN_EXAMPLE
    [parser]
    --- Front-end pass
    trans1     Transformation phase 1.
    anal1      Analysis phase 1.
    typify1    Type analysis and transformation 1.
    promo      Operand promotion phase.
    trans2     Transformation phase 2.
    fold       Constant folding.
    trans3     Transformation phase 3.
    typify2    Type analysis and transformation 2.
    anal2      Analysis phase 2.
    --- Middle-end pass
    fold       Constant folding.
    trans4     Transformation phase 4.
    analf      Analysis final phase.
    --- Back-end pass
    gen        Code generation.
#+END_EXAMPLE

   The phases above are organized in several passes:

   - Pass1 :: trans1 anal1 typify1 promo trans2 fold trans3 typify2 anal2
   - Pass2 :: fold trans4 analf
   - Pass3 :: gen

*** Naming Conventions for Phases

    We use the following convention to name phases:

    : {NAME}{SUFFIX}

    where =NAME= reflects a phase category (see below) and =SUFFIX= is
    usually an integer that specifies the order in which the phases
    are applied.  Thus, for example, =name4= is performed after
    =name1=.  Sometimes, =SUFFIX= is =f= (meaning "final").

    The suffix is not used if there is only one phase in the given
    category.

    We use the following phase categories:

    - anal ::
      For phases whose main purpose is to perform checks on the AST,
      and/or the contents of the AST nodes, and emit errors/warnings.
    - trans ::
      For phases whose main purpose is to alter the structure of the
      AST, and/or the contents of the AST nodes.
    - typify ::
      For phases whose main purpose is to perform type checks, and
      otherwise do work on types.
    - promo ::
      For phases whose main purpose is to perform coercions wherever
      appropriate.  Currently there is only one phase in this
      category.
    - fold ::
      For phases whose main purpose is to pre-compute areas of the AST
      whenever it is possible to do so at compile-time.  Currently
      there is only one phase in this category, that performs constant
      folding.
    - gen ::
      For phases whose main purpose is to generate PVM code.
      Currently there is only one phase in this category.

    The phases in category =NAME= are implemented in the source files
    =libpoke/pkl-NAME.[ch]=.

*** Naming Conventions for Handlers

    We use the following convention to name phase handlers:

    : pkl_PHASE_{ps,pr}_NODE

    where =PHASE= can be a complete phase name (like =typify1=) if the
    handler is to be installed in that phase only, or a phase category
    name (like =typify=) if the handler is to be installed in several
    phases in that category.  If the phase is to be executed in
    pre-order, =pr= follows, otherwise, =ps=.  Finally, =NODE= is the
    name of the AST node.

    For example, the handler:

    : pkl_anal1_ps_comp_stmt

    is installed in the phase =anal1=, executes in post-order, and
    serves the AST nodes with code =PKL_AST_COMP_STMT=.

*** Front and Middle End Handlers should be Re-entrant

    When a type is referenced by name, for example in a map:

    : Foo @ 0#B

    The AST associated with the type is processed again thru the
    compiler middle-end phases.  This means that if a handler modifies
    an AST subtree, it should either do it in a way the new structure
    will be still valid if submitted to the same handler again.

    An example of this is the =pkl_trans1_ps_print_stmt= handler.

    More generally, the front-end and middle-end passes are
    restartable.  This means that every handler in these phases shall
    be re-entrant: if executed more than once, they should do The
    Right Thing (TM).

** Adding Compiler Built-Ins

   [NOTE: now that inline asm statements are supported, built-ins
    are implemented as immutable functions in the compiler runtime
    rt-pkl.pk.]

   Compiler built-ins are predefined functions, provided by the
   compiler, that generate particular assembler instructions.

   The first step in defining a new built-in is to make the lexer to
   recognize tokens of the form =__PKL_BUILTIN_NAME__= where =NAME= is
   some meaningful name, like for example =RAND=:

   : "__PKL_BUILTIN_RAND__" { return BUILTIN_RAND; }

   Then, add a new rule to the rule =comp_stmt= in the bison parser.
   Built-ins are equivalent to compound statements.  For example, this
   is the rule for the rand built-in:

   :      | pushlevel BUILTIN_RAND
   :     {
   :       $$ = pkl_ast_make_builtin (pkl_parser->ast,
   :                                  PKL_AST_BUILTIN_RAND);
   :       PKL_AST_LOC ($$) = @$;
   :
   :       /* Pop the frame pushed by the `pushlevel' above.  */
   :       pkl_parser->env = pkl_env_pop_frame (pkl_parser->env);
   :     }

   Next step is to generate the code for the built-in.  This is done
   expanding the =pkl_gen_ps_comp_stmt= rule in the code generation.
   Keep in mind that the generated code should conform a valid
   function body.  For example, this is the code generation part for
   rand:

   :      case PKL_AST_BUILTIN_RAND:
   :      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_RAND);
   :      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_RETURN);
   :      break;

   : The final step is to define the built-in function proper, in the
   : compiler run-time, in =pkl-rt-1.pk=:

   : fun rand = int<32>: __PKL_BUILTIN_RAND__;

** Writing Compiler Diagnostics

   Please follow the following guidelines when adding new errors or
   warnings to the poke compiler:

   - Make the diagnostic messages self-contained, i.e. do not rely on
     the extra location information to make the error intelligible.
     This is mainly for the sake of accessibility, and also for when
     poke is run in quiet mode.

     This is an example of a bad diagnostic:

     : error: field doesn't exist in struct

     Write something like this instead:

     : error: field `foo' doesn't exist in struct

   - When checking for the type of some ENTITY, please use a two-lines
     error message like:

     : error: invalid ENTITY
     : error: expected EXPECTED_TYPE, got ACTUAL_TYPE

     this is to keep some uniformity.  You can get the written
     representation of a type using the =pkl_type_str= utility
     function.

   - When referring to integer types in diagnostic messages, please
     refer to them as "integrals".

   - Always pass 1 for =use_given_name= when invoking =pkl_type_str=
     unless you need the expanded definition of the type for whatever
     reason (like to show the arguments taken by a function type.)

* The Poke Virtual Machine
** PVM types
*** How =any= is handed in the PVM

    The Poke type =any= is not implemented in the PVM as a PVM type
    value.  Instead, =null= is used to denote it, by convention.

    Note that it is not possible to use =void= to denote the Poke
    =any= type, because of closure types: a closure returning =void=
    is not the same than a closure returning =any=.

** Exception Handling

   Exception types or codes are signed 32-bit integers, and are
   defined in =libpoke/pkl-rt-1.pk= as =EC_*= variables.

   The exceptions themselves are struct values of type Exception, also
   defined in =libpoke/pkl-rt-1.pk=.

   There are two ways an exception can be raised in the PVM:

   - Explicitly, when the instruction =raise= is executed.
   - Implicitly, when some instruction needs to fail.  For example,
     an integer division instruction divides by zero.

   In either case, the treatment of a raised exception is the same:

   1. Pop an exception handler from the exception handler stack.
   2. If the exception handler matches the raised exception type, then
      i. Restore the heights of the main and return stacks.
      ii. Restore the dynamic environment.
      iii. Push the cached exception type to the stack.
      iv. Branch to the exception handler.
   3. Repeat.

   The default exception handler, which catches "unhandled"
   exceptions, is installed by the macro-assembler in
   =libpoke/pkl-asm.c:pkl_asm_new= and
   =libpoke/pkl-asm.c:pkl_asm_finish=.  It calls the function
   =_pkl_exception_handler=, that is defined in the compiler runtime
   in =libpoke/pkl-rt-1.pkl=.

** Signal Handling

   When the PVM is about to execute a program, it installs a signal
   handler that, at the moment, handles =SIGINT=.  This signal handler
   is defined in the =late-c= block in pvm.jitter, and records the
   signal in the PVM internal state.

   Then, when a =sync= instruction is executed, it checks the PVM
   internal state and raises a =PVM_E_SIGNAL= exception if there is
   some pending signal.  The default signal handler just ignores this
   signal, but the user can also intercept it if desired.  The PKL
   compiler generates =sync= instructions in strategic places, such as
   before backward jumps in loops.

   The =exit= PVM instruction clears the pending signals in the
   internal PVM state.

** Offsets and bit-offsets in the PVM

   The PVM supports a =pvm_off= boxed value, to denote pairs of
   magnitudes and units.  Both accessor macros (in =pvm-val.h=) and
   PVM instructions (=ogetm=, =ogetu=) are provided to access their
   components.

   Many other PVM entities need to denote offsets in a way or another.
   For example, struct fields in =pvm_struct= values need to record
   their relative offset with respect the beginning of the struct.

   It may come to mind, quite naturally, to use =pvm_off= values to
   denote these offsets.  It is very elegant.  However, we decided to
   use "bit offsets" instead, stored in 64-bit =pvm_long= values.

   There are two reasons for this:

   - First of all, performance.  It is fairly common to operate with
     the absolute value of these offsets, in bits.  In fact, in most
     cases that is the only purpose of maintaining them.  Having them
     stored in =pvm_off= values means we have to multiply every time
     we want to get their magnitude.  This is a waste, for no good
     reason.
   - To avoid code coupling.  PVM offsets are very cool, but they are
     also complex: the unit is arbitrary.  This means in many cases we
     have to assume the nature of the unit, mainly bits.  This is very
     fragile.

   So, the take-home message is: in the PVM, restrict the presence of
   =pvm_off= values to the ones generated by the code generator.
   Whenever an offset is needed in some internal PVM structure, use
   bit-offsets instead encoded as =ulong<64>= values.

** Writing relocatable instructions

   When operating in non-threaded mode, Jitter likes to move the code
   compiled for instruction bodies around.  This imposes several
   restrictions on what can you have in the instruction bodies:

   - If you call a global function from your instruction, please add
     it to the =wrapped-functions= section in the file.

   - Likewise, if you use a global variable, please add the variable
     to the =wrapped-globals= section.

   - Do not use any constant C string like ="foo"=; these are global
     variables in disguise and you cannot wrap them unless you give
     them a name.

   If you cannot follow the guidelines above for whatever reason,
   please mark the instruction as =non-relocatable= like this:

   : instruction foo ()
   :   non-relocatable
   :   code
   :     ...
   :   end
   : end

   This will prevent Jitter to relocate the instruction body and crash
   in many platforms and non-threading modes.

** Wrapping globals

   The non-threaded Jitter operation modes require every global
   (variable or function) to be wrapped, i.e. specified in sections
   =wrapped-functions= or =wrapped-globals= in =pvm.jitter=.

   Since it is not trivial to keep track of every used global, having
   hundred of instructions, we are providing a syntax-check that looks
   for this automatically.

   In order to avoid false positives, there are two files that we
   maintain by hand:

   - =etc/pvm-wraps-whitelist= contains a list of _global_ symbols
     that are used in pvm.jitter but are not required to be listed in
     neither =wrapped-function= nor =wrapped-globals=.  These are
     variables and functions that, despite being global and undefined,
     are not used _within_ PVM instructions.

  - =etc/pvm-wraps-static-whitelist= contains a list of _static_
    symbols that are defined in pvm.jitter and also listed in either
    =wrapped-functions= or =wrapped-globals=.  This includes for
    example the =pvm_*= wrappers we define in the file, to be used in
    PVM instructions.

*** Wrapping standard function calls

    If we need to call to a standard library function provided by the
    system (such as =printf=, =strstr=, or the like) from the body of
    a PVM instruction, we have to consider the possibility of gnulib
    replacing such function with another having a name like
    =rpl_printf= or =rpl_strstr=.

    Since the =wrapped-functions= list in pvm.jitter is static and the
    referred functions must exist, just wrapping the =rpl_*= symbols
    doesn't work.

    So instead, for every standard function =FOO= we call from PVM
    instructions, we:

    - Create a wrapper for it, called =pvm_FOO=, and put it in the
      pvm-wrappers.[ch] source files.
    - Use =pvm_FOO= in the PVM instruction.
    - Add =pvm_FOO= to the wrapped-functions section in pvm.jitter.

* Memory Management

  Different parts of poke use different strategies for memory
  management:

  - The compiler front-end uses reference counting to handle AST nodes.

  - The PVM uses the Boehm GC collector for values and the run-time
    environment.

  - Everything else uses =malloc=/=free=.

  This sometimes leads to tricky situations, some of which are
  documented in the subsections below.

** Using ASTREF


   The AST uses reference counting in order to manage the memory used
   by the nodes.  Every time you store a pointer to an AST node, you
   should use the =ASTREF= function in order to increase its counter:

   : pkl_ast_node foo = ASTREF (node);

   Note that the =pkl_ast_make_*= constructors do =ASTREF= internally,
   so you don't need to use it in calls like:

   : pkl_ast_node new = pkl_ast_make_struct (ast, 5, elems_node);

   To make sure you get the reference counting right, it's required to
   use the return value of =ASTREF= function. The compiler will warn
   you otherwise.

** Using ASTDEREF

   =ASTDEREF= decreases the reference counter of the provided AST
   node. It's required to use the return value of =ASTDEREF=. The
   compiler will warn you otherwise.

   In practice you will seldom find yourself in the need to use
   =ASTDEREF=.  Just make sure that every =ASTREF= is paired with a
   =pkl_ast_node_free=.

   However, there are situations where =ASTDEREF= is necessary in
   order to avoid a memory leak.  For example, consider
   transformations like =a -> b= to =a -> x -> b=.  In that case, you
   should use something like:

   : b = PKL_AST_KIND_WHAT (node);
   : x = pkl_ast_make_xxx (ast, ASTDEREF (b));
   : PKL_AST_KIND_WHAT (node) = ASTREF (x);

   This works because =pkl_ast_make_xxx= does an =ASTREF= to =b=
   internally.  The final result is that the reference counter of =b=
   doesn't change at all.

** PVM values in PVM programs

   PVM routines (data structures of type =pvm_routine=) are allocated
   by Jitter in complicated data structures, internally relying on
   =malloc=.  Their content is therefore not automatically visible to
   the GC.

   Now, the instructions in a routine can contain literal PVM values,
   and some of these values will be boxed.  For example, the following
   routine contains a pointer to a =pvm_val_box=:

   : ;; Initialize the element index to 0UL, and put it
   : ;; in a local.
   : push ulong<64>0
   : regvar $eidx

   There is only one place where jitter routines are stored in other
   data structures: the PVM program abstraction.

   PVM programs are allocated using =pvm_alloc=, i.e. by the GC.  They
   are composed by a PVM routine and other fields:

   : struct pvm_program
   : {
   :   pvm_routine routine;
   :   [...]
   : }

   However, since =routine= is malloc-allocated, the GC can't traverse
   it.  Consequently, the references to contained boxed values won't
   be accounted for, and these values will be collected if there are
   no more references to them!

   The solution, recommended by Luca Saiu, is to keep an array of
   pointers in the PVM program structure, containing the pointers to
   every boxed value used in =routine=:

   : struct pvm_program
   : {
   :   pvm_routine routine;
   :   void **pointers;
   :   [...]
   : };

   The pointers are collected in the =pvm-program.c= functions that
   append parameters to instructions.

** PVM values in AST nodes

   Storing a PVM value (whose memory is handled by GC) in an AST node
   (reference-counted) leads to a problem: the GC is unable to see the
   reference to values, and will therefore collect the memory if there
   are no other reachable references.

   Let's see an example of this.  Both array and struct types contain
   closures for mappers, writers, bounders, and the like.  For
   example, let's take arrays:

#+BEGIN_EXAMPLE
    struct pkl_ast_type
    {
        ...
        struct
        {
          union pkl_ast_node *bound;
          union pkl_ast_node *etype;
          pvm_val mapper;
          pvm_val writer;
          pvm_val bounder;
        } array;
    }
#+END_EXAMPLE

  In this case, =mapper=, =writer= and =bounder= are managed by GC.
  However, the contained =struct pkl_ast_type= is not.  There is no
  way the GC can find these nodes thru the AST node.

  The solution is to allocate memory for these values as
  "uncollectable".  This is done with =pvm_alloc_uncollectable.  For
  example:

#+BEGIN_EXAMPLE
pkl_ast_node
pkl_ast_make_array_type (pkl_ast ast, pkl_ast_node etype, pkl_ast_node bound)
{
  ...
  /* Prevent GC to collect these PVM values.  */
  PKL_AST_TYPE_A_CLOSURES (type)
      = pvm_alloc_uncollectable (nclosures * sizeof (pvm_val));
  PKL_AST_TYPE_A_MAPPER (type) = PVM_NULL;
  PKL_AST_TYPE_A_WRITER (type) = PVM_NULL;
  PKL_AST_TYPE_A_BOUNDER (type) = PVM_NULL;
  PKL_AST_TYPE_A_CONSTRUCTOR (type) = PVM_NULL;
  PKL_AST_TYPE_A_INTEGRATOR (type) = PVM_NULL;
  PKL_AST_TYPE_A_FORMATER (type) = PVM_NULL;
  PKL_AST_TYPE_A_PRINTER (type) = PVM_NULL;

  return type;
}
#+END_EXAMPLE

  And of course, before the memory of the AST node is freed, the
  uncollectable memory shall be explicitly fred in
  =pkl_ast_node_free=:

#+BEGIN_EXAMPLE
  void
  pkl_ast_node_free (pkl_ast_node ast)
  {
    ...
    case PKL_AST_TYPE:
      switch (PKL_AST_TYPE_CODE (ast))
        {
        ...
        case PKL_TYPE_ARRAY:
          pvm_free_uncollectable (PKL_AST_TYPE_A_CLOSURES (ast));
        }
  }
#+END_EXAMPLE

  If you add PVM values or PVM environments to an AST node, please
  follow the strategy above.

* Terminal Handling
** pk-term

   Writing to the terminal, and getting information from the terminal,
   is handled by the =pk-term= module.  It provides functions to:

   - Write strings to the standard output.

   - Write formatted strings to the standard output, ala =printf=.

   - Handle output "classes", which are the base of styling.

   Out terminal abstraction is implemented of top of GNU libtextstyle.
   In case it is not available when building poke, a dummy stub is
   provided by gnulib.  In that case output won't be styled, but poke
   will still compile and run properly.

** Styling Classes

  Styling is handled using "classes", which are identified by some
  string.  Using =pk_term= calls, enclosed environments can be
  defined:

  : pk_term_class ("foo");
  : /* Text emitted here has class "foo"  */
  : pk_term_class ("bar");
  : /* Text emitted here has class "foo" and "bar" */
  : pk_term_end_class ("bar");
  : pk_term_end_class ("foo");

  The =class= and =end_class= calls should be properly paired.

  The styling classes used in poke should be documented in the user
  manual, so the user will know what is suitable to be configured.
  Also, whenever possible a reasonable default shall be provided in
  =poke-default.css=.

** Debugging Styling

   As recommended in the libtextstyle manual, a good way to see the
   class hierarchy of some given output is to run poke passing the
   =--color=html= option:

   : $ poke --color=html
   : [...]
   : (poke) [1#B,2#B]
   : <span class="array">[<span class="offset"><span class="integer">0x1</span>#B</span>,<span class="offset"><span class="integer">0x2</span>#B</span>]</span><br/>(poke)
