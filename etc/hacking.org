#+TITLE: GNU Poke - Hacking Notes
#+AUTHOR: The poke hackers

Welcome, adventurous poker! This file contains useful information for
you.

Copyright (C) 2019-2024 The poke authors.

This file is part of GNU poke.

GNU poke is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

GNU poke is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU poke.  If not, see <https://www.gnu.org/licenses/>.

* Coding Style and Conventions
** Writing C

   In Poke we follow the GNU Coding Standards.  Please see
   https://www.gnu.org/prep/standards/.

   Additionally, we have a few conventions that we ask you to follow
   when hacking poke, in order to keep a coherent style when possible.
   These are documented in the following subsections.

*** Avoid Tabs

    Please format your code using spaces.  Tabs (Ascii 9) should not
    appear anywhere except in Makefiles.

*** Avoid bool

    C99 defines the type =bool=.  However, in poke we prefer to use
    variables of type =int= in order to hold truth values.  We kindly
    ask you to do the same.

    When documenting functions that receive or return boolean values
    stored in integer variables, please remember that the
    interpretation of the truth values in C is: zero means false, and
    any value other than zero means true.  Avoid referring to 1 to
    mean true.

    Also, please never rely on a boolean to hold exactly 1 or any
    other particular non-zero value, to be interpreted as true.

*** Use _p for Predicates

    We use the venerable convention of using a suffix =_p= (for
    predicate) when naming variables and struct fields that contain
    booleans.

    We do not always do this, but it is especially important in cases
    where the name of the variable is not indicative enough.

*** Documenting Functions in Public Headers

    Function prototypes in headers must be documented using a comment
    block preceding the prototype.

    Start the comment block with a terse short sentence that states
    what the function does.  Then, document the arguments that the
    function takes, and the value it returns, if any.  When referring
    to arguments and other variables in the comment block, please use
    caps.

    It is ok for single comment block to document more than one prototype.

    Please leave an empty line between the comment block and the
    function prototype.

    Example:

#+BEGIN_EXAMPLE
  /* Frobnicate a frob.

     FROB is a frob that should have been previously initialized using
     frob_new.

     LAZY_P is a boolean.  If true, FROB won't be frobnicated
     immediately, but instead marked for later frobnication.

     If the frob cannot be frobnicated, this function returns NULL.
     Otherwise the function returns the given frob.  */

  frob_t frobnicate (frob_t frob, int lazy_p);
  frob_t forbnicate_r (frob_t frob, int lazy_p);
#+END_EXAMPLE

** Writing Poke

   We recommend to use the Emacs mode in =etc/poke-mode.el= to write
   =.pk= files.

   - Do not separate magnitudes and units when writing offsets.  Do it
     like this:

     : 16#B

     instead of:

     : 16 #B

   - Use Camel_Case for type names, but do not use Camel_Case for
     variable/function names!

   - Surround pretty-printed values with =#<= and =>.= This is to
     notify the reader that the value has been pretty-printed.

** Writing RAS

*** RAS Emacs mode

    We recommend to use the Emacs mode in =etc/poke-ras-mode.el= to
    write =.pks= files.

*** Calling compiled Poke from RAS

    A big part of the code generated by the PKL code generator is
    written by hand, in =.pks= files.  Sometimes it is convenient to
    call compiled Poke code from that code; for example, to execute
    complex formulae or to perform some operation defined recursively.

    In these situations, the solution is to first write a Poke
    function in the compiler's runtime library, =pkl-rt*.pk=, like:

    : fun _pkl_foo = (uint<64> ival, uint<64> eval,
    :                 uint<32> ivalw, uint<32> fieldw) uint<64>:
    : {
    :    return ival | (eval <<. (ivalw - fieldw));
    : }

    Then, the function can be invoked from the hand-written RAS file
    using the =.call= directive:

    : .call _pkl_foo

    Note how the compiler internal functions use the =_pkl_= prefix.
    Also note that =.call= can only invoke functions defined in the
    global environment.

* Writing Tests

  The poke testsuites live in the =testsuite/= subdirectory.  This
  section contains useful hints for adding tests there.

** Test framework

   The test suite is based on DejaGnu, for which you find the general
   documentation at
   https://www.gnu.org/software/dejagnu/manual/index.html

   The documentation of specific DejaGnu directives is at
   https://gcc.gnu.org/onlinedocs/gccint/Directives.html
   https://gcc.gnu.org/wiki/HowToPrepareATestcase

** Run selected tests

   Tests are categorized in different sub-directories. You can run
   run tests of a single category by running
     : make check RUNTESTFLAGS=CATEGORY.exp
   For example, to run tests of =pkl= in =poke.pkl= sub-directory, run:
     : make check RUNTESTFLAGS=pkl.exp
   You can also select tests using =TESTS= environment variable.
   As an example, to run all test files which start with =array=, you
   can run:
     : make check TESTS=array*.pk

** Unit Tests

   We are using DejaGnu's support for unit tests.  See
   =testsuite/poke.libpoke= for an example on how to write C unit
   tests.

** Naming Tests

   For testing a functionality =foo=, name your test =foo.pk= or
   =foo-N.pk= where =N= is a number.

   If the test is a =do-compile= whose compilation is expected to
   fail, name the test =func-diag.pk= or =func-diag-N.pk=.  Here
   "diag" means diagnostic.

** Always set obase

   If your test relies on printing integer values in the REPL (or
   using the =%v= formatting tag in a =printf=) please make sure to
   set an explicit output numerical base, like in:

   : /* { dg-command {.set obase 10} }  */

   This way, we won't have to change the tests if at some point we
   change the default obase.

** Put each test in its own file

   If you are writing tests for a specific functionality, like for
   example a standard function =foo=, it may seem logical to put all
   the tests in a single file =foo.pk= like:

   : /* { dg-do run } */
   :
   : /* { dg-command {foo (1)} } */
   : /* { dg-output "expected result" } */
   :
   : /* { dg-command {foo (1)} } */
   : /* { dg-output "\nexpected result" } */
   :
   : [... and so on ...]

   However, this is not a good idea.  If some of the "subtests" fail,
   it becomes difficult to determine which one is the culprit looking
   at the test log file.

   It is better to put each test in its own file: =foo-1.pk=,
   =foo-2.pk= and so on.

** List the test files in testsuite/Makefile.am

   So that the tests get distributed, you need to list each newly
   added test file in testsuite/Makefile.am.

  We have a syntax-check target that checks that EXTRA_DIST contains
  all the test files under `testsuite/', and that there is no test
  listed in EXTRA_DIST that doesn't exist in the file system.

** dg-output may require a newline

   If despite the advise above you really need to put more than
   dg-output in a dg-run test file, please be aware you need to prefix
   all of them (but the first one) with a newline, like in:

   : /* { dg-output "foo" } */
   : /* { dg-output "\nbar" } */
   : /* { dg-output "\n baz" } */

** Using data files in tests

   If your test requires mapping data, the dg-data directive is what
   you need.  It has two forms.

   The first form looks like:

   : /* { dg-data {c*} {0x10 0x20 0x30 0x40 ...} } */

   This creates a temporary file (whose name is irrelevant) and makes
   it the current IO space at poke initialization time.  The test
   body, and dg-commands, can then map on it.

   However, sometimes you need to map on several files.  In this case,
   you can have several dg-data entries with an additional argument,
   which is the name of the temporary file to create:

   : /* { dg-data {c*} {0x01 0x02 ...} foo.data } */
   : /* { dg-data {c*} {0x11 0x12 ...} bar.data } */
   :
   : [...]
   :
   : /* { dg-command { var foo = open ("foo.data") } } */

   The file created by the last dg-data (be it anonymous or named) is
   the current IO space.

** Using NBD connections in tests

   If your test requires an NBD server (only useful when poke is
   compiled with libnbd), the dg-nbd directive is what you need.  It
   has one form:

   : /* { dg-nbd { 0x1 0x2 ...} [dg-tmpdir]/sock } */

   This utilizes nbdkit to serve an in-memory disk with initial
   contents over a named Unix socket.  Note that the data argument is
   not the same as for dg-data (which uses tcl's binary command), but
   rather the syntax accepted by nbdkit-data-plugin's data= argument,
   although the two are similar.  nbdkit then creates a Unix socket
   server for the data, and will be shut down gracefully when the
   testsuite completes.  Use of the utility directive [dg-tmpdir]
   ensures that the socket name will not be too long while still
   respecting $TMPDIR (defaulting to a new subdirectory of /tmp),
   since $objdir may be arbitrarily deep.

   To use the server as an IO space, your test will then follow up
   with:

   : /* { dg-command "open (\"nbd+unix:///?socket=[dg-tmpdir]/sock\")" } */

** Writing tests that depend on a certain capability

   Sometimes the presence of the functionality tested may be optional.
   An example is testing the support for styling, which depends on
   poke to be built with libtextstyle support.

   The dg-require directive can be used for this purpose.  For
   example, the following test will be skipped (with status
   UNSUPPORTED) if the capability =libtextstyle= is not found in poke:

   : /* { dg-do run } */
   : /* { dg-options "--color=html" } */
   : /* { dg-require libtextstyle } */
   :
   : /* { dg-command {printf "%<foo:%i32d%>", 10} } */
   : /* { dg-output "<span class=\"foo\">10</span>" } */

   IMPORTANT NOTE: dg-require should appear before any dg-command
   directive in the test file.

   The supported capabilities are:

   - libtextstyle :: poke is built with libtextstyle support.
   - nbd :: poke is built with NBD io space support, and dg-nbd works.

** Writing REPL tests

   The =poke.repl= testsuite is intended to test features in the
   interactive usage of poke.  Therefore, it is not dg-based.
   Instead, it uses the services provided by =testsuite/lib/poke.exp=.
   In a nutshell, these services are:

   - poke_start :: Run a new poke process and wait at the prompt.
   - poke_exit :: Exit poke.
   - poke_test_cmd CMD PATTERN ::
     Send CMD to poke, and expect the result PATTERN.  CMD is sent as
     virtual keystrokes.  Therefore, sending \t or \n has the same
     effect on the REPL than typing TAB or RET in the keyboard,
     respectively.  PATTERN shouldn't include the prompt.
  - poke_send INPUT PATTERN :: Send INPUT to poke, and expect PATTERN as output.
  - poke_send_signal SIGNAL ::  Send SIGNAL to poke.

  Adding a new test to =poke.repl= involves editing
  =poke.repl/repl.exp= and adding some content there.  The following
  subsections detail how.

*** Command REPL tests

    Some REPL tests need to check whether poke replies properly to
    some sent command.  The =poke_test_cmd= procedure defined in
    =testsuite/lib/poke.exp= provides a convenient interface for this.

    For example:

    : set test "slashes are preserved"
    : poke_start
    : poke_test_cmd {4 / 2} {2}
    : poke_exit

    The snippet above implements a test named "slashes are preserved"
    that runs poke and sends the command =4 / 2= with expected result
    =2=.

    The dialogue when the test above is executed is:

    : (poke) 4 / 2
    : 2
    : (poke)

*** General REPL tests

    Other REPL tests are not about executing commands.  Suppose for
    example we want to test whether tab-completion works.  We would
    write something like:

    : set test "tab-completion-2"
    : poke_start
    : poke_send ".e\t\t" "\r\n.editor  .exit *\r\n$poke_prompt .e"
    : poke_exit

    The test above uses the =poke_send= procedure, defined in
    =testsuite/lib/poke.exp=.  This procedure gets two arguments: the
    input that is sent to poke, and the expected output.  Note how
    using =poke_send= doesn't require poke to execute any command.

    Using =poke_send= is more laborious than using =poke_test_cmd=: it
    is necessary to explicitly include the prompt in the expected
    output whenever needed.

    Note also how newlines are perceived by expect as the sequence
    =\r\n=.

** Testing Pickles

Each pickle in =pickles/FOO.pk= shall have a test file
=testsuite/poke.pickles/FOO-test.pk= written using pickle =pktest=.

If there are some features in the pickle that cannot be tested
using =pktest= (e.g., pickle uses =print=), that pickle also shall
have a testsuite in =testsuite/poke.FOO= with a driver
=testsuite/poke.FOO/FOO.exp=.

* Writing Documentation

** Documenting Pickles

   The chapter =Pickles= in the Poke manual contains several sections
   organized in thematic areas.  When adding a new pickle, find the
   area appropriate for the abstractions provided by the pickle (or
   create one if it doesn't exist already) and add a section for it.

   Please make sure to document any dependency of your pickle to other
   pickles.

   Keep a tutorial-like tone: for fine details, the user can always go
   and look to the pickle directly.

* Maintenance

  This section describes =make= targets that performs several
  maintenance tasks.

  - syntax-check ::
    Run several syntax-related checks in the source files.  It is
    useful to run this target before submitting code to be reviewed,
    and while reviewing other people's code.

    Note that sometimes the results have to be taken with a pinch of
    salt.  This happens, for example, when a rule oriented to C is
    applied to, say, an AWK file.  In these cases, consider adding a
    =.x-sc_*= fine-tuning file.  But please ask in poke-devel first.

    We provide a pre-push git hook that performs the syntax check
    right before pushing. If the check fails, the push is aborted. You
    should consider enabling this check by coping
    =etc/git-hooks/pre-push= to =.git/hooks/=.
  - coverage ::
    This target builds *poke* with code coverage support, runs the
    testsuite, and generates a nice html report under
    =$(top_builddir)/doc/coverage/=.  It is necessary to have the
    =lcov= program for this to work.  Note also that you need to have jitter
    configured to use a dispatch model other than no-threading.
  - cyclo-poke.html ::
    This target runs the pmccabe utility to calculate the modified
    cyclomatic complexity of the functions composing the poke sources,
    and generates a nice html report.
  - refresh-po ::
    This target download the latest available translations from the
    translation project and installs them in the source tree.
  - update-copyright ::
    Run this rule once per year (usually early in January) to update
    all the copyright years in the project.  By default this excludes
    all variants of COPYING.  Exceptions to this procedure (such as
    =ChangeLog..*= for rotated change logs) can be added in the file
    =.x-update-copyright=.

* Poke Architecture

  This figure depicts the overall architecture of poke:

#+BEGIN_EXAMPLE
  +----------+
  | compiler |
  +----------+      +------+
       |            |      |
       v            |      |
  +----------+      |      |
  |   PVM    | <--->|  IO  |
  +----------+      |      |
       ^            |      |
       |            |      |
       v            +------+
  +----------+
  | command  |
  +----------+
#+END_EXAMPLE

  The compiler, PVM and IO subsystems are provided by a shared library
  =libpoke=.

  The command subsystem resides in the =poke= executable.

* The Poke Compiler
** Compiler Overview

   This figure depicts the architecture of the compiler:

#+BEGIN_EXAMPLE
      /--------\
      | source |
      \---+----/
          |
          v
  +-----------------+
  |      Parser     |
  +-----------------+
  |  analysis and   |
  | transformation  |
  |     phases      |
  +-----------------+
  | code generation |
  |      phase      |
  +-----------------+
  | Macro assembler |
  +-----------------+
          |
          v
     /---------\
     | program |
     \---------/
#+END_EXAMPLE

** The bison Parser in pkl-tab.y

   The only purpose of the bison parser in pkl-tab.y is to do the
   syntactic analysis, build the initial AST, and set the locations of
   the AST nodes.

   Unfortunately, currently it also does some extra work, due to
   limitations in the LARL parser:

   - It builds the compile-time environment and register type, variable
     and function declarations.
   - It annotates variables with their lexical addresses.
   - It links return statements with their containing functions.
   - It annotates return statements with he number of lexical frames they
     should pop before exiting the function.

   As we shall see below, any further analysis and transformations on
   the AST are performed by the compiler phases, which are implemented
   elsewhere.  This greatly helps to keep the parser code clean and
   easy to read, and also eases changing the syntactic structure of
   poke programs.

** The AST

   The compiler operates on an abstract syntax tree that represent the
   program being compiled.  The following subsections discuss some
   useful aspects of the structure of the AST.

*** loop_stmt

    Loop statements are represented with trees like:

    : loop_stmt
    : |
    : +-- [iterator]
    : |       |
    : |       +-- decl
    : |       +-- container
    : |
    : +-- [condition]
    : +-- body

    Different kind of loop statements supported in Poke are
    represented including or not including optional fields.

    =while= statements with a condition:

    : while (CONDITION) BODY

    are represented as:

    : loop_stmt
    :     |
    :     +-- condition
    :     +-- body

    =for= statements without a condition:

    : for (;;) BODY

    are represented as:

    : loop_stmt
    :     |
    :     +-- body

    =for-in= statements:

    : for (VAR in CONTAINER) BODY

    are represented as:

    : loop_stmt
    :     |
    :     +-- iterator
    :     |      |
    :     |      +-- decl (VAR
    :     |      +-- container
    :     |
    :     +-- body

    =for-in-where= statements:

    : for (VAR in CONTAINER where SELECTOR) BODY

    are represented as:

    : loop_stmt
    :     |
    :     +-- iterator
    :     |      |
    :     |      +-- decl (VAR)
    :     |      +-- container
    :     |
    :     +-- condition (SELECTOR)
    :     +-- body

*** try_stmt

    There are several syntactic forms of this statement:

    : try CODE catch HANDLER
    : try CODE catch if EXP HANDLER
    : try CODE catch (ARG) HANDLER
    : try CODE until EXP

    try statements are represented with trees like:

    : try_stmt
    : |
    : +-- try_stmt_body
    : |   |
    : |   +-- code
    : |
    : +-- try_stmt_handler
    : |   |
    : |   +-- code
    : |
    : +-- [arg]
    : +-- [exp]

    where ARG and EXP are exclusive.

*** exp

    Expressions are the application of some *operator* to one or more
    *operators*.  The Poke language supports unary, binary and ternary
    operators.

    Expressions are represented with trees like:

    : exp
    : |
    : +-- code
    : +-- attr
    : +-- flag
    : +-- numops
    : +-- operands[3]
    :     |
    :     +-- [operand]
    :     +-- [operand]
    :     +-- [operand]

    Where =code= identifies the operator of the expression.  Operators
    are defined in the =libpoke/pkl-ops.def= file.

    If the operator is an attribute, then =attr= identifies the
    invoked attribute.  Attributes are defined in the
    =libpoke/pkl-attrs.def= file.  This field =attr= is initialized in
    the =trans1= phase.

    The =exp= AST node is used for all the Poke unary and binary
    operators, which only use two of the =operands=.

    Additionally, the application of an attribute to which an argument
    is passed, like in:

    : foo'elem (1)

    is encoded as an =exp= node with three operands: the first operand
    holds =foo=, the second operand an identifier for the attribute
    =elem= and the third operand the expression passed to the
    attribute (in this case =1=).  A handler in =trans1= transforms
    this ternary expression node in a binary expression, filling
    =attr= in the process.

    Note that the Poke ternary conditional operator =? := is *not*
    implemented using =exp= nodes, but =cond_exp= AST nodes.

*** cond_exp

    This AST node is used to encode Poke's ternary conditional
    operator, which looks like:

    : cond_exp ? then_exp : else_exp

    It uses trees like this:

    : cond_exp
    : |
    : +-- cond
    : +-- thenexp
    : +-- elseexp

** Lexical Handling

The parser needs to build the lexical enviroment as it works through
the source code.  This is because it needs to find the declarations of
all the entities referenced by variable names.  Also, the Poke syntax
requires to determine whether a given identifier is a type name or
not.  It uses a =pkl-env= for this, and it pushes and pops frames
according to the language rules.  The parser annotates each variable
reference with the declaration of the entity being referred, but does
not set the variable's lexical address.  This is because this address
may not be final, as we shall see below.  Once the parsing is done
successfully the lexical environment should consist on just the
top-level definitions, which is kept for the rest of the compilation.
But the inner frames are no longer available.

After the parser, the front-end compiler passes are run.  This
includes analysis and checking of language rules, transformation, type
analysis, constant folding, etc.  These passes can do arbitrary
transformations of the tree, and some of these transformations can
alter the lexical structure of the program.  The only exception is the
top-level environment.  Therefore, these passes shall not rely on the
lexical structure.

Finally, just before the code generator, a lexical pass is run.  This
pass contains a =transl= phase.  At this point no further
transformations of the AST will be performed and it is final.  The
=transl= phase reconstructs the lexical environment (the top-level
environment is preserved) and assigns the lexical addresses (back,
over) to all variable references.  It also performs a few language
rules checks that rely on the relative lexical position of entities.

** Compiler Passes and Phases

   These are the phases currently implemented in the poke compiler:

#+BEGIN_EXAMPLE
    [parser]
    --- Front-end pass
    trans1     Transformation phase 1.
    anal1      Analysis phase 1.
    typify1    Type analysis and transformation 1.
    promo      Operand promotion phase.
    trans2     Transformation phase 2.
    fold       Constant folding.
    trans3     Transformation phase 3.
    typify2    Type analysis and transformation 2.
    anal2      Analysis phase 2.
    --- Middle-end pass
    fold       Constant folding.
    trans4     Transformation phase 4.
    analf      Analysis final phase.
    --- Back-end pass
    gen        Code generation.
#+END_EXAMPLE

   The phases above are organized in several passes:

   - Pass1 :: trans1 anal1 typify1 promo trans2 fold trans3 typify2 anal2
   - Pass2 :: fold trans4 analf
   - Pass3 :: gen

*** Naming Conventions for Phases

    We use the following convention to name phases:

    : {NAME}{SUFFIX}

    where =NAME= reflects a phase category (see below) and =SUFFIX= is
    usually an integer that specifies the order in which the phases
    are applied.  Thus, for example, =name4= is performed after
    =name1=.  Sometimes, =SUFFIX= is =f= (meaning "final").

    The suffix is not used if there is only one phase in the given
    category.

    We use the following phase categories:

    - anal ::
      For phases whose main purpose is to perform checks on the AST,
      and/or the contents of the AST nodes, and emit errors/warnings.
    - trans ::
      For phases whose main purpose is to alter the structure of the
      AST, and/or the contents of the AST nodes.
    - typify ::
      For phases whose main purpose is to perform type checks, and
      otherwise do work on types.
    - promo ::
      For phases whose main purpose is to perform coercions wherever
      appropriate.  Currently there is only one phase in this
      category.
    - fold ::
      For phases whose main purpose is to pre-compute areas of the AST
      whenever it is possible to do so at compile-time.  Currently
      there is only one phase in this category, that performs constant
      folding.
    - gen ::
      For phases whose main purpose is to generate PVM code.
      Currently there is only one phase in this category.

    The phases in category =NAME= are implemented in the source files
    =libpoke/pkl-NAME.[ch]=.

*** Naming Conventions for Handlers

    We use the following convention to name phase handlers:

    : pkl_PHASE_{ps,pr}_NODE

    where =PHASE= can be a complete phase name (like =typify1=) if the
    handler is to be installed in that phase only, or a phase category
    name (like =typify=) if the handler is to be installed in several
    phases in that category.  If the phase is to be executed in
    pre-order, =pr= follows, otherwise, =ps=.  Finally, =NODE= is the
    name of the AST node.

    For example, the handler:

    : pkl_anal1_ps_comp_stmt

    is installed in the phase =anal1=, executes in post-order, and
    serves the AST nodes with code =PKL_AST_COMP_STMT=.

*** Front and Middle End Handlers should be Re-entrant

    When a type is referenced by name, for example in a map:

    : Foo @ 0#B

    The AST associated with the type is processed again thru the
    compiler middle-end phases.  This means that if a handler modifies
    an AST subtree, it should either do it in a way the new structure
    will be still valid if submitted to the same handler again.

    An example of this is the =pkl_trans1_ps_print_stmt= handler.

    More generally, the front-end and middle-end passes are
    restartable.  This means that every handler in these phases shall
    be re-entrant: if executed more than once, they should do The
    Right Thing (TM).

** Adding Compiler Built-Ins

   [NOTE: now that inline asm statements are supported, built-ins
    are implemented as immutable functions in the compiler runtime
    rt-pkl.pk.]

   Compiler built-ins are predefined functions, provided by the
   compiler, that generate particular assembler instructions.

   The first step in defining a new built-in is to make the lexer to
   recognize tokens of the form =__PKL_BUILTIN_NAME__= where =NAME= is
   some meaningful name, like for example =RAND=:

   : "__PKL_BUILTIN_RAND__" { return BUILTIN_RAND; }

   Then, add a new rule to the rule =comp_stmt= in the bison parser.
   Built-ins are equivalent to compound statements.  For example, this
   is the rule for the rand built-in:

   :      | pushlevel BUILTIN_RAND
   :     {
   :       $$ = pkl_ast_make_builtin (pkl_parser->ast,
   :                                  PKL_AST_BUILTIN_RAND);
   :       PKL_AST_LOC ($$) = @$;
   :
   :       /* Pop the frame pushed by the `pushlevel' above.  */
   :       pkl_parser->env = pkl_env_pop_frame (pkl_parser->env);
   :     }

   Next step is to generate the code for the built-in.  This is done
   expanding the =pkl_gen_ps_comp_stmt= rule in the code generation.
   Keep in mind that the generated code should conform a valid
   function body.  For example, this is the code generation part for
   rand:

   :      case PKL_AST_BUILTIN_RAND:
   :      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_RAND);
   :      pkl_asm_insn (PKL_GEN_ASM, PKL_INSN_RETURN);
   :      break;

   : The final step is to define the built-in function proper, in the
   : compiler run-time, in =pkl-rt-1.pk=:

   : fun rand = int<32>: __PKL_BUILTIN_RAND__;

** Writing Compiler Diagnostics

   Please follow the following guidelines when adding new errors or
   warnings to the poke compiler:

   - Make the diagnostic messages self-contained, i.e. do not rely on
     the extra location information to make the error intelligible.
     This is mainly for the sake of accessibility, and also for when
     poke is run in quiet mode.

     This is an example of a bad diagnostic:

     : error: field doesn't exist in struct

     Write something like this instead:

     : error: field `foo' doesn't exist in struct

   - When checking for the type of some ENTITY, please use a two-lines
     error message like:

     : error: invalid ENTITY
     : error: expected EXPECTED_TYPE, got ACTUAL_TYPE

     this is to keep some uniformity.  You can get the written
     representation of a type using the =pkl_type_str= utility
     function.

   - When referring to integer types in diagnostic messages, please
     refer to them as "integrals".

   - Always pass 1 for =use_given_name= when invoking =pkl_type_str=
     unless you need the expanded definition of the type for whatever
     reason (like to show the arguments taken by a function type.)

* The Poke Virtual Machine
** PVM types
*** How =any= is handed in the PVM

    The Poke type =any= is not implemented in the PVM as a PVM type
    value.  Instead, =null= is used to denote it, by convention.

    Note that it is not possible to use =void= to denote the Poke
    =any= type, because of closure types: a closure returning =void=
    is not the same than a closure returning =any=.

** Exception Handling

   Exception types or codes are signed 32-bit integers, and are
   defined in =libpoke/pkl-rt-1.pk= as =EC_*= variables.

   The exceptions themselves are struct values of type Exception, also
   defined in =libpoke/pkl-rt-1.pk=.

   There are two ways an exception can be raised in the PVM:

   - Explicitly, when the instruction =raise= is executed.
   - Implicitly, when some instruction needs to fail.  For example,
     an integer division instruction divides by zero.

   In either case, the treatment of a raised exception is the same:

   1. Pop an exception handler from the exception handler stack.
   2. If the exception handler matches the raised exception type, then
      i. Restore the heights of the main and return stacks.
      ii. Restore the dynamic environment.
      iii. Push the cached exception type to the stack.
      iv. Branch to the exception handler.
   3. Repeat.

   The default exception handler, which catches "unhandled"
   exceptions, is installed by the macro-assembler in
   =libpoke/pkl-asm.c:pkl_asm_new= and
   =libpoke/pkl-asm.c:pkl_asm_finish=.  It calls the function
   =_pkl_exception_handler=, that is defined in the compiler runtime
   in =libpoke/pkl-rt-1.pkl=.

** Signal Handling

   When the PVM is about to execute a program, it installs a signal
   handler that, at the moment, handles =SIGINT=.  This signal handler
   is defined in the =late-c= block in pvm.jitter, and records the
   signal in the PVM internal state.

   Then, when a =sync= instruction is executed, it checks the PVM
   internal state and raises a =PVM_E_SIGNAL= exception if there is
   some pending signal.  The default signal handler just ignores this
   signal, but the user can also intercept it if desired.  The PKL
   compiler generates =sync= instructions in strategic places, such as
   before backward jumps in loops.

   The =exit= PVM instruction clears the pending signals in the
   internal PVM state.

** Offsets and bit-offsets in the PVM

   The PVM supports a =pvm_off= boxed value, to denote pairs of
   magnitudes and units.  Both accessor macros (in =pvm-val.h=) and
   PVM instructions (=ogetm=, =ogetu=) are provided to access their
   components.

   Many other PVM entities need to denote offsets in a way or another.
   For example, struct fields in =pvm_struct= values need to record
   their relative offset with respect the beginning of the struct.

   It may come to mind, quite naturally, to use =pvm_off= values to
   denote these offsets.  It is very elegant.  However, we decided to
   use "bit offsets" instead, stored in 64-bit =pvm_long= values.

   There are two reasons for this:

   - First of all, performance.  It is fairly common to operate with
     the absolute value of these offsets, in bits.  In fact, in most
     cases that is the only purpose of maintaining them.  Having them
     stored in =pvm_off= values means we have to multiply every time
     we want to get their magnitude.  This is a waste, for no good
     reason.
   - To avoid code coupling.  PVM offsets are very cool, but they are
     also complex: the unit is arbitrary.  This means in many cases we
     have to assume the nature of the unit, mainly bits.  This is very
     fragile.

   So, the take-home message is: in the PVM, restrict the presence of
   =pvm_off= values to the ones generated by the code generator.
   Whenever an offset is needed in some internal PVM structure, use
   bit-offsets instead encoded as =ulong<64>= values.

** Writing relocatable instructions

   When operating in non-threaded mode, Jitter likes to move the code
   compiled for instruction bodies around.  This imposes several
   restrictions on what can you have in the instruction bodies:

   - If you call a global function from your instruction, please add
     it to the =wrapped-functions= section in the file.

   - Likewise, if you use a global variable, please add the variable
     to the =wrapped-globals= section.

   - Do not use any constant C string like ="foo"=; these are global
     variables in disguise and you cannot wrap them unless you give
     them a name.

   If you cannot follow the guidelines above for whatever reason,
   please mark the instruction as =non-relocatable= like this:

   : instruction foo ()
   :   non-relocatable
   :   code
   :     ...
   :   end
   : end

   This will prevent Jitter to relocate the instruction body and crash
   in many platforms and non-threading modes.

** Wrapping globals

   The non-threaded Jitter operation modes require every global
   (variable or function) to be wrapped, i.e. specified in sections
   =wrapped-functions= or =wrapped-globals= in =pvm.jitter=.

   Since it is not trivial to keep track of every used global, having
   hundred of instructions, we are providing a syntax-check that looks
   for this automatically.

   In order to avoid false positives, there are two files that we
   maintain by hand:

   - =etc/pvm-wraps-whitelist= contains a list of _global_ symbols
     that are used in pvm.jitter but are not required to be listed in
     neither =wrapped-function= nor =wrapped-globals=.  These are
     variables and functions that, despite being global and undefined,
     are not used _within_ PVM instructions.

  - =etc/pvm-wraps-static-whitelist= contains a list of _static_
    symbols that are defined in pvm.jitter and also listed in either
    =wrapped-functions= or =wrapped-globals=.  This includes for
    example the =pvm_*= wrappers we define in the file, to be used in
    PVM instructions.

*** Wrapping standard function calls

    If we need to call to a standard library function provided by the
    system (such as =printf=, =strstr=, or the like) from the body of
    a PVM instruction, we have to consider the possibility of gnulib
    replacing such function with another having a name like
    =rpl_printf= or =rpl_strstr=.

    Since the =wrapped-functions= list in pvm.jitter is static and the
    referred functions must exist, just wrapping the =rpl_*= symbols
    doesn't work.

    So instead, for every standard function =FOO= we call from PVM
    instructions, we:

    - Create a wrapper for it, called =pvm_FOO=, and put it in the
      pvm-wrappers.[ch] source files.
    - Use =pvm_FOO= in the PVM instruction.
    - Add =pvm_FOO= to the wrapped-functions section in pvm.jitter.

* Memory Management

  Different parts of poke use different strategies for memory
  management:

  - The compiler front-end uses reference counting to handle AST nodes.

  - The PVM uses the Boehm GC collector for values and the run-time
    environment.

  - Everything else uses =malloc=/=free=.

  This sometimes leads to tricky situations, some of which are
  documented in the subsections below.

** Using ASTREF


   The AST uses reference counting in order to manage the memory used
   by the nodes.  Every time you store a pointer to an AST node, you
   should use the =ASTREF= function in order to increase its counter:

   : pkl_ast_node foo = ASTREF (node);

   Note that the =pkl_ast_make_*= constructors do =ASTREF= internally,
   so you don't need to use it in calls like:

   : pkl_ast_node new = pkl_ast_make_struct (ast, 5, elems_node);

   To make sure you get the reference counting right, it's required to
   use the return value of =ASTREF= function. The compiler will warn
   you otherwise.

** Using ASTDEREF

   =ASTDEREF= decreases the reference counter of the provided AST
   node. It's required to use the return value of =ASTDEREF=. The
   compiler will warn you otherwise.

   In practice you will seldom find yourself in the need to use
   =ASTDEREF=.  Just make sure that every =ASTREF= is paired with a
   =pkl_ast_node_free=.

   However, there are situations where =ASTDEREF= is necessary in
   order to avoid a memory leak.  For example, consider
   transformations like =a -> b= to =a -> x -> b=.  In that case, you
   should use something like:

   : b = PKL_AST_KIND_WHAT (node);
   : x = pkl_ast_make_xxx (ast, ASTDEREF (b));
   : PKL_AST_KIND_WHAT (node) = ASTREF (x);

   This works because =pkl_ast_make_xxx= does an =ASTREF= to =b=
   internally.  The final result is that the reference counter of =b=
   doesn't change at all.

** PVM values in PVM programs

   PVM routines (data structures of type =pvm_routine=) are allocated
   by Jitter in complicated data structures, internally relying on
   =malloc=.  Their content is therefore not automatically visible to
   the GC.

   Now, the instructions in a routine can contain literal PVM values,
   and some of these values will be boxed.  For example, the following
   routine contains a pointer to a =pvm_val_box=:

   : ;; Initialize the element index to 0UL, and put it
   : ;; in a local.
   : push ulong<64>0
   : regvar $eidx

   There is only one place where jitter routines are stored in other
   data structures: the PVM program abstraction.

   PVM programs are allocated using =pvm_alloc=, i.e. by the GC.  They
   are composed by a PVM routine and other fields:

   : struct pvm_program
   : {
   :   pvm_routine routine;
   :   [...]
   : }

   However, since =routine= is malloc-allocated, the GC can't traverse
   it.  Consequently, the references to contained boxed values won't
   be accounted for, and these values will be collected if there are
   no more references to them!

   The solution, recommended by Luca Saiu, is to keep an array of
   pointers in the PVM program structure, containing the pointers to
   every boxed value used in =routine=:

   : struct pvm_program
   : {
   :   pvm_routine routine;
   :   void **pointers;
   :   [...]
   : };

   The pointers are collected in the =pvm-program.c= functions that
   append parameters to instructions.

** PVM values in AST nodes

   Storing a PVM value (whose memory is handled by GC) in an AST node
   (reference-counted) leads to a problem: the GC is unable to see the
   reference to values, and will therefore collect the memory if there
   are no other reachable references.

   Let's see an example of this.  Both array and struct types contain
   closures for mappers, writers, bounders, and the like.  For
   example, let's take arrays:

#+BEGIN_EXAMPLE
    struct pkl_ast_type
    {
        ...
        struct
        {
          union pkl_ast_node *bound;
          union pkl_ast_node *etype;
          pvm_val mapper;
          pvm_val writer;
          pvm_val bounder;
        } array;
    }
#+END_EXAMPLE

  In this case, =mapper=, =writer= and =bounder= are managed by GC.
  However, the contained =struct pkl_ast_type= is not.  There is no
  way the GC can find these nodes thru the AST node.

  The solution is to allocate memory for these values as
  "uncollectable".  This is done with =pvm_alloc_uncollectable.  For
  example:

#+BEGIN_EXAMPLE
pkl_ast_node
pkl_ast_make_array_type (pkl_ast ast, pkl_ast_node etype, pkl_ast_node bound)
{
  ...
  /* Prevent GC to collect these PVM values.  */
  PKL_AST_TYPE_A_CLOSURES (type)
      = pvm_alloc_uncollectable (nclosures * sizeof (pvm_val));
  PKL_AST_TYPE_A_MAPPER (type) = PVM_NULL;
  PKL_AST_TYPE_A_WRITER (type) = PVM_NULL;
  PKL_AST_TYPE_A_BOUNDER (type) = PVM_NULL;
  PKL_AST_TYPE_A_CONSTRUCTOR (type) = PVM_NULL;
  PKL_AST_TYPE_A_INTEGRATOR (type) = PVM_NULL;
  PKL_AST_TYPE_A_FORMATER (type) = PVM_NULL;
  PKL_AST_TYPE_A_PRINTER (type) = PVM_NULL;

  return type;
}
#+END_EXAMPLE

  And of course, before the memory of the AST node is freed, the
  uncollectable memory shall be explicitly fred in
  =pkl_ast_node_free=:

#+BEGIN_EXAMPLE
  void
  pkl_ast_node_free (pkl_ast_node ast)
  {
    ...
    case PKL_AST_TYPE:
      switch (PKL_AST_TYPE_CODE (ast))
        {
        ...
        case PKL_TYPE_ARRAY:
          pvm_free_uncollectable (PKL_AST_TYPE_A_CLOSURES (ast));
        }
  }
#+END_EXAMPLE

  If you add PVM values or PVM environments to an AST node, please
  follow the strategy above.

* Terminal Handling
** pk-term

   Writing to the terminal, and getting information from the terminal,
   is handled by the =pk-term= module.  It provides functions to:

   - Write strings to the standard output.

   - Write formatted strings to the standard output, ala =printf=.

   - Handle output "classes", which are the base of styling.

   Out terminal abstraction is implemented of top of GNU libtextstyle.
   In case it is not available when building poke, a dummy stub is
   provided by gnulib.  In that case output won't be styled, but poke
   will still compile and run properly.

** Styling Classes

  Styling is handled using "classes", which are identified by some
  string.  Using =pk_term= calls, enclosed environments can be
  defined:

  : pk_term_class ("foo");
  : /* Text emitted here has class "foo"  */
  : pk_term_class ("bar");
  : /* Text emitted here has class "foo" and "bar" */
  : pk_term_end_class ("bar");
  : pk_term_end_class ("foo");

  The =class= and =end_class= calls should be properly paired.

  The styling classes used in poke should be documented in the user
  manual, so the user will know what is suitable to be configured.
  Also, whenever possible a reasonable default shall be provided in
  =poke-default.css=.

** Debugging Styling

   As recommended in the libtextstyle manual, a good way to see the
   class hierarchy of some given output is to run poke passing the
   =--color=html= option:

   : $ poke --color=html
   : [...]
   : (poke) [1#B,2#B]
   : <span class="array">[<span class="offset"><span class="integer">0x1</span>#B</span>,<span class="offset"><span class="integer">0x2</span>#B</span>]</span><br/>(poke)
